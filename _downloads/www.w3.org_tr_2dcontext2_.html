<!-- http://www.w3.org/TR/2dcontext2/ -->
<!DOCTYPE html><html lang="en-US-x-Hixie"><head>
    <meta charset="utf-8">
    <title>HTML Canvas 2D Context, Level 2
    </title>
    <style type="text/css">

     .applies thead th > * { display: block; }
     .applies thead code { display: block; }
     .applies tbody th { white-space: nowrap; }
     .applies td { text-align: center; }
     .applies .yes { background: yellow; }

     .matrix, .matrix td { border: hidden; text-align: right; }
     .matrix { margin-left: 2em; }

     .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
     .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
     .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

     td.eg { border-width: thin; text-align: center; }

     #table-example-1 { border: solid thin; border-collapse: collapse; margin-left: 3em; }
     #table-example-1 * { font-family: "Essays1743", serif; line-height: 1.01em; }
     #table-example-1 caption { padding-bottom: 0.5em; }
     #table-example-1 thead, #table-example-1 tbody { border: none; }
     #table-example-1 th, #table-example-1 td { border: solid thin; }
     #table-example-1 th { font-weight: normal; }
     #table-example-1 td { border-style: none solid; vertical-align: top; }
     #table-example-1 th { padding: 0.5em; vertical-align: middle; text-align: center; }
     #table-example-1 tbody tr:first-child td { padding-top: 0.5em; }
     #table-example-1 tbody tr:last-child td { padding-bottom: 1.5em; }
     #table-example-1 tbody td:first-child { padding-left: 2.5em; padding-right: 0; width: 9em; }
     #table-example-1 tbody td:first-child::after { content: leader(". "); }
     #table-example-1 tbody td { padding-left: 2em; padding-right: 2em; }
     #table-example-1 tbody td:first-child + td { width: 10em; }
     #table-example-1 tbody td:first-child + td ~ td { width: 2.5em; }
     #table-example-1 tbody td:first-child + td + td + td ~ td { width: 1.25em; }

     .apple-table-examples { border: none; border-collapse: separate; border-spacing: 1.5em 0em; width: 40em; margin-left: 3em; }
     .apple-table-examples * { font-family: "Times", serif; }
     .apple-table-examples td, .apple-table-examples th { border: none; white-space: nowrap; padding-top: 0; padding-bottom: 0; }
     .apple-table-examples tbody th:first-child { border-left: none; width: 100%; }
     .apple-table-examples thead th:first-child ~ th { font-size: smaller; font-weight: bolder; border-bottom: solid 2px; text-align: center; }
     .apple-table-examples tbody th::after, .apple-table-examples tfoot th::after { content: leader(". ") }
     .apple-table-examples tbody th, .apple-table-examples tfoot th { font: inherit; text-align: left; }
     .apple-table-examples td { text-align: right; vertical-align: top; }
     .apple-table-examples.e1 tbody tr:last-child td { border-bottom: solid 1px; }
     .apple-table-examples.e1 tbody + tbody tr:last-child td { border-bottom: double 3px; }
     .apple-table-examples.e2 th[scope=row] { padding-left: 1em; }
     .apple-table-examples sup { line-height: 0; }

     .details-example img { vertical-align: top; }

     #base64-table {
       white-space: nowrap;
       font-size: 0.6em;
       column-width: 6em;
       column-count: 5;
       column-gap: 1em;
       -moz-column-width: 6em;
       -moz-column-count: 5;
       -moz-column-gap: 1em;
       -webkit-column-width: 6em;
       -webkit-column-count: 5;
       -webkit-column-gap: 1em;
     }
     #base64-table thead { display: none; }
     #base64-table * { border: none; }
     #base64-table tbody td:first-child:after { content: ':'; }
     #base64-table tbody td:last-child { text-align: right; }

     #named-character-references-table {
       white-space: nowrap;
       font-size: 0.6em;
       column-width: 30em;
       column-gap: 1em;
       -moz-column-width: 30em;
       -moz-column-gap: 1em;
       -webkit-column-width: 30em;
       -webkit-column-gap: 1em;
     }
     #named-character-references-table > table > tbody > tr > td:first-child + td,
     #named-character-references-table > table > tbody > tr > td:last-child { text-align: center; }
     #named-character-references-table > table > tbody > tr > td:last-child:hover > span { position: absolute; top: auto; left: auto; margin-left: 0.5em; line-height: 1.2; font-size: 5em; border: outset; padding: 0.25em 0.5em; background: white; width: 1.25em; height: auto; text-align: center; }
     #named-character-references-table > table > tbody > tr#entity-CounterClockwiseContourIntegral > td:first-child { font-size: 0.5em; }

     .glyph.control { color: red; }

     @font-face {
       font-family: 'Essays1743';
       src: url('fonts/Essays1743.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-weight: bold;
       src: url('fonts/Essays1743-Bold.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-style: italic;
       src: url('fonts/Essays1743-Italic.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-style: italic;
       font-weight: bold;
       src: url('fonts/Essays1743-BoldItalic.ttf');
     }

    </style>
    <style type="text/css">
       pre { margin-left: 2em; white-space: pre-wrap; }
       h2 { margin: 3em 0 1em 0; }
       h3 { margin: 2.5em 0 1em 0; }
       h4 { margin: 2.5em 0 0.75em 0; }
       h5, h6 { margin: 2.5em 0 1em; }
       h1 + h2, h1 + h2 + h2, h1 + p, h1 + p + h2 { margin: 0.75em 0 0.75em; }
       h2 + h3, h3 + h4, h4 + h5, h5 + h6 { margin-top: 0.5em; }
       p { margin: 1em 0; }
       hr:not(.top) { display: block; background: none; border: none; padding: 0; margin: 2em 0; height: auto; }
       .element dd,  .element dl { margin-top: 0em; margin-bottom: 0.25em;}
       dt { margin-top: 0.75em; margin-bottom: 0.5em; clear: left; }
        .element dt { margin-top: 0.5em; margin-bottom: 0.5em;  }
       dt + dt { margin-top: 0; }
       dd dt { margin-top: 0.25em; margin-bottom: 0; }
       dd p { margin-top: 0; }
       dd dl + p { margin-top: 1em; }
       dd table + p { margin-top: 1em; }
       p + * > li, dd li { margin: 1em 0; }
       dt, dfn { font-weight: bold; font-style: normal; }
       i, em { font-style: italic; }
       dt dfn { font-style: italic; }
       pre, code { font-size: inherit; font-family: monospace; font-variant: normal; }
       pre strong { color: black; font: inherit; font-weight: bold; background: yellow; }
       pre em { font-weight: bolder; font-style: normal; }
       @media screen { code { color: #D93B00; } code :link, code :visited { color: inherit; } }
       var { background-color: #f9f9f9; border: 1px solid #eee; padding: 0 2px; }
       var sub { vertical-align: bottom; font-size: smaller; position: relative; top: 0.1em; }
       table { border-collapse: collapse; border-style: hidden hidden none hidden; }
       table thead, table tbody { border-bottom: solid; }
       table tbody th:first-child { border-left: solid; }
       table tbody th { text-align: left; }
       table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
       blockquote { margin: 0 0 0 2em; border: 0; padding: 0; font-style: italic; }

       .bad, .bad *:not(.XXX) { color: #5F6D7A; border-color: gray; background: transparent; }
       .matrix, .matrix td { border: none; text-align: right; }
       .matrix { margin-left: 2em; }
       .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
       .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
       .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

       .toc dfn, h1 dfn, h2 dfn, h3 dfn, h4 dfn, h5 dfn, h6 dfn { font: inherit; }
       img.extra, p.overview { float: right; }
       pre.idl { border: solid thin #d3d3d3; background: #FCFCFC; color: black; padding: 0.5em 1em; position: relative; }
       pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
       pre.idl::before { content: "IDL"; font: bold small sans-serif; padding: 0.5em; background: white; position: absolute; top: 0; margin: -1px 0 0 -4em; width: 1.5em; border: thin solid; border-radius: 0 0 0 0.5em }
       pre.css { border: solid thin; background: #FFFFEE; color: black; padding: 0.5em 1em; }
       pre.css:first-line { color: #AAAA50; }
       dl.domintro {padding: 0.5em 1em; border: none; background:#E9FBE9; border: 1px solid lightgray; }
       hr + dl.domintro, div.impl + dl.domintro { margin-top: 2.5em; margin-bottom: 1.5em; }
       dl.domintro dt, dl.domintro dt * { color: black; text-decoration: none; }
       dl.domintro dd { margin: 0.5em 0 1em 2em; padding: 0; }
       dl.domintro dd p { margin: 0.5em 0; }
       dl.domintro:before { display: table; margin: -1em -0.5em -0.5em auto; width: auto; content: 'This definition is non-normative. Implementation requirements are given below this definition.'; color: #606060; border:1px solid lightgray; background: white; padding: 0 0.25em;font-size:.9em;}
       dl.switch { padding-left: 2em; }
       dl.switch > dt { text-indent: -1.5em; }
       dl.switch > dt:before { content: '\21AA'; padding: 0 0.5em 0 0; display: inline-block; width: 1em; text-align: right; line-height: 0.5em; }
       dl.triple { padding: 0 0 0 1em; }
       dl.triple dt, dl.triple dd { margin: 0; display: inline }
       dl.triple dt:after { content: ':'; }
       dl.triple dd:after { content: '\A'; white-space: pre; }
       .diff-old { text-decoration: line-through; color: silver; background: transparent; }
       .diff-chg, .diff-new { text-decoration: underline; color: green; background: transparent; }
       a .diff-new { border-bottom: 1px blue solid; }

       figure.diagrams { border: double black; background: white; padding: 1em; }
       figure.diagrams img { display: block; margin: 1em auto; } 

       h2 { page-break-before: always; }
       h1, h2, h3, h4, h5, h6 { page-break-after: avoid; }
       h1 + h2, hr + h2.no-toc { page-break-before: auto; }

       p  > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]):not([class="t2"]):not([id]):not([lang]),
       li > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]):not([class="t2"]):not([id]):not([lang])
       { border-bottom: solid #9999CC; }

       div.head { margin: 0 0 1em; padding: 1em 0 0 0; }
       div.head p { margin: 0; }
       div.head h1 { margin: 0; }
       div.head .logo { float: right; margin: 0 1em; }
       div.head .logo img { border: none } /* remove border from top image */
       div.head dl { margin: 1em 0; }
       div.head p.copyright, div.head p.alt { font-size: x-small; font-style: oblique; margin: 0; }

       body > .toc > li { margin-top: 1em; margin-bottom: 1em; }
       body > .toc.brief > li { margin-top: 0.35em; margin-bottom: 0.35em; }
       body > .toc > li > * { margin-bottom: 0.5em; }
       body > .toc > li > * > li > * { margin-bottom: 0.25em; }
       .toc, .toc li { list-style: none; }

       .brief { margin-top: 1em; margin-bottom: 1em; line-height: 1.1; }
       .brief li { margin: 0; padding: 0; }
       .brief li p { margin: 0; padding: 0; }

       .category-list { margin-top: -0.75em; margin-bottom: 1em; line-height: 1.5; }
       .category-list::before { content: '\21D2\A0'; font-size: 1.2em; font-weight: 900; }
       .category-list li { display: inline; }
       .category-list li:not(:last-child)::after { content: ', '; }
       .category-list li > span, .category-list li > a { text-transform: lowercase; }
       .category-list li * { text-transform: none; } /* don't affect <code> nested in <a> */

       .XXX { color: #E50000; background: white; border: solid red; padding: 0.5em; margin: 1em 0; }
       .XXX > :first-child { margin-top: 0; }
       p .XXX { line-height: 3em; }
       .annotation { border: solid thin black; background: #0C479D; color: white; position: relative; margin: 8px 0 20px 0; }
       .annotation:before { position: absolute; left: 0; top: 0; width: 100%; height: 100%; margin: 6px -6px -6px 6px; background: #333333; z-index: -1; content: ''; }
       .annotation :link, .annotation :visited { color: inherit; }
       .annotation :link:hover, .annotation :visited:hover { background: transparent; }
       .annotation span { border: none ! important; }
       .note { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
       .warning { background-color: #F9F0D4; border: medium double #FF0000; margin: 1em; padding: 1em; }
       .note em, .warning em, .note i, .warning i { font-style: normal; }
       p.note, div.note { padding: 0.5em 2em; }
       span.note { padding: 0 2em; }
       .note p:first-child, .warning p:first-child { margin-top: 0; }
       .note p:last-child, .warning p:last-child { margin-bottom: 0; }
       .warning:before { font-style: normal; }
       p.note:before { content: 'Note: '; font-weight: bolder;}
       p.warning:before { content: '\26A0 Warning! '; font-weight:bolder;}
       .critical {margin:1em; border:double red; padding:1em; background-color:#F9F0D4;}

       .bookkeeping:before { display: block; content: 'Bookkeeping details'; font-weight: bolder; font-style: italic; }
       .bookkeeping { font-size: 0.8em; margin: 2em 0; }
       .bookkeeping p { margin: 0.5em 2em; display: list-item; list-style: square; }
       .bookkeeping dt { margin: 0.5em 2em 0; }
       .bookkeeping dd { margin: 0 3em 0.5em; }

       h4 { position: relative; z-index: 3; }
       h4 + .element, h4 + div + .element { margin-top: -2.5em; padding-top: 2em; }
       .element {
         background: #F4F4FA;
         color: black;
         margin: 0 0 1em 0.15em;
         padding: 0 1em 0.25em 0.75em;
         border-left: solid #9999FF 0.25em;
         position: relative;
         z-index: 1;
       }
       .element:before {
         position: absolute;
         z-index: 2;
         top: 0;
         left: -1.15em;
         height: 2em;
         width: 0.9em;
         background: #F4F4FA;
         content: ' ';
         border-style: none none solid solid;
         border-color: #9999FF;
         border-width: 0.25em;
       }

       .example { display: block; color: #222222; background: #FCFCFC; border-left-style: solid;border-color:#c0c0c0; border-left-width: 0.25em; margin-left: 1em; padding-left: 1em;padding-bottom: 0.5em;}
       div.example:before { content: 'Code Example: '; font-weight: bolder;}
       td > .example:only-child { margin: 0 0 0 0.1em; }

       ul.domTree, ul.domTree ul { padding: 0 0 0 1em; margin: 0; }
       ul.domTree li { padding: 0; margin: 0; list-style: none; position: relative; }
       ul.domTree li li { list-style: none; }
       ul.domTree li:first-child::before { position: absolute; top: 0; height: 0.6em; left: -0.75em; width: 0.5em; border-style: none none solid solid; content: ''; border-width: 0.1em; }
       ul.domTree li:not(:last-child)::after { position: absolute; top: 0; bottom: -0.6em; left: -0.75em; width: 0.5em; border-style: none none solid solid; content: ''; border-width: 0.1em; }
       ul.domTree span { font-style: italic; font-family: serif; }
       ul.domTree .t1 code { color: purple; font-weight: bold; }
       ul.domTree .t2 { font-style: normal; font-family: monospace; }
       ul.domTree .t2 .name { color: black; font-weight: bold; }
       ul.domTree .t2 .value { color: blue; font-weight: normal; }
       ul.domTree .t3 code, .domTree .t4 code, .domTree .t5 code { color: gray; }
       ul.domTree .t7 code, .domTree .t8 code { color: green; }
       ul.domTree .t10 code { color: teal; }

       body.dfnEnabled dfn { cursor: pointer; }
       .dfnPanel {
         display: inline;
         position: absolute;
         z-index: 10;
         height: auto;
         width: auto;
         padding: 0.5em 0.75em;
         font: small sans-serif, Droid Sans Fallback;
         background: #DDDDDD;
         color: black;
         border: outset 0.2em;
       }
       .dfnPanel * { margin: 0; padding: 0; font: inherit; text-indent: 0; }
       .dfnPanel :link, .dfnPanel :visited { color: black; }
       .dfnPanel p { font-weight: bolder; }
       .dfnPanel * + p { margin-top: 0.25em; }
       .dfnPanel li { list-style-position: inside; }

       #configUI { position: absolute; z-index: 20; top: 10em; right: 1em; width: 11em; font-size: small; }
       #configUI p { margin: 0.5em 0; padding: 0.3em; background: #EEEEEE; color: black; border: inset thin; }
       #configUI p label { display: block; }
       #configUI #updateUI, #configUI .loginUI { text-align: center; }
       #configUI input[type=button] { display: block; margin: auto; }

       fieldset { margin: 1em; padding: 0.5em 1em; }
       fieldset > legend + * { margin-top: 0; }
       fieldset > :last-child { margin-bottom: 0; }
       fieldset p { margin: 0.5em 0; }
       header p.subline {color:#005A9C; font: 140% sans-serif;margin: 0.75em 0;}
       #authorButton {overflow: visible; padding: 0.1em 0.3em; position: fixed; right: 2em; top: 6em; width: auto;}

       @media print {#authorButton { display:none;}}

   .stability {
     position: fixed;
     bottom: 0;
     left: 0; right: 0;
     margin: 0 auto 0 auto;
     width: 50%;
     background: maroon; color: yellow;
     -webkit-border-radius: 1em 1em 0 0;
     -moz-border-radius: 1em 1em 0 0;
     border-radius: 1em 1em 0 0;
     -moz-box-shadow: 0 0 1em #500;
     -webkit-box-shadow: 0 0 1em #500;
     box-shadow: 0 0 1em red;
     padding: 0.5em 1em;
     text-align: center;
   }
   .stability strong {
     display: block;
   }
   .stability input {
     -moz-appearance: none; -webkit-appearance: none; margin: 0; 
     border: 0; padding: 0.25em 0.5em; background: transparent; color: black;
     position: absolute; top: -0.5em; right: 0; font: 1.25em sans-serif; text-align: center;
   }
   .stability input:hover {
     color: white;
     text-shadow: 0 0 2px black;
   }
   .stability input:active {
     padding: 0.3em 0.45em 0.2em 0.55em;
   }
   .stability :link, .stability :visited,
   .stability :link:hover, .stability :visited:hover {
     background: transparent;
     color: white;
   }

  </style>
  <link href="http://www.w3.org/StyleSheets/TR/W3C-WD" rel="stylesheet" type="text/css">


  <script>
   function getCookie(name) {
     var params = location.search.substr(1).split("&");
     for (var index = 0; index < params.length; index++) {
       if (params[index] == name)
         return "1";
       var data = params[index].split("=");
       if (data[0] == name)
         return unescape(data[1]);
     }
     var cookies = document.cookie.split("; ");
     for (var index = 0; index < cookies.length; index++) {
       var data = cookies[index].split("=");
       if (data[0] == name)
         return unescape(data[1]);
     }
     return null;
   }
  </script>
  
   </head>
 <body>
  <div class="head" id="head">
<header>

   <p><a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72"></a></p>

    <h1>HTML Canvas 2D Context, Level 2
    </h1>
   <h2 class="no-num no-toc" id="w3c-working-draft-28-august-2014">W3C Working Draft 28 August 2014</h2>
   </header>
<dl>
    <dt>This Version:</dt>
    <dd><a href="http://www.w3.org/TR/2014/WD-2dcontext2-20140828/">http://www.w3.org/TR/2014/WD-2dcontext2-20140828/</a></dd>
    <dt>Latest Published Version:</dt>
    <dd><a href="http://www.w3.org/TR/2dcontext2/">http://www.w3.org/TR/2dcontext2/</a></dd>
    <dt>Latest Editor's Draft:</dt>
    <dd><a class="latest-link" href="http://www.w3.org/html/wg/drafts/2dcontext/master/">http://www.w3.org/html/wg/drafts/2dcontext/master/</a></dd>

      <dt>Previous Version:</dt>
      <dd><a href="http://www.w3.org/TR/2013/WD-2dcontext2-20131029/">http://www.w3.org/TR/2013/WD-2dcontext2-20131029/</a></dd>
      <dt id="specification-editors">Editors:</dt>
      <dd>W3C:</dd>
      <dd><a href="mailto:cabanier@adobe.com">Rik Cabanier</a>, Adobe Systems, Inc.</dd>
      <dd><a href="mailto:jmann@microsoft.com">Jatinder Mann</a>, Microsoft Corporation</dd>
      <dd><a href="mailto:jaymunro@microsoft.com">Jay Munro</a>, Microsoft Corporation</dd>
      <dd><a href="mailto:wiltzius@google.com">Tom Wiltzius</a>, Google, Inc.</dd>
      <dd>WHATWG:</dd>
      <dd><a href="mailto:ian@hixie.ch">Ian Hickson</a>, Google, Inc.</dd>
   </dl>
   <p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
   © 2014 <a href="http://www.w3.org/"><abbr title="World Wide
   Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts
   Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research
   Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C
   <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
   <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
   and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document
   use</a> rules apply.</p>

</div>
  

  <hr class="top">


  <h2 class="no-num no-toc" id="abstract">Abstract</h2>

  <p>This specification defines the 2D Context for the HTML
  <code>canvas</code> element. The 2D Context provides
   objects, methods, and properties to draw and manipulate 
   graphics on a <code>canvas</code> drawing surface.</p>

  <h2 class="no-num no-toc" id="status-of-this-document">Status of This document</h2>

    <!-- intro boilerplate (required) -->

    <p>
      <em>This section describes the status of this document at the time of its publication. 
      Other documents may supersede this document. A list of current W3C publications and the 
      latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C 
      technical reports index</a> at http://www.w3.org/TR/.</em>
    </p>

    <!-- where to send feedback (required) -->

    <p>If you wish to make comments regarding this document in a manner
    that is tracked by the W3C, please submit them via using <a href="http://www.w3.org/Bugs/Public/enter_bug.cgi?product=HTML%20WG">our
    public bug database</a>. If you cannot do this then you can also e-mail feedback to <a href="mailto:public-html-comments@w3.org">public-html-comments@w3.org</a>
    (<a href="mailto:public-html-comments-request@w3.org?subject=subscribe">subscribe</a>,
    <a href="http://lists.w3.org/Archives/Public/public-html-comments/">archives</a>),
    and arrangements will be made to transpose the comments to our
    public bug database. All feedback is welcome.</p>

            <p>
      Work on extending this specification typically proceeds through
      <a href="http://www.w3.org/html/wg/wiki/ExtensionSpecifications">extension specifications</a>
      which should be consulted to see what new features are being reviewed.
    </p>
               <!-- UNDER NO CIRCUMSTANCES IS THE FOLLOWING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
       <p class="alt">The bulk of the text of this specification is also
       available in the WHATWG <a href="http://www.whatwg.org/specs/web-apps/current-work/complete.html#2dcontext">HTML Living Standard</a>, under a license that permits reuse of the
       specification text.</p>
       <!-- UNDER NO CIRCUMSTANCES IS THE PRECEDING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
    
  <!-- UNDER NO CIRCUMSTANCES IS THE FOLLOWING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->  
    <p>The working groups maintains <a href="https://www.w3.org/Bugs/Public/buglist.cgi?component=HTML%20Canvas%202D%20Context&amp;list_id=41062&amp;product=HTML%20WG&amp;resolution=---">a
  list of all bug reports that the editors have not yet tried to
  address</a> and <a href="http://www.w3.org/html/wg/tracker/products/1">a list of issues
  for which the chairs have not yet declared a decision</a>.
  You are very welcome to <a href="https://www.w3.org/Bugs/Public/enter_bug.cgi?product=HTML%20WG&amp;component=HTML5%20spec&amp;priority=P3">file a new bug</a>
  for any problem you may encounter.
   These bugs and
  issues apply to multiple HTML-related specifications,
  not just this one.</p>
  <!-- UNDER NO CIRCUMSTANCES IS THE PRECEDING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->


    <!-- stability (required) -->


  <div id="multipage-common">
  <!-- stability warning for TR/ page version -->
  <!-- q.v. http://lists.w3.org/Archives/Public/public-html/2010Oct/0457.html -->
  <p class="stability" id="wip"><strong>This is a work in
  progress!</strong> For the latest updates from the HTML WG, possibly
  including important bug fixes, please look at the <a href="http://www.w3.org/html/wg/drafts/2dcontext/master/">editor's draft</a> instead.
  <input onclick="closeWarning(this.parentNode)" type="button" value="X">
  </p>
  <script>
   function closeWarning(element) {
     element.parentNode.removeChild(element);
     var date = new Date();
     date.setDate(date.getDate()+4);
     document.cookie = 'hide-obsolescence-warning=1; expires=' + date.toGMTString();
   }
   function removeWIP () {
       document.getElementById('wip').parentNode.removeChild(document.getElementById('wip'));
   }
   if (document.documentElement.getAttribute("data-wip") === "false") removeWIP();
   if (getCookie('hide-obsolescence-warning') == '1') setTimeout(removeWIP, 2000);
  </script>
  </div>
  

  <p>Publication as a Working Draft does not imply endorsement by the W3C Membership.
  This is a draft document and may be updated, replaced or obsoleted by other documents at
  any time. It is inappropriate to cite this document as other than work in progress.</p>

  <!-- version history or list of changes (required) -->
  <p>The latest stable version of the editor's draft of this
  specification is always available on <a href="https://github.com/w3c/html">the W3C HTML git repository</a>.
  </p>

  <!-- status of document, group responsible (required) -->
  <p>The W3C <a href="http://www.w3.org/html/wg/">HTML Working
  Group</a> is the W3C working group responsible for this
  specification's progress.
  This specification is the 28 August 2014 Working Draft.
        This specification is intended to become a W3C Recommendation.
      </p>
  
  <!-- relationship to other work (required) -->

    <p>Work on this specification is also done at the <a href="http://www.whatwg.org/">WHATWG</a>. The W3C HTML working group actively pursues convergence of the 
  HTML specification with the WHATWG living standard, within the bounds of the <a href="http://www.w3.org/2013/09/html-charter.html">W3C HTML working
  group charter</a>. There are various ways to follow this work at the WHATWG:</p>
  <ul>
      <li>Commit-Watchers mailing list (complete source diffs): <a href="http://lists.whatwg.org/listinfo.cgi/commit-watchers-whatwg.org">http://lists.whatwg.org/listinfo.cgi/commit-watchers-whatwg.org</a></li>
      <li>Annotated summary with unified diffs: <a href="http://html5.org/tools/web-apps-tracker">http://html5.org/tools/web-apps-tracker</a></li>
      <li>Raw Subversion interface: <code>svn checkout http://svn.whatwg.org/webapps/</code></li>
  </ul>
    

  <!-- UNDER NO CIRCUMSTANCES IS THE PRECEDING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
  <!-- context and rationale (required) -->
  <!-- (this text is from the RDFa+HTML spec -->
  <p>This specification is an extension to the HTML5 language. All
  normative content in the HTML5 specification, unless specifically
  overridden by this specification, is intended to be the basis for
  this specification.</p>
  <!-- UNDER NO CIRCUMSTANCES IS THE FOLLOWING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->



  <!-- required patent boilerplate -->
  <p>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5
  February 2004 W3C Patent Policy</a>. W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/40318/status" rel="disclosure">public list of
  any patent disclosures</a> made in connection with the deliverables
  of the group; that page also includes instructions for disclosing a
  patent. An individual who has actual knowledge of a patent which the
  individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
  Claim(s)</a> must disclose the information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
  6 of the W3C Patent Policy</a>.</p>

<div>
  <p>Implementors should be aware that this specification is not
  stable. <strong>Implementors who are not taking part in the
  discussions are likely to find the specification changing out from
  under them in incompatible ways.</strong> Vendors interested in
  implementing this specification before it eventually reaches the
  Candidate Recommendation stage should join the aforementioned
  mailing lists and take part in the discussions.</p>
  <p>
    The following features are <strong>experimental</strong> and have not been discussed by the working group or implemented.
  </p>
  <ul>
    <li>
      The following methods that operate on Path2D objects: <code>addText(path, ...)</code>, and
 <code>addPathByStrokingText(path, styles, ...)</code>
	</li>
    <li>
	  The fillRule constructor for Path2D: <code>Path2D(path [, fillRule])</code>
	</li>	
    <li>
      <a href="#drawingstyle">DrawingStyle</a>
    </li>
	<li>
      <code>resetClip</code>
    </li>
    <li>
      All attributes of the <a href="#textmetrics">Text metrics</a> object except <a href="#dom-textmetrics-width">'width'</a>
    </li>
    <li>
      <a href="#dom-context-2d-ellipse">Ellipse</a>
    </li>
    <li>
      The constructor for <code>CanvasRenderingContext2D</code>
    </li>
	<li>
	  The <a href="#dom-context-2d-commit">Commit</a>  method and all related language
	</li>
	<li>
	  Bound and unbound rendering contexts 
	</li>
  </ul>
</div>


  <h2 class="no-num no-toc" id="contents">Table of Contents</h2>

<!--begin-toc-->
<ul class="toc">
 <li><a href="#conformance-requirements"><span class="secno">1 </span>Conformance requirements</a>
  <ul class="toc">
   <li><a href="#2dcontext"><span class="secno">1.1 </span>The 2D rendering context</a>
    <ul class="toc">
     <li><a href="#implementation-notes"><span class="secno">1.1.1 </span>Implementation notes</a></li>
     <li><a href="#the-canvas-state"><span class="secno">1.1.2 </span>The canvas state</a></li>
     <li><a href="#drawingstyle-objects"><span class="secno">1.1.3 </span><code>DrawingStyle</code> objects</a></li>
     <li><a href="#line-styles"><span class="secno">1.1.4 </span>Line styles</a></li>
     <li><a href="#text-styles"><span class="secno">1.1.5 </span>Text styles</a></li>
     <li><a href="#building-paths"><span class="secno">1.1.6 </span>Building paths</a></li>
     <li><a href="#path2d-objects"><span class="secno">1.1.7 </span><code>Path2D</code> objects</a></li>
     <li><a href="#transformations"><span class="secno">1.1.8 </span>Transformations</a></li>
     <li><a href="#image-sources-for-2d-rendering-contexts"><span class="secno">1.1.9 </span>Image sources for 2D rendering contexts</a></li>
     <li><a href="#fill-and-stroke-styles"><span class="secno">1.1.10 </span>Fill and stroke styles</a></li>
     <li><a href="#drawing-rectangles-to-the-bitmap"><span class="secno">1.1.11 </span>Drawing rectangles to the bitmap</a></li>
     <li><a href="#drawing-text-to-the-bitmap"><span class="secno">1.1.12 </span>Drawing text to the bitmap</a></li>
     <li><a href="#drawing-paths-to-the-canvas"><span class="secno">1.1.13 </span>Drawing paths to the canvas</a></li>
     <li><a href="#drawing-images"><span class="secno">1.1.14 </span>Drawing images</a></li>
     <li><a href="#hit-regions"><span class="secno">1.1.15 </span>Hit regions</a></li>
     <li><a href="#pixel-manipulation"><span class="secno">1.1.16 </span>Pixel manipulation</a></li>
     <li><a href="#compositing"><span class="secno">1.1.17 </span>Compositing</a></li>
     <li><a href="#image-smoothing"><span class="secno">1.1.18 </span>Image smoothing</a></li>
     <li><a href="#shadows"><span class="secno">1.1.19 </span>Shadows</a></li>
     <li><a href="#drawing-model"><span class="secno">1.1.20 </span>Drawing model</a></li>
     <li><a href="#best-practices"><span class="secno">1.1.21 </span>Best practices</a></li>
     <li><a href="#examples"><span class="secno">1.1.22 </span>Examples</a></li></ul></li></ul></li>
 <li><a class="no-num" href="#references">References</a></li></ul>
<!--end-toc-->
  <hr>


  <h2 id="conformance-requirements"><span class="secno">1 </span>Conformance requirements</h2>

  <p>This specification is an HTML specification. All the conformance
  requirements, conformance classes, definitions, dependencies,
  terminology, and typographical conventions described in the core
  HTML5 specification apply to this specification. <a href="#refsHTML5">[HTML5]</a></p>

  <p>Interfaces are defined in terms of Web IDL. <a href="#refsWEBIDL">[WEBIDL]</a></p>



  <h5 id="2dcontext"><span class="secno">1.1 </span>The 2D rendering context</h5>

  <!-- v2: we're on v5. suggestions for subsequent versions are marked v6, v7, v8. -->

  <pre class="idl">typedef (<span>HTMLImageElement</span> or
         <span>HTMLVideoElement</span> or
         <span>HTMLCanvasElement</span> or
         <a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a> or
         <span>ImageBitmap</span>) <dfn id="canvasimagesource">CanvasImageSource</dfn>;

enum <dfn id="canvasfillrule">CanvasFillRule</dfn> { "<a data-anolis-xref="dom-context-2d-fillRule-nonzero" href="#dom-context-2d-fillrule-nonzero">nonzero</a>", "<a data-anolis-xref="dom-context-2d-fillRule-evenodd" href="#dom-context-2d-fillrule-evenodd">evenodd</a>" };

[<a data-anolis-xref="dom-context-2d" href="#dom-context-2d">Constructor</a>(optional unsigned long width, unsigned long height), Exposed=Window,Worker]
interface <dfn id="canvasrenderingcontext2d">CanvasRenderingContext2D</dfn> {

  // back-reference to the canvas
  readonly attribute <span>HTMLCanvasElement</span> <a data-anolis-xref="dom-context-2d-canvas" href="#dom-context-2d-canvas">canvas</a>;

  // canvas dimensions
           attribute unsigned long <a data-anolis-xref="dom-context-2d-width" href="#dom-context-2d-width">width</a>;
           attribute unsigned long <a data-anolis-xref="dom-context-2d-height" href="#dom-context-2d-height">height</a>;

  // for contexts that aren't directly <span data-anolis-xref="concept-canvas-fixed">fixed</span> to a specific canvas
  void <a data-anolis-xref="dom-context-2d-commit" href="#dom-context-2d-commit">commit</a>(); // push the image to the <a href="#output-bitmap">output bitmap</a>

  // state
  void <a data-anolis-xref="dom-context-2d-save" href="#dom-context-2d-save">save</a>(); // push state on state stack
  void <a data-anolis-xref="dom-context-2d-restore" href="#dom-context-2d-restore">restore</a>(); // pop state stack and restore state
<!--
  // v7 we've also received requests for:
          attribute boolean <span data-x="dom-context-2d-forceHighQuality">forceHighQuality</span> // (default false)
  // when enabled, it would prevent the UA from falling back on lower-quality but faster rendering routines
  // useful e.g. for when an image manipulation app uses <canvas> both for UI previews and the actual work

-->
  // transformations (default transform is the identity matrix)
           attribute <span>SVGMatrix</span> <a data-anolis-xref="dom-context-2d-currentTransform" href="#dom-context-2d-currenttransform">currentTransform</a>;
  void <a data-anolis-xref="dom-context-2d-scale" href="#dom-context-2d-scale">scale</a>(unrestricted double x, unrestricted double y);
  void <a data-anolis-xref="dom-context-2d-rotate" href="#dom-context-2d-rotate">rotate</a>(unrestricted double angle);
  void <a data-anolis-xref="dom-context-2d-translate" href="#dom-context-2d-translate">translate</a>(unrestricted double x, unrestricted double y);
  void <a data-anolis-xref="dom-context-2d-transform" href="#dom-context-2d-transform">transform</a>(unrestricted double a, unrestricted double b, unrestricted double c, unrestricted double d, unrestricted double e, unrestricted double f);
  void <a data-anolis-xref="dom-context-2d-setTransform" href="#dom-context-2d-settransform">setTransform</a>(unrestricted double a, unrestricted double b, unrestricted double c, unrestricted double d, unrestricted double e, unrestricted double f);
  void <a data-anolis-xref="dom-context-2d-resetTransform" href="#dom-context-2d-resettransform">resetTransform</a>();
<!--
  // v7 we've also received requests (though not many so far) for:
  void skew(...);                             // is this common enough that one can't just use setTransform()?
  void reflect(...);  and  void mirror(...);  // aren't negative values in scale() sufficient for these?

-->
  // compositing
           attribute unrestricted double <a data-anolis-xref="dom-context-2d-globalAlpha" href="#dom-context-2d-globalalpha">globalAlpha</a>; // (default 1.0)
           attribute DOMString <a data-anolis-xref="dom-context-2d-globalCompositeOperation" href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a>; // (default source-over)

  // image smoothing
           attribute boolean <a data-anolis-xref="dom-context-2d-imageSmoothingEnabled" href="#dom-context-2d-imagesmoothingenabled">imageSmoothingEnabled</a>; // (default true)
<!--
  // v7 we've also received requests for:
  - turning off antialiasing to avoid seams when patterns are painted next to each other
    - might be better to overdraw?
    - might be better to just draw at a higher res then downsample, like for 3d?
  - nested layers
    - the ability to composite an entire set of drawing operations with one shadow all at once
      http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2008-August/015567.html

-->
  // colors and styles (see also the <a href="#canvasdrawingstyles">CanvasDrawingStyles</a> interface)
           attribute (DOMString or CanvasGradient or CanvasPattern) <a data-anolis-xref="dom-context-2d-strokeStyle" href="#dom-context-2d-strokestyle">strokeStyle</a>; // (default black)
           attribute (DOMString or CanvasGradient or CanvasPattern) <a data-anolis-xref="dom-context-2d-fillStyle" href="#dom-context-2d-fillstyle">fillStyle</a>; // (default black)
  <a href="#canvasgradient">CanvasGradient</a> <a data-anolis-xref="dom-context-2d-createLinearGradient" href="#dom-context-2d-createlineargradient">createLinearGradient</a>(double x0, double y0, double x1, double y1);
  <a href="#canvasgradient">CanvasGradient</a> <a data-anolis-xref="dom-context-2d-createRadialGradient" href="#dom-context-2d-createradialgradient">createRadialGradient</a>(double x0, double y0, double r0, double x1, double y1, double r1);
  <a href="#canvaspattern">CanvasPattern</a> <a data-anolis-xref="dom-context-2d-createPattern" href="#dom-context-2d-createpattern">createPattern</a>(<a href="#canvasimagesource">CanvasImageSource</a> image, [TreatNullAs=EmptyString] DOMString repetition);
<!--
  // v8 we received one request from Ralf Richard G&oml;bel for a new kind of pattern: a hatch.
  // basically it would be a series of dash styles, angles, line widths, and offsets
-->
  // shadows
           attribute unrestricted double <a data-anolis-xref="dom-context-2d-shadowOffsetX" href="#dom-context-2d-shadowoffsetx">shadowOffsetX</a>; // (default 0)
           attribute unrestricted double <a data-anolis-xref="dom-context-2d-shadowOffsetY" href="#dom-context-2d-shadowoffsety">shadowOffsetY</a>; // (default 0)
           attribute unrestricted double <a data-anolis-xref="dom-context-2d-shadowBlur" href="#dom-context-2d-shadowblur">shadowBlur</a>; // (default 0)
           attribute DOMString <a data-anolis-xref="dom-context-2d-shadowColor" href="#dom-context-2d-shadowcolor">shadowColor</a>; // (default transparent black)

  // rects
  void <a data-anolis-xref="dom-context-2d-clearRect" href="#dom-context-2d-clearrect">clearRect</a>(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void <a data-anolis-xref="dom-context-2d-fillRect" href="#dom-context-2d-fillrect">fillRect</a>(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void <a data-anolis-xref="dom-context-2d-strokeRect" href="#dom-context-2d-strokerect">strokeRect</a>(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);

  // path API (see also <a href="#canvaspathmethods">CanvasPathMethods</a>)
  void <a data-anolis-xref="dom-context-2d-beginPath" href="#dom-context-2d-beginpath">beginPath</a>();
  void <a data-anolis-xref="dom-context-2d-fill" href="#dom-context-2d-fill">fill</a>(optional <a href="#canvasfillrule">CanvasFillRule</a> fillRule = "<a data-anolis-xref="dom-context-2d-fillRule-nonzero" href="#dom-context-2d-fillrule-nonzero">nonzero</a>");
  void <a data-anolis-xref="dom-context-2d-fill" href="#dom-context-2d-fill">fill</a>(<a href="#path2d">Path2D</a> path, optional <a href="#canvasfillrule">CanvasFillRule</a> fillRule = "<a data-anolis-xref="dom-context-2d-fillRule-nonzero" href="#dom-context-2d-fillrule-nonzero">nonzero</a>");
  void <a data-anolis-xref="dom-context-2d-stroke" href="#dom-context-2d-stroke">stroke</a>();
  void <a data-anolis-xref="dom-context-2d-stroke" href="#dom-context-2d-stroke">stroke</a>(<a href="#path2d">Path2D</a> path);
  <!-- START w3c-html-->
  void <a data-anolis-xref="dom-context-2d-drawFocusIfNeeded" href="#dom-context-2d-drawfocusifneeded">drawFocusIfNeeded</a>(<span>Element</span> element);
  void <a data-anolis-xref="dom-context-2d-drawFocusIfNeeded" href="#dom-context-2d-drawfocusifneeded">drawFocusIfNeeded</a>(<a href="#path2d">Path2D</a> path, <span>Element</span> element);
<!-- END FORK w3c-html--> 
 boolean <a data-anolis-xref="dom-context-2d-drawCustomFocusRing" href="#dom-context-2d-drawcustomfocusring">drawCustomFocusRing</a>(<span>Element</span> element);
  boolean <a data-anolis-xref="dom-context-2d-drawCustomFocusRing" href="#dom-context-2d-drawcustomfocusring">drawCustomFocusRing</a>(<a href="#path2d">Path2D</a> path, <span>Element</span> element);
  void <a data-anolis-xref="dom-context-2d-scrollPathIntoView" href="#dom-context-2d-scrollpathintoview">scrollPathIntoView</a>();
  void <a data-anolis-xref="dom-context-2d-scrollPathIntoView" href="#dom-context-2d-scrollpathintoview">scrollPathIntoView</a>(<a href="#path2d">Path2D</a> path);
  void <a data-anolis-xref="dom-context-2d-clip" href="#dom-context-2d-clip">clip</a>(optional <a href="#canvasfillrule">CanvasFillRule</a> fillRule = "<a data-anolis-xref="dom-context-2d-fillRule-nonzero" href="#dom-context-2d-fillrule-nonzero">nonzero</a>");
  void <a data-anolis-xref="dom-context-2d-clip" href="#dom-context-2d-clip">clip</a>(<a href="#path2d">Path2D</a> path, optional <a href="#canvasfillrule">CanvasFillRule</a> fillRule = "<a data-anolis-xref="dom-context-2d-fillRule-nonzero" href="#dom-context-2d-fillrule-nonzero">nonzero</a>");
  void <a data-anolis-xref="dom-context-2d-resetClip" href="#dom-context-2d-resetclip">resetClip</a>();
  boolean <a data-anolis-xref="dom-context-2d-isPointInPath" href="#dom-context-2d-ispointinpath">isPointInPath</a>(unrestricted double x, unrestricted double y, optional <a href="#canvasfillrule">CanvasFillRule</a> fillRule = "<a data-anolis-xref="dom-context-2d-fillRule-nonzero" href="#dom-context-2d-fillrule-nonzero">nonzero</a>");
  boolean <a data-anolis-xref="dom-context-2d-isPointInPath" href="#dom-context-2d-ispointinpath">isPointInPath</a>(<a href="#path2d">Path2D</a> path, unrestricted double x, unrestricted double y, optional <a href="#canvasfillrule">CanvasFillRule</a> fillRule = "<a data-anolis-xref="dom-context-2d-fillRule-nonzero" href="#dom-context-2d-fillrule-nonzero">nonzero</a>");
  boolean <a data-anolis-xref="dom-context-2d-isPointInStroke" href="#dom-context-2d-ispointinstroke">isPointInStroke</a>(unrestricted double x, unrestricted double y);
  boolean <a data-anolis-xref="dom-context-2d-isPointInStroke" href="#dom-context-2d-ispointinstroke">isPointInStroke</a>(<a href="#path2d">Path2D</a> path, unrestricted double x, unrestricted double y);

  // text (see also the <a href="#canvasdrawingstyles">CanvasDrawingStyles</a> interface)
  void <a data-anolis-xref="dom-context-2d-fillText" href="#dom-context-2d-filltext">fillText</a>(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);
  void <a data-anolis-xref="dom-context-2d-strokeText" href="#dom-context-2d-stroketext">strokeText</a>(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);<!-- v6DVT
  void <span data-x="dom-context-2d-fillVerticalText">fillVerticalText</span>(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxHeight);
  void <span data-x="dom-context-2d-strokeVerticalText">strokeVerticalText</span>(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxHeight); -->
  <a href="#textmetrics">TextMetrics</a> <a data-anolis-xref="dom-context-2d-measureText" href="#dom-context-2d-measuretext">measureText</a>(DOMString text);

  // drawing images
  void <a data-anolis-xref="dom-context-2d-drawImage" href="#dom-context-2d-drawimage">drawImage</a>(<a href="#canvasimagesource">CanvasImageSource</a> image, unrestricted double dx, unrestricted double dy);
  void <a data-anolis-xref="dom-context-2d-drawImage" href="#dom-context-2d-drawimage">drawImage</a>(<a href="#canvasimagesource">CanvasImageSource</a> image, unrestricted double dx, unrestricted double dy, unrestricted double dw, unrestricted double dh);
  void <a data-anolis-xref="dom-context-2d-drawImage" href="#dom-context-2d-drawimage">drawImage</a>(<a href="#canvasimagesource">CanvasImageSource</a> image, unrestricted double sx, unrestricted double sy, unrestricted double sw, unrestricted double sh, unrestricted double dx, unrestricted double dy, unrestricted double dw, unrestricted double dh);

  // hit regions
  void <a data-anolis-xref="dom-context-2d-addHitRegion" href="#dom-context-2d-addhitregion">addHitRegion</a>(optional <a href="#hitregionoptions">HitRegionOptions</a> options);
  void <a data-anolis-xref="dom-context-2d-removeHitRegion" href="#dom-context-2d-removehitregion">removeHitRegion</a>(DOMString id);
  void <a href="#dom-context-2d-clearhitregions" title="dom-context-2d-clearHitRegions">clearHitRegions</a>();
  
  // pixel manipulation
  <a href="#imagedata">ImageData</a> <a data-anolis-xref="dom-context-2d-createImageData" href="#dom-context-2d-createimagedata">createImageData</a>(double sw, double sh);
  <a href="#imagedata">ImageData</a> <a data-anolis-xref="dom-context-2d-createImageData" href="#dom-context-2d-createimagedata">createImageData</a>(<a href="#imagedata">ImageData</a> imagedata);
  <a href="#imagedata">ImageData</a> <a data-anolis-xref="dom-context-2d-getImageData" href="#dom-context-2d-getimagedata">getImageData</a>(double sx, double sy, double sw, double sh);
  void <a data-anolis-xref="dom-context-2d-putImageData" href="#dom-context-2d-putimagedata">putImageData</a>(<a href="#imagedata">ImageData</a> imagedata, double dx, double dy);
  void <a data-anolis-xref="dom-context-2d-putImageData" href="#dom-context-2d-putimagedata">putImageData</a>(<a href="#imagedata">ImageData</a> imagedata, double dx, double dy, double dirtyX, double dirtyY, double dirtyWidth, double dirtyHeight);
};
<a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a> implements <a href="#canvasdrawingstyles">CanvasDrawingStyles</a>;
<a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a> implements <a href="#canvaspathmethods">CanvasPathMethods</a>;

[NoInterfaceObject, Exposed=Window,Worker]
interface <dfn id="canvasdrawingstyles">CanvasDrawingStyles</dfn> {
  // line caps/joins
           attribute unrestricted double <a data-anolis-xref="dom-context-2d-lineWidth" href="#dom-context-2d-linewidth">lineWidth</a>; // (default 1)
           attribute DOMString <a data-anolis-xref="dom-context-2d-lineCap" href="#dom-context-2d-linecap">lineCap</a>; // "butt", "round", "square" (default "butt")
           attribute DOMString <a data-anolis-xref="dom-context-2d-lineJoin" href="#dom-context-2d-linejoin">lineJoin</a>; // "round", "bevel", "miter" (default "miter")
           attribute unrestricted double <a data-anolis-xref="dom-context-2d-miterLimit" href="#dom-context-2d-miterlimit">miterLimit</a>; // (default 10)

  // dashed lines
  void <a data-anolis-xref="dom-context-2d-setLineDash" href="#dom-context-2d-setlinedash">setLineDash</a>(sequence&lt;unrestricted double&gt; segments); // default empty
  sequence&lt;unrestricted double&gt; <a data-anolis-xref="dom-context-2d-getLineDash" href="#dom-context-2d-getlinedash">getLineDash</a>();
           attribute unrestricted double <a data-anolis-xref="dom-context-2d-lineDashOffset" href="#dom-context-2d-linedashoffset">lineDashOffset</a>;

  // text
           attribute DOMString <a data-anolis-xref="dom-context-2d-font" href="#dom-context-2d-font">font</a>; // (default 10px sans-serif)
           attribute DOMString <a data-anolis-xref="dom-context-2d-textAlign" href="#dom-context-2d-textalign">textAlign</a>; // "start", "end", "left", "right", "center" (default: "start")
           attribute DOMString <a data-anolis-xref="dom-context-2d-textBaseline" href="#dom-context-2d-textbaseline">textBaseline</a>; // "top", "hanging", "middle", "alphabetic", "ideographic", "bottom" (default: "alphabetic")
           attribute DOMString <a data-anolis-xref="dom-context-2d-direction" href="#dom-context-2d-direction">direction</a>; // "ltr", "rtl"<!--, "auto"-->, "inherit" (default: "inherit")
};

[NoInterfaceObject, Exposed=Window,Worker]
interface <dfn id="canvaspathmethods">CanvasPathMethods</dfn> {
  // shared path API methods
  void <a data-anolis-xref="dom-context-2d-closePath" href="#dom-context-2d-closepath">closePath</a>();
  void <a data-anolis-xref="dom-context-2d-moveTo" href="#dom-context-2d-moveto">moveTo</a>(unrestricted double x, unrestricted double y);
  void <a data-anolis-xref="dom-context-2d-lineTo" href="#dom-context-2d-lineto">lineTo</a>(unrestricted double x, unrestricted double y);
  void <a data-anolis-xref="dom-context-2d-quadraticCurveTo" href="#dom-context-2d-quadraticcurveto">quadraticCurveTo</a>(unrestricted double cpx, unrestricted double cpy, unrestricted double x, unrestricted double y);
  void <a data-anolis-xref="dom-context-2d-bezierCurveTo" href="#dom-context-2d-beziercurveto">bezierCurveTo</a>(unrestricted double cp1x, unrestricted double cp1y, unrestricted double cp2x, unrestricted double cp2y, unrestricted double x, unrestricted double y);
  void <a data-anolis-xref="dom-context-2d-arcTo" href="#dom-context-2d-arcto">arcTo</a>(unrestricted double x1, unrestricted double y1, unrestricted double x2, unrestricted double y2, unrestricted double radius); <!-- see ARC-ORDER note below -->
  void <a data-anolis-xref="dom-context-2d-arcTo" href="#dom-context-2d-arcto">arcTo</a>(unrestricted double x1, unrestricted double y1, unrestricted double x2, unrestricted double y2, unrestricted double radiusX, unrestricted double radiusY, unrestricted double rotation); <!-- see ARC-ORDER note below -->
  void <a data-anolis-xref="dom-context-2d-rect" href="#dom-context-2d-rect">rect</a>(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void <a data-anolis-xref="dom-context-2d-arc" href="#dom-context-2d-arc">arc</a>(unrestricted double x, unrestricted double y, unrestricted double radius, unrestricted double startAngle, unrestricted double endAngle, optional boolean anticlockwise = false); <!-- see ARC-ORDER note below -->
  void <a data-anolis-xref="dom-context-2d-ellipse" href="#dom-context-2d-ellipse">ellipse</a>(unrestricted double x, unrestricted double y, unrestricted double radiusX, unrestricted double radiusY, unrestricted double rotation, unrestricted double startAngle, unrestricted double endAngle, optional boolean anticlockwise = false); <!-- see ARC-ORDER note below -->
};

[Exposed=Window,Worker]
interface <dfn id="canvasgradient">CanvasGradient</dfn> {
  // opaque object
  void <a data-anolis-xref="dom-canvasgradient-addColorStop" href="#dom-canvasgradient-addcolorstop">addColorStop</a>(double offset, DOMString color);
};

[Exposed=Window,Worker]
interface <dfn id="canvaspattern">CanvasPattern</dfn> {
  // opaque object
  void <a data-anolis-xref="dom-canvaspattern-setTransform" href="#dom-canvaspattern-settransform">setTransform</a>(<span>SVGMatrix</span> transform);
};

[Exposed=Window,Worker]
interface <dfn id="textmetrics">TextMetrics</dfn> {
  // x-direction
  readonly attribute double <a data-anolis-xref="dom-textmetrics-width" href="#dom-textmetrics-width">width</a>; // advance width
  readonly attribute double <a data-anolis-xref="dom-textmetrics-actualBoundingBoxLeft" href="#dom-textmetrics-actualboundingboxleft">actualBoundingBoxLeft</a>;
  readonly attribute double <a data-anolis-xref="dom-textmetrics-actualBoundingBoxRight" href="#dom-textmetrics-actualboundingboxright">actualBoundingBoxRight</a>;

  // y-direction
  readonly attribute double <a data-anolis-xref="dom-textmetrics-fontBoundingBoxAscent" href="#dom-textmetrics-fontboundingboxascent">fontBoundingBoxAscent</a>;
  readonly attribute double <a data-anolis-xref="dom-textmetrics-fontBoundingBoxDescent" href="#dom-textmetrics-fontboundingboxdescent">fontBoundingBoxDescent</a>;
  readonly attribute double <a data-anolis-xref="dom-textmetrics-actualBoundingBoxAscent" href="#dom-textmetrics-actualboundingboxascent">actualBoundingBoxAscent</a>;
  readonly attribute double <a data-anolis-xref="dom-textmetrics-actualBoundingBoxDescent" href="#dom-textmetrics-actualboundingboxdescent">actualBoundingBoxDescent</a>;
  readonly attribute double <a data-anolis-xref="dom-textmetrics-emHeightAscent" href="#dom-textmetrics-emheightascent">emHeightAscent</a>;
  readonly attribute double <a data-anolis-xref="dom-textmetrics-emHeightDescent" href="#dom-textmetrics-emheightdescent">emHeightDescent</a>;
  readonly attribute double <a data-anolis-xref="dom-textmetrics-hangingBaseline" href="#dom-textmetrics-hangingbaseline">hangingBaseline</a>;
  readonly attribute double <a data-anolis-xref="dom-textmetrics-alphabeticBaseline" href="#dom-textmetrics-alphabeticbaseline">alphabeticBaseline</a>;
  readonly attribute double <a data-anolis-xref="dom-textmetrics-ideographicBaseline" href="#dom-textmetrics-ideographicbaseline">ideographicBaseline</a>;
};

dictionary <dfn id="hitregionoptions">HitRegionOptions</dfn> {
  <a href="#path2d">Path2D</a>? <a data-anolis-xref="dom-HitRegionOptions-path" href="#dom-hitregionoptions-path">path</a> = null;
  <a href="#canvasfillrule">CanvasFillRule</a> <a data-anolis-xref="dom-HitRegionOptions-fillRule" href="#dom-hitregionoptions-fillrule">fillRule</a> = "<a data-anolis-xref="dom-context-2d-fillRule-nonzero" href="#dom-context-2d-fillrule-nonzero">nonzero</a>";
<!--  <span>SVGMatrix</span>? <span data-x="dom-HitRegionOptions-transform">transform</span> = null;
-->  DOMString <a data-anolis-xref="dom-HitRegionOptions-id" href="#dom-hitregionoptions-id">id</a> = ""; <!-- "" is converted to null internally by addHitRegion() -->
  DOMString? <a data-anolis-xref="dom-HitRegionOptions-parentID" href="#dom-hitregionoptions-parentid">parentID</a> = null;
  DOMString <a data-anolis-xref="dom-HitRegionOptions-cursor" href="#dom-hitregionoptions-cursor">cursor</a> = "inherit";
  // for control-backed regions:
  <span>Element</span>? <a data-anolis-xref="dom-HitRegionOptions-control" href="#dom-hitregionoptions-control">control</a> = null;
  // for unbacked regions:
  DOMString? <a data-anolis-xref="dom-HitRegionOptions-label" href="#dom-hitregionoptions-label">label</a> = null;
  DOMString? <a data-anolis-xref="dom-HitRegionOptions-role" href="#dom-hitregionoptions-role">role</a> = null;
};

[<a data-anolis-xref="dom-imagedata" href="#dom-imagedata">Constructor</a>(unsigned long sw, unsigned long sh),
 <a data-anolis-xref="dom-imagedata" href="#dom-imagedata">Constructor</a>(<span>Uint8ClampedArray</span> data, unsigned long sw, optional unsigned long sh),
 Exposed=Window,Worker]
interface <dfn id="imagedata">ImageData</dfn> {
  readonly attribute unsigned long <a data-anolis-xref="dom-imagedata-width" href="#dom-imagedata-width">width</a>;
  readonly attribute unsigned long <a data-anolis-xref="dom-imagedata-height" href="#dom-imagedata-height">height</a>;
  readonly attribute <span>Uint8ClampedArray</span> <a data-anolis-xref="dom-imagedata-data" href="#dom-imagedata-data">data</a>;
};

[<a data-anolis-xref="dom-DrawingStyle" href="#dom-drawingstyle">Constructor</a>(optional <span>Element</span> scope), Exposed=Window,Worker]
interface <dfn id="drawingstyle">DrawingStyle</dfn> { };
<a href="#drawingstyle">DrawingStyle</a> implements <a href="#canvasdrawingstyles">CanvasDrawingStyles</a>;

[<a data-anolis-xref="dom-Path2D" href="#dom-path2d">Constructor</a>,
 <a data-anolis-xref="dom-Path2D-copy" href="#dom-path2d-copy">Constructor</a>(<a href="#path2d">Path2D</a> path),
 <a data-anolis-xref="dom-Path2D-merge" href="#dom-path2d-merge">Constructor</a>(<a href="#path2d">Path2D</a>[] paths, optional <a href="#canvasfillrule">CanvasFillRule</a> fillRule = "<a data-anolis-xref="dom-context-2d-fillRule-nonzero" href="#dom-context-2d-fillrule-nonzero">nonzero</a>"),
 <a data-anolis-xref="dom-Path2D-withdata" href="#dom-path2d-withdata">Constructor</a>(DOMString d), Exposed=Window,Worker]
interface <dfn id="path2d">Path2D</dfn> {
  void <a data-anolis-xref="dom-Path2D-addPath" href="#dom-path2d-addpath">addPath</a>(<a href="#path2d">Path2D</a> path, optional <span>SVGMatrix</span>? transformation = null);
  void <a data-anolis-xref="dom-Path2D-addPathByStrokingPath" href="#dom-path2d-addpathbystrokingpath">addPathByStrokingPath</a>(<a href="#path2d">Path2D</a> path, <a href="#canvasdrawingstyles">CanvasDrawingStyles</a> styles, optional <span>SVGMatrix</span>? transformation = null);
  void <a data-anolis-xref="dom-Path2D-addText" href="#dom-path2d-addtext">addText</a>(DOMString text, <a href="#canvasdrawingstyles">CanvasDrawingStyles</a> styles, <span>SVGMatrix</span>? transformation, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);
  void <a data-anolis-xref="dom-Path2D-addPathByStrokingText" href="#dom-path2d-addpathbystrokingtext">addPathByStrokingText</a>(DOMString text, <a href="#canvasdrawingstyles">CanvasDrawingStyles</a> styles, <span>SVGMatrix</span>? transformation, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);
  void <a data-anolis-xref="dom-Path2D-addText" href="#dom-path2d-addtext">addText</a>(DOMString text, <a href="#canvasdrawingstyles">CanvasDrawingStyles</a> styles, <span>SVGMatrix</span>? transformation, <a href="#path2d">Path2D</a> path, optional unrestricted double maxWidth);
  void <a data-anolis-xref="dom-Path2D-addPathByStrokingText" href="#dom-path2d-addpathbystrokingtext">addPathByStrokingText</a>(DOMString text, <a href="#canvasdrawingstyles">CanvasDrawingStyles</a> styles, <span>SVGMatrix</span>? transformation, <a href="#path2d">Path2D</a> path, optional unrestricted double maxWidth);
};
<a href="#path2d">Path2D</a> implements <a href="#canvaspathmethods">CanvasPathMethods</a>;</pre>

 <!-- ARC-ORDER note (see above):
      some demos rely on the precise order of the arc() and arcTo()
      methods, see https://bugzilla.mozilla.org/show_bug.cgi?id=623437
      for an example, and its duplicates for more -->

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> = <var data-anolis-xref="">canvas</var> . <code data-anolis-xref="dom-canvas-getContext">getContext</code>('2d')</dt>

   <dd>

    <p>Returns a <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object that is permanently bound to a
    particular <code>canvas</code> element.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> = new <code data-anolis-xref="dom-context-2d"><a href="#dom-context-2d">CanvasRenderingContext2D</a></code>( [ <var data-anolis-xref="">width</var>, <var data-anolis-xref="">height</var> ] )</dt>

   <dd>

    <p>Returns an unbound <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object with an implied bitmap with
    the given dimensions in CSS pixels (300x150, if the arguments are omitted).</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-canvas"><a href="#dom-context-2d-canvas">canvas</a></code></dt>

   <dd>

    <p>Returns the <code>canvas</code> element, if the rendering context was obtained using the
    <code data-anolis-xref="dom-canvas-getContext">getContext()</code> method.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-width"><a href="#dom-context-2d-width">width</a></code></dt>
   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-height"><a href="#dom-context-2d-height">height</a></code></dt>

   <dd>

    <p>Return the dimensions of the bitmap, in CSS pixels.</p>

    <p>Can be set, to update the bitmap's dimensions. If the rendering context is bound to a canvas,
    this will also update the canvas' intrinsic dimensions.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-commit"><a href="#dom-context-2d-commit">commit</a></code>()</dt>

   <dd>

    <p>If the rendering context is bound to a <code>canvas</code>, display the current frame.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>A <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object can be obtained in two ways: the <code data-anolis-xref="dom-canvas-getContext">getContext()</code> method on a <code>canvas</code> element (which
  invokes the <a href="#2d-context-creation-algorithm">2D context creation algorithm</a>), and the <code data-anolis-xref="dom-context-2d"><a href="#dom-context-2d">CanvasRenderingContext2D()</a></code> constructor.</p>

  <p>A <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object has a <dfn id="scratch-bitmap">scratch bitmap</dfn> and can be bound
  to an <dfn id="output-bitmap">output bitmap</dfn>. These are initialised when the object is created, and can be
  subsequently adjusted when the rendering context is <a data-anolis-xref="concept-canvas-binding-steps" href="#concept-canvas-binding-steps">bound</a> or <a data-anolis-xref="concept-canvas-unbinding-steps" href="#concept-canvas-unbinding-steps">unbound</a>. In some cases, these bitmaps are the same
  underlying bitmap. In general, the <a href="#scratch-bitmap">scratch bitmap</a> is what scripts interact with, and
  the <a href="#output-bitmap">output bitmap</a> is what is being displayed. These bitmaps always have the same
  dimensions.</p>

<!--ADD-TOPIC:Security-->
  <p>Each such bitmap has an <span data-anolis-xref="concept-canvas-origin-clean">origin-clean</span> flag,
  which can be set to true or false. Initially, when one of these bitmaps is created, its <span data-anolis-xref="concept-canvas-origin-clean">origin-clean</span> flag must be set to true.</p>
<!--REMOVE-TOPIC:Security-->

  <p>These bitmaps also have a <a href="#hit-region-list">hit region list</a>, which is described in a later section.
  Initially, this list is empty. <a data-anolis-xref="scratch bitmap" href="#scratch-bitmap">Scratch bitmaps</a> also have a
  <dfn id="list-of-pending-interface-actions">list of pending interface actions</dfn>, which can contain instructions to draw the user's
  attention to a location on the bitmap, and instructions to scroll to a location on the bitmap.
  Initially, this list is also empty.</p>

  <p>The <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> 2D rendering context represents a flat linear
  Cartesian surface whose origin (0,0) is at the top left corner, with the coordinate space having
  <var data-anolis-xref="">x</var> values increasing when going right, and <var data-anolis-xref="">y</var> values
  increasing when going down. The <var data-anolis-xref="">x</var>-coordinate of the right-most edge is equal to
  the width of the rendering context's <a href="#scratch-bitmap">scratch bitmap</a> in CSS pixels; similarly, the
  <var data-anolis-xref="">y</var>-coordinate of the bottom-most edge is equal to the height of the rendering
  context's <a href="#scratch-bitmap">scratch bitmap</a> in CSS pixels.</p>

  <p>The size of the coordinate space does not necessarily represent the size of the actual bitmaps
  that the user agent will use internally or during rendering. On high-definition displays, for
  instance, the user agent may internally use bitmaps with two device pixels per unit in the
  coordinate space, so that the rendering remains at high quality throughout. Anti-aliasing can
  similarly be implemented using over-sampling with bitmaps of a higher resolution than the final
  image on the display.</p>

  <hr>

  <p>The <dfn id="2d-context-creation-algorithm">2D context creation algorithm</dfn>, which is passed a <var data-anolis-xref="">target</var> (a
  <code>canvas</code> element), consists of running the following steps:</p>

  <ol>

   <li><p>Create a new <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object.</p></li>

   <li><p>Initialise its <code data-anolis-xref="dom-context-2d-canvas"><a href="#dom-context-2d-canvas">canvas</a></code> attribute to point to
   <var data-anolis-xref="">target</var>.</p></li>

   <li><p>Let the new <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object's <a href="#output-bitmap">output bitmap</a> and
   <a href="#scratch-bitmap">scratch bitmap</a> both be the same bitmap as <var data-anolis-xref="">target</var>'s bitmap (so
   that they are shared).</p></li>

   <li><p><a data-anolis-xref="concept-canvas-set-bitmap-dimensions" href="#concept-canvas-set-bitmap-dimensions">Set bitmap dimensions</a> to the
   numeric values of <var data-anolis-xref="">target</var>'s <code data-anolis-xref="attr-canvas-width">width</code> and
   <code data-anolis-xref="attr-canvas-height">height</code> content attributes.</p></li>

   <li><p>Return the new <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object.</p></li>

  </ol>

  <hr>

  <p>The <dfn data-anolis-xref="dom-context-2d" id="dom-context-2d"><code>CanvasRenderingContext2D()</code></dfn> constructor, when
  invoked, must run the following steps:</p>

  <ol>

   <li><p>Create a new <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object.</p></li>

   <li><p>Initialise its <code data-anolis-xref="dom-context-2d-canvas"><a href="#dom-context-2d-canvas">canvas</a></code> attribute to
   null.</p></li>

   <li><p>Let the new <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object's <a href="#scratch-bitmap">scratch bitmap</a> be
   a new bitmap.</p></li>

   <li><p>If the constructor was called with arguments, let <var data-anolis-xref="">width</var> and <var data-anolis-xref="">height</var> be the first and second arguments, respectively. Otherwise, let <var data-anolis-xref="">width</var> and <var data-anolis-xref="">height</var> be 300 and 150, respectively.</p></li>

   <li><p><a data-anolis-xref="concept-canvas-set-bitmap-dimensions" href="#concept-canvas-set-bitmap-dimensions">Set bitmap dimensions</a> to <var data-anolis-xref="">width</var> and <var data-anolis-xref="">height</var>.</p></li>

   <li><p>Let the new <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object have no <a href="#output-bitmap">output
   bitmap</a>.</p></li>

<!--
   <li><p><span>Start autocommitting the scratch bitmap</span> for the new
   <code>CanvasRenderingContext2D</code> object.</p></li>
-->

   <li><p>Return the new <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object.</p></li>

  </ol>

  <hr>

  <p>When the user agent is required to <dfn id="commit-the-scratch-bitmap">commit the scratch bitmap</dfn> for a rendering
  context, it must run the following steps:

  </p><ol>

   <li><p>Let <var data-anolis-xref="">bitmap copy</var> be a copy of the rendering context's <a href="#scratch-bitmap">scratch
   bitmap</a>.</p></li>

<!--ADD-TOPIC:Security-->
   <li><p>Let <var data-anolis-xref="">origin-clean flag copy</var> be a copy of the rendering context's
   <a href="#scratch-bitmap">scratch bitmap</a>'s <span data-anolis-xref="concept-canvas-origin-clean">origin-clean</span>
   flag.</p></li>
<!--REMOVE-TOPIC:Security-->

   <li><p>Let <var data-anolis-xref="">hit region list copy</var> be a copy of the rendering context's
   <a href="#scratch-bitmap">scratch bitmap</a>'s <a href="#hit-region-list">hit region list</a>.</p></li>

   <li><p>Let <var data-anolis-xref="">list of pending interface actions copy</var> be a copy of the rendering
   context's <a href="#scratch-bitmap">scratch bitmap</a>'s <a href="#list-of-pending-interface-actions">list of pending interface actions</a>.</p></li>

   <li><p>Empty the <a href="#scratch-bitmap">scratch bitmap</a>'s <a href="#list-of-pending-interface-actions">list of pending interface actions</a>.</p></li>

   <li><p>If the rendering context has no <a href="#output-bitmap">output bitmap</a>, abort these steps.</p></li>

   <li><p>Let <var data-anolis-xref="">output bitmap</var> be the rendering context's <a href="#output-bitmap">output
   bitmap</a>.</p></li>

   <li><p>Let <var data-anolis-xref="">canvas</var> be the <code>canvas</code> element to which the rendering
   context was most recently <a data-anolis-xref="concept-canvas-binding-steps" href="#concept-canvas-binding-steps">bound</a>.</p></li>

   <li>

    <p><span>Queue a task</span> associated with <var data-anolis-xref="">canvas</var>' <code>Document</code>
    to perform the following substeps:</p>

    <ol>

     <li><p>Overwrite <var data-anolis-xref="">output bitmap</var> with <var data-anolis-xref="">bitmap
     copy</var>.</p></li>

<!--ADD-TOPIC:Security-->
     <li><p>Overwrite <var data-anolis-xref="">output bitmap</var>'s <span data-anolis-xref="concept-canvas-origin-clean">origin-clean</span> flag with <var data-anolis-xref="">origin-clean
     flag copy</var>.</p></li>
<!--REMOVE-TOPIC:Security-->

     <li><p>Overwrite <var data-anolis-xref="">output bitmap</var>'s <a href="#hit-region-list">hit region list</a> with <var data-anolis-xref="">hit region list copy</var>.</p></li>

     <li><p>Follow the directions in the <var data-anolis-xref="">list of pending interface actions
     copy</var>.</p></li>

    </ol>

   </li>

  </ol>

  <p>The algorithm above must use the <dfn id="canvas-updating-task-source">canvas updating task source</dfn> (which is just used by
  this algorithm).</p>

<!--(right now we're requiring commit())
  <p>When a user agent is to <dfn>start autocommitting the scratch bitmap</dfn> for a rendering
  context, it must asynchronously start running the following algorithm. This algorithm interacts
  closely with the <span>event loop</span> mechanism; in particular, it has a <span>synchronous
  section</span> (which is triggered as part of the <span>event loop</span> algorithm). The steps in
  that section are marked with &#x231B;.</p>

  <ol>

   <li><p><i>Top</i>: <span>Await a stable state</span>. The <span>synchronous section</span>
   consists of the following steps. (The steps in the <span>synchronous section</span> are marked
   with &#x231B;.)</p></li>

   <li><p>&#x231B; <span>Commit the scratch bitmap</span> for the rendering context.</p></li>

   <li><p>End the <span>synchronous section</span>, continuing the remaining steps
   asynchronously.</p></li>

   <li><p>Return to the step labeled <i>top</i>.</p></li>

  </ol>
-->

  <p>The <dfn data-anolis-xref="dom-context-2d-commit" id="dom-context-2d-commit"><code>commit()</code></dfn> method must run the
  following steps:</p>

  <ol>

   <li><p>If the rendering context's <span data-anolis-xref="concept-canvas-context-bitmap-mode">context bitmap
   mode</span> is <span data-anolis-xref="concept-canvas-bound">fixed</span>, throw an
   <code>InvalidStateError</code> exception and abort these steps.</p></li>

   <li><p><a href="#commit-the-scratch-bitmap">Commit the scratch bitmap</a> for the rendering context.</p></li>

  </ol>

  <p class="note">The <a href="#scratch-bitmap">scratch bitmap</a> is only <a data-anolis-xref="commit the scratch
  bitmap" href="#commit-the-scratch-bitmap">committed</a> when the <code data-anolis-xref="dom-context-2d-commit"><a href="#dom-context-2d-commit">commit()</a></code> method is
  called. (This doesn't matter for <code>canvas</code> elements in <span data-anolis-xref="concept-canvas-direct-2d">direct-2d</span> mode, since there the <a href="#scratch-bitmap">scratch
  bitmap</a> is also the <code>canvas</code> element's bitmap so every drawing operation is
  immediately drawn.)</p>

  <hr>

  <p>When the user agent is to <dfn data-anolis-xref="concept-canvas-set-bitmap-dimensions" id="concept-canvas-set-bitmap-dimensions">set bitmap
  dimensions</dfn> to <var data-anolis-xref="">width</var> and <var data-anolis-xref="">height</var>, it must run the
  following steps:</p>

  <ol>

   <li><p><a href="#reset-the-rendering-context-to-its-default-state">Reset the rendering context to its default state</a>.</p></li>

   <li><p>Clear the <a href="#scratch-bitmap">scratch bitmap</a>'s <a href="#hit-region-list">hit region list</a> and its <a href="#list-of-pending-interface-actions">list of
   pending interface actions</a>.</p></li>

   <li><p>Resize the <a href="#scratch-bitmap">scratch bitmap</a> to the new <var data-anolis-xref="">width</var> and <var data-anolis-xref="">height</var> and clear it to fully transparent black.</p></li>

   <li><p>If the rendering context has an <a href="#output-bitmap">output bitmap</a>, and the <a href="#scratch-bitmap">scratch
   bitmap</a> is a different bitmap than the <a href="#output-bitmap">output bitmap</a>, then resize the
   <a href="#output-bitmap">output bitmap</a> to the new <var data-anolis-xref="">width</var> and <var data-anolis-xref="">height</var>
   and clear it to fully transparent black.</p></li>

   <li>

    <p>If the rendering context's <span data-anolis-xref="concept-canvas-context-bitmap-mode">context bitmap
    mode</span> is <span data-anolis-xref="concept-canvas-fixed">fixed</span>, then run these substeps:</p>

    <ol>

     <li><p>Let <var data-anolis-xref="">canvas</var> be the <code>canvas</code> element to which the rendering
     context's <code data-anolis-xref="dom-context-2d-canvas"><a href="#dom-context-2d-canvas">canvas</a></code> attribute was initialized.</p></li>

     <li><p>If the rendering context's <span data-anolis-xref="concept-canvas-context-bitmap-mode">context
     bitmap mode</span> is <span data-anolis-xref="concept-canvas-fixed">fixed</span> and the numeric value of
     the <var data-anolis-xref="">canvas</var>' <code data-anolis-xref="attr-canvas-width">width</code> content attribute
     differs from <var data-anolis-xref="">width</var>, then set <var data-anolis-xref="">canvas</var>' <code data-anolis-xref="attr-canvas-width">width</code> content attribute to the shortest possible string
     representing <var data-anolis-xref="">width</var> as a <span>valid non-negative integer</span>.</p></li>

     <li><p>If the rendering context's <span data-anolis-xref="concept-canvas-context-bitmap-mode">context
     bitmap mode</span> is <span data-anolis-xref="concept-canvas-fixed">fixed</span> and the numeric value of
     the <var data-anolis-xref="">canvas</var>' <code data-anolis-xref="attr-canvas-height">height</code> content attribute
     differs from <var data-anolis-xref="">height</var>, then set <var data-anolis-xref="">canvas</var>' <code data-anolis-xref="attr-canvas-height">height</code> content attribute to the shortest possible string
     representing <var data-anolis-xref="">height</var> as a <span>valid non-negative integer</span>.</p></li>

    </ol>

   </li>

  </ol>

  <div class="example">
   <p>Only one square appears to be drawn in the following example:</p>
   <pre>// canvas is a reference to a &lt;canvas&gt; element
var context = canvas.getContext('2d');
context.fillRect(0,0,50,50);
canvas.setAttribute('width', '300'); // clears the canvas
context.fillRect(0,100,50,50);
canvas.width = canvas.width; // clears the canvas
context.fillRect(100,0,50,50); // only this square remains</pre>
  </div>

  <hr>

  <p>When the user agent is to run the <dfn data-anolis-xref="concept-canvas-unbinding-steps" id="concept-canvas-unbinding-steps">unbinding
  steps</dfn> for a rendering context, it must run the following steps:</p>

  <ol>

   <li><p><a href="#reset-the-rendering-context-to-its-default-state">Reset the rendering context to its default state</a>.</p></li>

   <li><p>Clear the <a href="#scratch-bitmap">scratch bitmap</a>'s <a href="#hit-region-list">hit region list</a> and its <a href="#list-of-pending-interface-actions">list of
   pending interface actions</a>.</p></li>

   <li><p>Clear the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object's <a href="#scratch-bitmap">scratch bitmap</a> to a
   transparent black.</p></li>

<!--ADD-TOPIC:Security-->
   <li><p>Set the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object's <a href="#scratch-bitmap">scratch bitmap</a>'s <span data-anolis-xref="concept-canvas-origin-clean">origin-clean</span> flag to true.</p></li>
<!--REMOVE-TOPIC:Security-->

   <li><p>Let the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object have no <a href="#output-bitmap">output
   bitmap</a>.</p></li>

  </ol>

  <p>When the user agent is to run the <dfn data-anolis-xref="concept-canvas-binding-steps" id="concept-canvas-binding-steps">binding steps</dfn>
  to bind the rendering context to the <code>canvas</code> element <var data-anolis-xref="">target</var>, it
  must run the following steps:</p>

  <ol>

   <li><p><a href="#reset-the-rendering-context-to-its-default-state">Reset the rendering context to its default state</a>.</p></li>

   <li><p>Clear the <a href="#scratch-bitmap">scratch bitmap</a>'s <a href="#hit-region-list">hit region list</a> and its <a href="#list-of-pending-interface-actions">list of
   pending interface actions</a>.</p></li>

   <li><p>Resize the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object's <a href="#scratch-bitmap">scratch bitmap</a> to
   the dimensions of <var data-anolis-xref="">target</var>'s bitmap and clear it to fully transparent
   black.</p></li>

<!--ADD-TOPIC:Security-->
   <li><p>Set the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object's <a href="#scratch-bitmap">scratch bitmap</a>'s <span data-anolis-xref="concept-canvas-origin-clean">origin-clean</span> flag to true.</p></li>
<!--REMOVE-TOPIC:Security-->

   <li><p>Let the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object's <a href="#output-bitmap">output bitmap</a> be <var data-anolis-xref="">target</var>'s bitmap.</p></li>

  </ol>

  <hr>

  <p>The <dfn data-anolis-xref="dom-context-2d-canvas" id="dom-context-2d-canvas"><code>canvas</code></dfn> attribute must return the
  value it was initialised to when the object was created.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-width" id="dom-context-2d-width"><code>width</code></dfn> attribute, on getting, must
  return the width of the rendering context's <a href="#scratch-bitmap">scratch bitmap</a>, in CSS pixels. On
  setting, it must <a data-anolis-xref="concept-canvas-set-bitmap-dimensions" href="#concept-canvas-set-bitmap-dimensions">set bitmap dimensions</a>
  to the new value and the current height of the rendering context's <a href="#scratch-bitmap">scratch bitmap</a> in
  CSS pixels, respectively.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-height" id="dom-context-2d-height"><code>height</code></dfn> attribute, on getting, must
  return the height of the rendering context's <a href="#scratch-bitmap">scratch bitmap</a>, in CSS pixels. On
  setting, it must <a data-anolis-xref="concept-canvas-set-bitmap-dimensions" href="#concept-canvas-set-bitmap-dimensions">set bitmap dimensions</a>
  to the current width of the rendering context's <a href="#scratch-bitmap">scratch bitmap</a> in CSS pixels and the
  new value, respectively.</p>

  <hr>

  <p>Except where otherwise specified, for the 2D context interface, <strong>any method call with a
  numeric argument whose value is infinite or a NaN value must be ignored</strong>.</p>

  <!--
   Philip Taylor wrote:
   > My experience with some 3d canvas code is that infinities come up in
   > naturally harmless places, e.g. having a function that scales by x then
   > translates by 1/x and wanting it to work when x=0 (which ought to draw
   > nothing, since anything it draws is zero pixels wide), and it's a bit
   > annoying to track down and fix those issues, so I'd probably like it if
   > they were harmless in canvas methods. Opera appears to silently not draw
   > anything if the transformation matrix is not finite, but Firefox throws
   > exceptions when passing in non-finite arguments.
  -->

  <p>Whenever the CSS value <code data-anolis-xref="">currentColor</code> is used as a color in the
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> API, the "computed value of the 'color' property" for the
  purposes of determining the computed value of the <code data-anolis-xref="">currentColor</code> keyword is
  the value described by the appropriate entry in the following list:</p>

  <dl>

   <dt>If the rendering context's <span data-anolis-xref="concept-canvas-context-bitmap-mode">context bitmap
   mode</span> is <span data-anolis-xref="concept-canvas-fixed">fixed</span> and the <code>canvas</code>
   element is <span>being rendered</span></dt>

   <dd><p>The "computed value of the 'color' property" for the purposes of determining the computed
   value of the <code data-anolis-xref="">currentColor</code> keyword is the computed value of the 'color'
   property on the <code>canvas</code> element at the time that the color is specified (e.g. when
   the appropriate attribute is set, or when the method is called; not when the color is rendered or
   otherwise used). <a href="#refsCSSCOLOR">[CSSCOLOR]</a></p></dd>

   <dt>In all other cases</dt>

   <dd><p>The "computed value of the 'color' property" for the purposes of determining the computed
   value of the <code data-anolis-xref="">currentColor</code> keyword is fully opaque black. <a href="#refsCSSCOLOR">[CSSCOLOR]</a></p></dd>

  </dl>

  <p>In the case of <code data-anolis-xref="dom-canvasgradient-addColorStop"><a href="#dom-canvasgradient-addcolorstop">addColorStop()</a></code> on
  <code><a href="#canvasgradient">CanvasGradient</a></code>, the "computed value of the 'color' property" for the purposes of
  determining the computed value of the <code data-anolis-xref="">currentColor</code> keyword is always fully
  opaque black (there is no associated element). <a href="#refsCSSCOLOR">[CSSCOLOR]</a></p>

  <p class="note">This is because <code><a href="#canvasgradient">CanvasGradient</a></code> objects are
  <code>canvas</code>-neutral — a <code><a href="#canvasgradient">CanvasGradient</a></code> object created by one
  <code>canvas</code> can be used by another, and there is therefore no way to know which is the
  "element in question" at the time that the color is specified.</p>

  <p class="note">Similar concerns exist with font-related properties; the rules for those are
  described in detail in the relevant section below.</p>

  </div>

  <hr>

  <p>The <code><a href="#canvasfillrule">CanvasFillRule</a></code> enumeration is used to select the <dfn id="fill-rule">fill rule</dfn>
  algorithm by which to determine if a point is inside or outside a path.</p>

  <p>The value "<dfn data-anolis-xref="dom-context-2d-fillRule-nonzero" id="dom-context-2d-fillrule-nonzero"><code>nonzero</code></dfn>" value
  indicates the non-zero winding rule, wherein

     a point is considered to be outside a shape if the number of times a half-infinite straight
     line drawn from that point crosses the shape's path going in one direction is equal to the
     number of times it crosses the path going in the other direction.

  </p>


  <p>The "<dfn data-anolis-xref="dom-context-2d-fillRule-evenodd" id="dom-context-2d-fillrule-evenodd"><code>evenodd</code></dfn>" value indicates
  the even-odd rule, wherein

     a point is considered to be outside a shape if the number of times a half-infinite straight
     line drawn from that point crosses the shape's path is even.

  </p>

  <p>If a point is not outside a shape, it is inside the shape.</p>


  <h6 id="implementation-notes"><span class="secno">1.1.1 </span>Implementation notes</h6>

  <p><i>This section is non-normative.</i></p>

  <p>Although the way the specification is written it might sound like an implementation needs to
  track up to four bitmaps per canvas or rendering context — one <a href="#scratch-bitmap">scratch bitmap</a>,
  one <a href="#output-bitmap">output bitmap</a> for the rendering context, one bitmap for the <code>canvas</code>,
  and one bitmap for the actually currently rendered image — user agents can in fact generally
  optimise this to only one or two.</p>

  <p>The <a href="#scratch-bitmap">scratch bitmap</a>, when it isn't the same bitmap as the <a href="#output-bitmap">output
  bitmap</a>, is only directly observable if it is read, and therefore implementations can,
  instead of updating this bitmap, merely remember the sequence of drawing operations that have been
  applied to it until such time as the bitmap's actual data is needed (for example because of a call
  to <code data-anolis-xref="dom-context-2d-commit"><a href="#dom-context-2d-commit">commit()</a></code>, <code data-anolis-xref="dom-context-2d-drawImage"><a href="#dom-context-2d-drawimage">drawImage()</a></code>, or the <code data-anolis-xref="dom-createImageBitmap">createImageBitmap()</code>
  factory method). In many cases, this will be more memory efficient.</p>

  <p>The bitmap of a <code>canvas</code> element is the one bitmap that's pretty much always going
  to be needed in practice. The <a href="#output-bitmap">output bitmap</a> of a rendering context, when it has one,
  is always just an alias to a <code>canvas</code> element's bitmap.</p>

  <p>Additional bitmaps are sometimes needed, e.g. to enable fast drawing when the canvas is being
  painted at a different size than its intrinsic size, or to enable double buffering so that the
  rendering commands from the <a href="#scratch-bitmap">scratch bitmap</a> can be applied without the rendering being
  updated midway.</p>




  <h6 id="the-canvas-state"><span class="secno">1.1.2 </span>The canvas state</h6>

  <p>Each <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> rendering context maintains a stack of drawing
  states. <dfn data-anolis-xref="drawing state" id="drawing-state">Drawing states</dfn> consist of:</p>

  <ul class="brief">
   <li>The current <a data-anolis-xref="dom-context-2d-transformation" href="#transformations">transformation matrix</a>.</li>
   <li>The current <a href="#clipping-region">clipping region</a>.</li>
   <li>The current values of the following attributes: <code data-anolis-xref="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code>, <code data-anolis-xref="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code>, <code data-anolis-xref="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code>, <code data-anolis-xref="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code>, <code data-anolis-xref="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code>, <code data-anolis-xref="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code>, <code data-anolis-xref="dom-context-2d-miterLimit"><a href="#dom-context-2d-miterlimit">miterLimit</a></code>, <code data-anolis-xref="dom-context-2d-lineDashOffset"><a href="#dom-context-2d-linedashoffset">lineDashOffset</a></code>, <code data-anolis-xref="dom-context-2d-shadowOffsetX"><a href="#dom-context-2d-shadowoffsetx">shadowOffsetX</a></code>, <code data-anolis-xref="dom-context-2d-shadowOffsetY"><a href="#dom-context-2d-shadowoffsety">shadowOffsetY</a></code>, <code data-anolis-xref="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code>, <code data-anolis-xref="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code>, <code data-anolis-xref="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code>, <code data-anolis-xref="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code>, <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code>, <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code>, <code data-anolis-xref="dom-context-2d-direction"><a href="#dom-context-2d-direction">direction</a></code>, <code data-anolis-xref="dom-context-2d-imageSmoothingEnabled"><a href="#dom-context-2d-imagesmoothingenabled">imageSmoothingEnabled</a></code>.</li>
   <li>The current <a href="#dash-list">dash list</a>.</li>
  </ul>

  <p class="note">The <a href="#current-default-path">current default path</a> and the rendering context's bitmaps are not
  part of the drawing state. The <a href="#current-default-path">current default path</a> is persistent, and can only be
  reset using the <code data-anolis-xref="dom-context-2d-beginPath"><a href="#dom-context-2d-beginpath">beginPath()</a></code> method. The bitmaps
  depend on whether and how the rendering context is bound to a <code>canvas</code> element.</p>

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-save"><a href="#dom-context-2d-save">save</a></code>()</dt>

   <dd>

    <p>Pushes the current state onto the stack.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-restore"><a href="#dom-context-2d-restore">restore</a></code>()</dt>

   <dd>

    <p>Pops the top state on the stack, restoring the context to that state.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-context-2d-save" id="dom-context-2d-save"><code>save()</code></dfn> method must push a copy of the
  current drawing state onto the drawing state stack.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-restore" id="dom-context-2d-restore"><code>restore()</code></dfn> method must pop the top
  entry in the drawing state stack, and reset the drawing state it describes. If there is no saved
  state, the method must do nothing.</p>

  <p>When the user agent is to <dfn id="reset-the-rendering-context-to-its-default-state">reset the rendering context to its default state</dfn>, it must
  clear the drawing state stack and everything that <a href="#drawing-state">drawing state</a> consists of to
  initial values.</p>

  <!-- v7
idea from Mihai:
> 5. Drawing states should be saveable with IDs, and for easier restoring.
>
> save(id)
> restore(id)
>
> If id is not provided, then save() works as defined now. The same for
> restore().
>
> Currently, it's not trivial to save and restore a specific state.
...and from Philip:
> I think a more convenient syntax would be:
>   var state = ctx.save();
>   ctx.restore(state);
> But how would it interact with normal calls to ctx.restore()?
  -->

  </div>


  <h6 id="drawingstyle-objects"><span class="secno">1.1.3 </span><code><a href="#drawingstyle">DrawingStyle</a></code> objects</h6>

  <p>All the line styles (line width, caps, joins, and dash patterns) and text styles (fonts)
  described in the next two sections apply to <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> objects and to
  <code><a href="#drawingstyle">DrawingStyle</a></code> objects. This section defines the constructor used to obtain a
  <code><a href="#drawingstyle">DrawingStyle</a></code> object. This object is then used by methods on <code><a href="#path2d">Path2D</a></code>
  objects to control how text and paths are rasterised and stroked.</p>

  <dl class="domintro">

   <dt><var data-anolis-xref="">styles</var> = new <code data-anolis-xref="dom-DrawingStyle"><a href="#dom-drawingstyle">DrawingStyle</a></code>( [ <var data-anolis-xref="">element</var> ] )</dt>

   <dd>

    <p>Creates a new <code><a href="#drawingstyle">DrawingStyle</a></code> object, optionally using a specific element for
    resolving relative keywords and sizes in font specifications.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Each <code><a href="#drawingstyle">DrawingStyle</a></code> object can have a <dfn id="styles-scope-object">styles scope object</dfn>.</p>

  <p>The <dfn data-anolis-xref="dom-DrawingStyle" id="dom-drawingstyle"><code>DrawingStyle()</code></dfn> constructor, when invoked,
  must return a newly created <code><a href="#drawingstyle">DrawingStyle</a></code> object. If the constructor was passed an
  argument, then the <code><a href="#drawingstyle">DrawingStyle</a></code> object's <a href="#styles-scope-object">styles scope object</a> is that
  element. Otherwise, if the <span>JavaScript global environment</span> is a <span>document
  environment</span>, the object's <a href="#styles-scope-object">styles scope object</a> is the <code>Document</code>
  object of the <span>active document</span> of the <span>browsing context</span> of the
  <code>Window</code> object on which the interface object of the invoked constructor is found.
  Otherwise, the <span>JavaScript global environment</span> is a <span>worker environment</span>,
  and the <a href="#styles-scope-object">styles scope object</a> is the worker.</p>

  </div>


  <h6 id="line-styles"><span class="secno">1.1.4 </span>Line styles</h6>

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dt><var data-anolis-xref="">styles</var> . <code data-anolis-xref="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current line width.</p>

    <p>Can be set, to change the line width. Values that are not finite values greater than zero are
    ignored.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dt><var data-anolis-xref="">styles</var> . <code data-anolis-xref="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current line cap style.</p>

    <p>Can be set, to change the line cap style.</p>

    <p>The possible line cap styles are <code>butt</code>, <code>round</code>, and
    <code>square</code>. Other values are ignored.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dt><var data-anolis-xref="">styles</var> . <code data-anolis-xref="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current line join style.</p>

    <p>Can be set, to change the line join style.</p>

    <p>The possible line join styles are <code>bevel</code>, <code>round</code>, and
    <code>miter</code>. Other values are ignored.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-miterLimit"><a href="#dom-context-2d-miterlimit">miterLimit</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dt><var data-anolis-xref="">styles</var> . <code data-anolis-xref="dom-context-2d-miterLimit"><a href="#dom-context-2d-miterlimit">miterLimit</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current miter limit ratio.</p>

    <p>Can be set, to change the miter limit ratio. Values that are not finite values greater than
    zero are ignored.</p>

   </dd>


   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-setLineDash"><a href="#dom-context-2d-setlinedash">setLineDash</a></code>(<var data-anolis-xref="">segments</var>)</dt>
   <dt><var data-anolis-xref="">styles</var> . <code data-anolis-xref="dom-context-2d-setLineDash"><a href="#dom-context-2d-setlinedash">setLineDash</a></code>(<var data-anolis-xref="">segments</var>)</dt>

   <dd>

    <p>Sets the current line dash pattern (as used when stroking). The argument is a list of
    distances for which to alternately have the line on and the line off.</p>

   </dd>


   <dt><var data-anolis-xref="">segments</var> = <var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-getLineDash"><a href="#dom-context-2d-getlinedash">getLineDash</a></code>()</dt>
   <dt><var data-anolis-xref="">segments</var> = <var data-anolis-xref="">styles</var> . <code data-anolis-xref="dom-context-2d-getLineDash"><a href="#dom-context-2d-getlinedash">getLineDash</a></code>()</dt>

   <dd>

    <p>Returns a copy of the current line dash pattern. The array returned will always have an even
    number of entries (i.e. the pattern is normalized).</p>

   </dd>


   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-lineDashOffset"><a href="#dom-context-2d-linedashoffset">lineDashOffset</a></code></dt>
   <dt><var data-anolis-xref="">styles</var> . <code data-anolis-xref="dom-context-2d-lineDashOffset"><a href="#dom-context-2d-linedashoffset">lineDashOffset</a></code></dt>

   <dd>

    <p>Returns the phase offset (in the same units as the line dash pattern).</p>

    <p>Can be set, to change the phase offset. Values that are not finite values are ignored.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Objects that implement the <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> interface have attributes and
  methods (defined in this section) that control how lines are treated by the object.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-lineWidth" id="dom-context-2d-linewidth"><code>lineWidth</code></dfn> attribute gives the
  width of lines, in coordinate space units. On getting, it must return the current value. On
  setting, zero, negative, infinite, and NaN values must be ignored, leaving the value unchanged;
  other values must change the current value to the new value.</p>

  <p>When the object implementing the <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> interface is created, the
  <code data-anolis-xref="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> attribute must initially have the value
  <code>1.0</code>.</p>

  <hr>

  <p>The <dfn data-anolis-xref="dom-context-2d-lineCap" id="dom-context-2d-linecap"><code>lineCap</code></dfn> attribute defines the type
  of endings that UAs will place on the end of lines. The three valid values are <code>butt</code>,
  <code>round</code>, and <code>square</code>.</p>

  <p>On getting, it must return the current value. On setting, if the new value is one of the
  literal strings <code>butt</code>, <code>round</code>, and <code>square</code>, then the current
  value must be changed to the new value; other values must ignored, leaving the value
  unchanged.</p>

  <p>When the object implementing the <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> interface is created, the
  <code data-anolis-xref="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code> attribute must initially have the value
  <code>butt</code>.</p>

  <hr>

  <p>The <dfn data-anolis-xref="dom-context-2d-lineJoin" id="dom-context-2d-linejoin"><code>lineJoin</code></dfn> attribute defines the type
  of corners that UAs will place where two lines meet. The three valid values are
  <code>bevel</code>, <code>round</code>, and <code>miter</code>.</p>

  <p>On getting, it must return the current value. On setting, if the new value is one of the
  literal strings <code>bevel</code>, <code>round</code>, and <code>miter</code>, then the current
  value must be changed to the new value; other values must be ignored, leaving the value
  unchanged.</p>

  <p>When the object implementing the <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> interface is created, the
  <code data-anolis-xref="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code> attribute must initially have the value
  <code>miter</code>.</p>

  <hr>

  <p>When the <code data-anolis-xref="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code> attribute has the value
  <code>miter</code>, strokes use the miter limit ratio to decide how to render joins. The miter
  limit ratio can be explicitly set using the <dfn data-anolis-xref="dom-context-2d-miterLimit" id="dom-context-2d-miterlimit"><code>miterLimit</code></dfn> attribute. On getting, it must
  return the current value. On setting, zero, negative, infinite, and NaN values must be ignored,
  leaving the value unchanged; other values must change the current value to the new value.</p>
  <!-- values less than 1.0 are equivalent to 1.0, since it's compared
       against a ratio that can't be less than 1.0 -->

  <p>When the object implementing the <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> interface is created, the
  <code data-anolis-xref="dom-context-2d-miterLimit"><a href="#dom-context-2d-miterlimit">miterLimit</a></code> attribute must initially have the value
  <code>10.0</code>.</p>

  <hr>

  <p>Each <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> object has a <dfn id="dash-list">dash list</dfn>, which is either empty
  or consists of an even number of non-negative numbers. Initially, the <a href="#dash-list">dash list</a> must
  be empty.</p>

  <p>When the <dfn data-anolis-xref="dom-context-2d-setLineDash" id="dom-context-2d-setlinedash"><code>setLineDash()</code></dfn> method is
  invoked, it must run the following steps:</p>

  <ol>

   <li><p>Let <var data-anolis-xref="">a</var> be the argument.</p></li>

   <li><p>If any value in <var data-anolis-xref="">a</var> is not finite (e.g. an Infinity or a NaN value), or
   if any value is negative (less than zero), then abort these steps (without throwing an exception;
   user agents could show a message on a developer console, though, as that would be helpful for
   debugging).</p></li>

   <li><p>If the number of elements in <var data-anolis-xref="">a</var> is odd, then let <var data-anolis-xref="">a</var>
   be the concatentation of two copies of <var data-anolis-xref="">a</var>.</p></li>

   <li><p>Let the object's <a href="#dash-list">dash list</a> be <var data-anolis-xref="">a</var>.</p></li>

  </ol>

  <p>When the <dfn data-anolis-xref="dom-context-2d-getLineDash" id="dom-context-2d-getlinedash"><code>getLineDash()</code></dfn> method is
  invoked, it must return a sequence whose values are the values of the object's <a href="#dash-list">dash
  list</a>, in the same order.</p>

  <p>It is sometimes useful to change the "phase" of the dash pattern, e.g. to achieve a "marching
  ants" effect. The phase can be set using the <dfn data-anolis-xref="dom-context-2d-lineDashOffset" id="dom-context-2d-linedashoffset"><code>lineDashOffset</code></dfn> attribute. On getting, it
  must return the current value. On setting, infinite and NaN values must be ignored, leaving the
  value unchanged; other values must change the current value to the new value.</p>

  <p>When the object implementing the <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> interface is created, the
  <code data-anolis-xref="dom-context-2d-lineDashOffset"><a href="#dom-context-2d-linedashoffset">lineDashOffset</a></code> attribute must initially have
  the value <code>0.0</code>.</p>

  <hr>

  <p>When a user agent is to <dfn id="trace-a-path">trace a <span data-anolis-xref="concept-path">path</span></dfn>, <!-- <dfn>trace a path</dfn> -->
  given an object <var data-anolis-xref="">style</var> that implements the <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code>
  interface, it must run the following algorithm. This algorithm returns a new <a data-anolis-xref="concept-path" href="#concept-path">path</a>.</p>

  <ol>

   <li><p>Let <var data-anolis-xref="">path</var> be a copy of the path being traced.</p></li>

   <!-- PATH SANITIZATION -->

   <li><p>Prune all zero-length <a href="#line-segments">line segments</a> from <var data-anolis-xref="">path</var>.</p></li>

   <li><p>Remove from <var data-anolis-xref="">path</var> any subpaths containing no lines (i.e. subpaths with
   just one point).</p></li>

   <li><p>Replace each point in each subpath of <var data-anolis-xref="">path</var> other than the first point
   and the last point of each subpath by a <i>join</i> that joins the line leading to that point to
   the line leading out of that point, such that the subpaths all consist of two points (a starting
   point with a line leading out of it, and an ending point with a line leading into it), one or
   more lines (connecting the points and the joins), and zero or more joins (each connecting one
   line to another), connected together such that each subpath is a series of one or more lines with
   a join between each one and a point on each end.</p></li>

   <li><p>Add a straight closing line to each closed subpath in <var data-anolis-xref="">path</var> connecting
   the last point and the first point of that subpath; change the last point to a join (from the
   previously last line to the newly added closing line), and change the first point to a join (from
   the newly added closing line to the first line).</p>

   </li><li><p>If the <var data-anolis-xref="">styles</var> <a href="#dash-list">dash list</a> is empty, jump to the step
   labeled <i>convert</i>.</p></li>

   <!-- DASHING -->

   <li><p>Let <var data-anolis-xref="">pattern width</var> be the concatenation of all the entries of the <var data-anolis-xref="">styles</var> <a href="#dash-list">dash list</a>, in coordinate space units.</p>

   </li><li><p>For each subpath <var data-anolis-xref="">subpath</var> in <var data-anolis-xref="">path</var>, run the
   following substeps. These substeps mutate the subpaths in <var data-anolis-xref="">path</var> <i>in
   vivo</i>.</p>

    <ol>

     <li><p>Let <var data-anolis-xref="">subpath width</var> be the length of all the lines of <var data-anolis-xref="">subpath</var>, in coordinate space units.</p>

     </li><li><p>Let <var data-anolis-xref="">offset</var> be the value of the <var data-anolis-xref="">styles</var> <code data-anolis-xref="dom-context-2d-lineDashOffset"><a href="#dom-context-2d-linedashoffset">lineDashOffset</a></code>, in coordinate space
     units.</p></li>

     <li>

      <p>While <var data-anolis-xref="">offset</var> is greater than <var data-anolis-xref="">pattern width</var>,
      decrement it by <var data-anolis-xref="">pattern width</var>.</p>

      <p>While <var data-anolis-xref="">offset</var> is less than zero, increment it by <var data-anolis-xref="">pattern
      width</var>.</p>

     </li>

     <li><p>Define <var data-anolis-xref="">L</var> to be a linear coordinate line defined along all lines in
     <var data-anolis-xref="">subpath</var>, such that the start of the first line in the subpath is defined
     as coordinate 0, and the end of the last line in the subpath is defined as coordinate <var data-anolis-xref="">subpath width</var>.</p></li>

     <li><p>Let <var data-anolis-xref="">position</var> be zero minus <var data-anolis-xref="">offset</var>.</p></li>

     <li><p>Let <var data-anolis-xref="">index</var> be 0.</p></li>

     <li><p>Let <var data-anolis-xref="">current state</var> be <i>off</i> (the other states being <i>on</i>
     and <i>zero-on</i>).</p></li>

     <li><p><i>Dash on</i>: Let <var data-anolis-xref="">segment length</var> be
     the value of the <var data-anolis-xref="">styles</var> <a href="#dash-list">dash
     list</a>'s <var data-anolis-xref="">index</var>th entry.</p></li>

     <li><p>Increment <var data-anolis-xref="">position</var> by <var data-anolis-xref="">segment length</var>.</p></li>

     <li><p>If <var data-anolis-xref="">position</var> is greater than <var data-anolis-xref="">subpath width</var>, then
     end these substeps for this subpath and start them again for the next subpath; if there are no
     more subpaths, then jump to the step labeled <i>convert</i> instead.</p></li>

     <li><p>If <var data-anolis-xref="">segment length</var> is non-zero, let <var data-anolis-xref="">current state</var> be <i>on</i>.</p></li>

     <li><p>Increment <var data-anolis-xref="">index</var> by one.</p></li>

     <li><p><i>Dash off<!-- labeled for consistency only --></i>: Let <var data-anolis-xref="">segment
     length</var> be the value of the <var data-anolis-xref="">styles</var> <a href="#dash-list">dash list</a>'s <var data-anolis-xref="">index</var>th entry.</p></li>

     <li><p>Let <var data-anolis-xref="">start</var> be the offset <var data-anolis-xref="">position</var> on <var data-anolis-xref="">L</var>.</p></li>

     <li><p>Increment <var data-anolis-xref="">position</var> by <var data-anolis-xref="">segment length</var>.</p></li>

     <li><p>If <var data-anolis-xref="">position</var> is less than zero, then jump to the step labeled
     <i>post-cut</i>.</p></li> <!-- start and end both before zero -->

     <li><p>If <var data-anolis-xref="">start</var> is less than zero, then let <var data-anolis-xref="">start</var> be
     zero.</p></li> <!-- end will be (at or) after zero -->

     <li><p>If <var data-anolis-xref="">position</var> is greater than <var data-anolis-xref="">subpath width</var>, then
     let <var data-anolis-xref="">end</var> be the offset <var data-anolis-xref="">subpath width</var> on <var data-anolis-xref="">L</var>. Otherwise, let <var data-anolis-xref="">end</var> be the offset <var data-anolis-xref="">position</var> on <var data-anolis-xref="">L</var>.</p></li>

     <li>

      <p>Jump to the first appropriate step:</p>

      <dl class="switch">

       <dt>If <var data-anolis-xref="">segment length</var> is zero and <var data-anolis-xref="">current state</var> is <i>off</i></dt>

       <dd>

        <p>Do nothing, just continue to the next step.</p>

       </dd>


       <dt>If <var data-anolis-xref="">current state</var> is <i>off</i></dt>

       <dd>

        <p>Cut the line on which <var data-anolis-xref="">end</var> finds itself short at <var data-anolis-xref="">end</var> and place a point there, cutting the subpath that it was in in two;
        remove all line segments, joins, points, and subpaths that are between <var data-anolis-xref="">start</var> and <var data-anolis-xref="">end</var>; and finally place a single point at <var data-anolis-xref="">start</var> with no lines connecting to it.</p>

        <p>The point has a <i>directionality</i> for the purposes of drawing line caps (see below).
        The directionality is the direction that the original line had at that point (i.e. when <var data-anolis-xref="">L</var> was defined above).</p>

       </dd>


       <dt>Otherwise</dt>

       <dd>

        <p>Cut the line on which <var data-anolis-xref="">start</var> finds itself into two at <var data-anolis-xref="">start</var> and place a point there, cutting the subpath that it was in in two, and
        similarly cut the line on which <var data-anolis-xref="">end</var> finds itself short at <var data-anolis-xref="">end</var> and place a point there, cutting the subpath that <em>it</em> was in in
        two, and then remove all line segments, joins, points, and subpaths that are between <var data-anolis-xref="">start</var> and <var data-anolis-xref="">end</var>.</p>

        <p>If <var data-anolis-xref="">start</var> and <var data-anolis-xref="">end</var> are the same point, then this
        results in just the line being cut in two and two points being inserted there, with nothing
        being removed, unless a join also happens to be at that point, in which case the join must
        be removed.</p>

       </dd>

      </dl>

     </li>

     <li><p><i>Post-cut</i>: If <var data-anolis-xref="">position</var> is greater than <var data-anolis-xref="">subpath width</var>, then jump to the step labeled <i>convert</i>.</p></li>

     <li><p>If <var data-anolis-xref="">segment length</var> is greater than zero, let <var data-anolis-xref="">positioned-at-on-dash</var> be false.</p></li>

     <li><p>Increment <var data-anolis-xref="">index</var> by one. If it is equal to the number of entries in
     the <var data-anolis-xref="">styles</var> <a href="#dash-list">dash list</a>, then let <var data-anolis-xref="">index</var> be
     0.</p></li>

     <li><p>Return to the step labeled <i>dash on</i>.</p></li>

    </ol>

   </li>

   <!-- STROKING -->

   <li>

    <p><i>Convert</i>: This is the step that converts the path to a new path that represents its
    stroke.</p>

    <p>Create a new <a data-anolis-xref="concept-path" href="#concept-path">path</a> that describes the edge of the areas
    that would be covered if a straight line of length equal to the <var data-anolis-xref="">styles</var>
    <code data-anolis-xref="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> was swept along each subpath in <var data-anolis-xref="">path</var> while being kept at an angle such that the line is orthogonal to the path
    being swept, replacing each point with the end cap necessary to satisfy the <var data-anolis-xref="">styles</var> <code data-anolis-xref="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code> attribute as
    described previously and elaborated below, and replacing each join with the join necessary to
    satisfy the <var data-anolis-xref="">styles</var> <code data-anolis-xref="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code>
    type, as defined below.</p>

    <p><strong>Caps</strong>: Each point has a flat edge perpendicular to the direction of the line
    coming out of it. This is them augmented according to the value of the <var data-anolis-xref="">styles</var> <code data-anolis-xref="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code>. The
    <code>butt</code> value means that no additional line cap is added. The <code>round</code> value
    means that a semi-circle with the diameter equal to the <var data-anolis-xref="">styles</var> <code data-anolis-xref="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> width must additionally be placed on to the
    line coming out of each point. The <code>square</code> value means that a rectangle with the
    length of the <var data-anolis-xref="">styles</var> <code data-anolis-xref="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> width and the width of half the <var data-anolis-xref="">styles</var> <code data-anolis-xref="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> width, placed
    flat against the edge perpendicular to the direction of the line coming out of the point, must
    be added at each point.</p>

    <p>Points with no lines coming out of them must have two caps placed back-to-back as if it was
    really two points connected to each other by an infinitesimally short straight line in the
    direction of the point's <i>directionality</i> (as defined above).</p>

    <p><strong>Joins</strong>: In addition to the point where a join occurs, two additional points
    are relevant to each join, one for each line: the two corners found half the line width away
    from the join point, one perpendicular to each line, each on the side furthest from the other
    line.</p>

    <p>A triangle connecting these two opposite corners with a straight line, with the third point
    of the triangle being the join point, must be added at all joins. The <code data-anolis-xref="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code> attribute controls whether anything else is
    rendered. The three aforementioned values have the following meanings:</p>

    <p>The <code>bevel</code> value means that this is all that is rendered at joins.</p>

    <p>The <code>round</code> value means that an arc connecting the two aforementioned corners of
    the join, abutting (and not overlapping) the aforementioned triangle, with the diameter equal to
    the line width and the origin at the point of the join, must be added at joins.</p>

    <p>The <code>miter</code> value means that a second triangle must (if it can given the miter
    length) be added at the join, with one line being the line between the two aforementioned
    corners, abutting the first triangle, and the other two being continuations of the outside edges
    of the two joining lines, as long as required to intersect without going over the miter
    length.</p>

    <p>The miter length is the distance from the point where the join occurs to the intersection of
    the line edges on the outside of the join. The miter limit ratio is the maximum allowed ratio of
    the miter length to half the line width. If the miter length would cause the miter limit ratio
    (as set by the <var data-anolis-xref="">style</var> <code data-anolis-xref="dom-context-2d-miterLimit"><a href="#dom-context-2d-miterlimit">miterLimit</a></code> attribute) to be exceeded, this second
    triangle must not be added.</p> <!-- the actual ratio can't possibly be less than 1.0 -->

<!-- here's a nice demo of the miter:
  c.clearRect(0, 0, 640, 480);
  c.beginPath();

  c.moveTo((new Date()/100) % 600, 100);
  c.lineTo(300, 300);
  c.lineTo(500, 300);

  c.lineWidth = 50;
  c.miterLimit = 10000;
  c.strokeStyle = 'silver'
  c.stroke();

  c.miterLimit = 0.0001;
  c.strokeStyle = 'black'
  c.stroke();

  c.lineWidth = 1;
  c.strokeStyle = 'red'
  c.stroke();
-->

    <p>The subpaths in the newly created path must be oriented such that for any point, the number
    of times a half-infinite straight line drawn from that point crosses a subpath is even if and
    only if the number of times a half-infinite straight line drawn from that same point crosses a
    subpath going in one direction is equal to the number of times it crosses a subpath going in the
    other direction.</p>

   </li>

   <li><p>Return the newly created path.</p></li>

  </ol>

<!--v6: Another request has been for hairline width lines, that remain hairline width with
transform. ack Shaun Morris. -->

  </div>


  <h6 id="text-styles"><span class="secno">1.1.5 </span>Text styles</h6>

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dt><var data-anolis-xref="">styles</var> . <code data-anolis-xref="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current font settings.</p>

    <p>Can be set, to change the font. The syntax is the same as for the CSS 'font' property; values
    that cannot be parsed as CSS font values are ignored.</p>

    <p>Relative keywords and lengths are computed relative to the font of the <code>canvas</code>
    element.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dt><var data-anolis-xref="">styles</var> . <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current text alignment settings.</p>

    <p>Can be set, to change the alignment. The possible values are and their meanings are given
    below. Other values are ignored. The default is <code data-anolis-xref="">start</code>.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dt><var data-anolis-xref="">styles</var> . <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current baseline alignment settings.</p>

    <p>Can be set, to change the baseline alignment. The possible values and their meanings are
    given below. Other values are ignored. The default is <code data-anolis-xref="dom-concept-2d-textAlign-alphabetic">alphabetic</code>.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-direction"><a href="#dom-context-2d-direction">direction</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dt><var data-anolis-xref="">styles</var> . <code data-anolis-xref="dom-context-2d-direction"><a href="#dom-context-2d-direction">direction</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current directionality.</p>

    <p>Can be set, to change the directionality. The possible values and their meanings are given
    below. Other values are ignored. The default is <code data-anolis-xref="dom-concept-2d-textAlign-inherit">inherit</code>.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Objects that implement the <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> interface have attributes (defined
  in this section) that control how text is laid out (rasterised or outlined) by the object. Such
  objects can also have a <dfn id="font-style-source-object">font style source object</dfn>. For
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> objects whose <span data-anolis-xref="concept-canvas-context-bitmap-mode">context bitmap mode</span> is <span data-anolis-xref="concept-canvas-fixed">fixed</span>, this is their <code>canvas</code> element; for other
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> objects, if the <span>JavaScript global environment</span>
  is a <span>document environment</span>, the object's <a href="#font-style-source-object">font style source object</a> is the
  <code>Document</code> object of the <span>active document</span> of the <span>browsing
  context</span> of the <code>Window</code> object on which the interface object of the
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object is found; otherwise the <span>JavaScript global
  environment</span> is a <span>worker environment</span> and the <a href="#font-style-source-object">font style source
  object</a> is the worker. For <code><a href="#drawingstyle">DrawingStyle</a></code> objects, it's the <a href="#styles-scope-object">styles scope
  object</a>.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-font" id="dom-context-2d-font"><code>font</code></dfn> IDL attribute, on setting, must
  be parsed the same way as the 'font' property of CSS (but without supporting property-independent
  style sheet syntax like 'inherit'), and the resulting font must be assigned to the context, with
  the 'line-height' component forced to 'normal', with the 'font-size' component converted to CSS
  pixels, and with system fonts being computed to explicit values. If the new value is syntactically
  incorrect (including using property-independent style sheet syntax like 'inherit' or 'initial'),
  then it must be ignored, without assigning a new font value. <a href="#refsCSS">[CSS]</a></p>

  <p>Font family names must be interpreted in the context of the <a href="#font-style-source-object">font style source
  object</a> when the font is to be used; any fonts embedded using <code data-anolis-xref="">@font-face</code> or loaded using the <code>FontLoader</code> that are visible to the
  <a href="#font-style-source-object">font style source object</a> must therefore be available once they are loaded. If a font
  is used before it is fully loaded, or if the <a href="#font-style-source-object">font style source object</a> does not have
  that font in scope at the time the font is to be used, then it must be treated as if it was an
  unknown font, falling back to another as described by the relevant CSS specifications. <a href="#refsCSSFONTS">[CSSFONTS]</a> <a href="#refsCSSFONTLOAD">[CSSFONTLOAD]</a></p>

  <p>On getting, the <code data-anolis-xref="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code> attribute must return the <span data-anolis-xref="serializing a CSS value">serialised form</span> of the current font of the context (with
  no 'line-height' component). <a href="#refsCSSOM">[CSSOM]</a></p>

  <div class="example">

   <p>For example, after the following statement:</p>

   <pre>context.font = 'italic 400 12px/2 Unknown Font, sans-serif';</pre>

   <p>...the expression <code data-anolis-xref="">context.font</code> would evaluate to the string "<code data-anolis-xref="">italic 12px "Unknown Font", sans-serif</code>". The "400"
   font-weight doesn't appear because that is the default value. The line-height doesn't appear
   because it is forced to "normal", the default value.</p>

  </div>

  <p>When the object implementing the <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> interface is created, the
  font of the context must be set to 10px sans-serif. When the 'font-size' component is set to
  lengths using percentages, 'em' or 'ex' units, or the 'larger' or 'smaller' keywords, these must
  be interpreted relative to the computed value of the 'font-size' property of the <a href="#font-style-source-object">font style
  source object</a> at the time that the attribute is set, if it is an element. When the
  'font-weight' component is set to the relative values 'bolder' and 'lighter', these must be
  interpreted relative to the computed value of the 'font-weight' property of the <a href="#font-style-source-object">font style
  source object</a> at the time that the attribute is set, if it is an element. If the computed
  values are undefined for a particular case (e.g. because the <a href="#font-style-source-object">font style source object</a>
  is not an element or is not <span>being rendered</span>), then the relative keywords must be
  interpreted relative to the normal-weight 10px sans-serif default.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-textAlign" id="dom-context-2d-textalign"><code>textAlign</code></dfn> IDL attribute, on
  getting, must return the current value. On setting, if the value is one of <code data-anolis-xref="dom-concept-2d-textAlign-start"><a href="#dom-concept-2d-textalign-start">start</a></code>, <code data-anolis-xref="dom-concept-2d-textAlign-end"><a href="#dom-concept-2d-textalign-end">end</a></code>, <code data-anolis-xref="dom-concept-2d-textAlign-left"><a href="#dom-concept-2d-textalign-left">left</a></code>, <code data-anolis-xref="dom-concept-2d-textAlign-right"><a href="#dom-concept-2d-textalign-right">right</a></code>, or <code data-anolis-xref="dom-concept-2d-textAlign-center"><a href="#dom-concept-2d-textalign-center">center</a></code>, then the value must be changed to the new
  value. Otherwise, the new value must be ignored. When the object implementing the
  <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> interface is created, the <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> attribute must initially have the value <code data-anolis-xref="dom-concept-2d-textAlign-start"><a href="#dom-concept-2d-textalign-start">start</a></code>.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-textBaseline" id="dom-context-2d-textbaseline"><code>textBaseline</code></dfn> IDL attribute, on
  getting, must return the current value. On setting, if the value is one of <code data-anolis-xref="dom-context-2d-textBaseline-top"><a href="#dom-context-2d-textbaseline-top">top</a></code>, <code data-anolis-xref="dom-context-2d-textBaseline-hanging"><a href="#dom-context-2d-textbaseline-hanging">hanging</a></code>, <code data-anolis-xref="dom-context-2d-textBaseline-middle"><a href="#dom-context-2d-textbaseline-middle">middle</a></code>, <code data-anolis-xref="dom-context-2d-textBaseline-alphabetic"><a href="#dom-context-2d-textbaseline-alphabetic">alphabetic</a></code>, <code data-anolis-xref="dom-context-2d-textBaseline-ideographic"><a href="#dom-context-2d-textbaseline-ideographic">ideographic</a></code>, or <code data-anolis-xref="dom-context-2d-textBaseline-bottom"><a href="#dom-context-2d-textbaseline-bottom">bottom</a></code>, then the value must be changed to the
  new value. Otherwise, the new value must be ignored. When the object implementing the
  <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> interface is created, the <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> attribute must initially have the value
  <code data-anolis-xref="dom-context-2d-textBaseline-alphabetic"><a href="#dom-context-2d-textbaseline-alphabetic">alphabetic</a></code>.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-direction" id="dom-context-2d-direction"><code>direction</code></dfn> IDL attribute, on
  getting, must return the current value. On setting, if the value is one of <code data-anolis-xref="dom-context-2d-direction-ltr">ltr</code>, <code data-anolis-xref="dom-context-2d-direction-rtl">rtl</code>, <!--<code
  data-x="dom-context-2d-direction-auto">auto</code>,--> or <code data-anolis-xref="dom-context-2d-direction-inherit">inherit</code>, then the value must be changed to the
  new value. Otherwise, the new value must be ignored. When the object implementing the
  <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> interface is created, the <code data-anolis-xref="dom-context-2d-direction"><a href="#dom-context-2d-direction">direction</a></code> attribute must initially have the value <code data-anolis-xref="dom-context-2d-direction-inherit">inherit</code>.</p>

  </div>

  <p>The <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> attribute's allowed keywords are
  as follows:</p>

  <dl>

   <dt><dfn data-anolis-xref="dom-concept-2d-textAlign-start" id="dom-concept-2d-textalign-start"><code>start</code></dfn>
   </dt><dd><p>Align to the start edge of the text (left side in left-to-right text, right side in
   right-to-left text).</p></dd>

   <dt><dfn data-anolis-xref="dom-concept-2d-textAlign-end" id="dom-concept-2d-textalign-end"><code>end</code></dfn>
   </dt><dd><p>Align to the end edge of the text (right side in left-to-right text, left side in
   right-to-left text).</p></dd>

   <dt><dfn data-anolis-xref="dom-concept-2d-textAlign-left" id="dom-concept-2d-textalign-left"><code>left</code></dfn>
   </dt><dd><p>Align to the left.</p></dd>

   <dt><dfn data-anolis-xref="dom-concept-2d-textAlign-right" id="dom-concept-2d-textalign-right"><code>right</code></dfn>
   </dt><dd><p>Align to the right.</p></dd>

   <dt><dfn data-anolis-xref="dom-concept-2d-textAlign-center" id="dom-concept-2d-textalign-center"><code>center</code></dfn>
   </dt><dd><p>Align to the center.</p></dd>

  </dl>

  <p>The <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code>
  attribute's allowed keywords correspond to alignment points in the
  font:</p>

  <p><img alt="The top of the em square is roughly at the top of the glyphs in a font, the hanging baseline is where some glyphs like आ are anchored, the middle is half-way between the top of the em square and the bottom of the em square, the alphabetic baseline is where characters like Á, ÿ, f, and Ω are anchored, the ideographic baseline is where glyphs like 私 and 達 are anchored, and the bottom of the em square is roughly at the bottom of the glyphs in a font. The top and bottom of the bounding box can be far from these baselines, due to glyphs extending far outside the em square." height="300" src="images/baselines.png" width="738"></p>

  <p>The keywords map to these alignment points as follows:</p>

  <dl>

   <dt><dfn data-anolis-xref="dom-context-2d-textBaseline-top" id="dom-context-2d-textbaseline-top"><code>top</code></dfn>
   </dt><dd>The top of the em square</dd>

   <dt><dfn data-anolis-xref="dom-context-2d-textBaseline-hanging" id="dom-context-2d-textbaseline-hanging"><code>hanging</code></dfn>
   </dt><dd>The hanging baseline</dd>

   <dt><dfn data-anolis-xref="dom-context-2d-textBaseline-middle" id="dom-context-2d-textbaseline-middle"><code>middle</code></dfn>
   </dt><dd>The middle of the em square</dd>

   <dt><dfn data-anolis-xref="dom-context-2d-textBaseline-alphabetic" id="dom-context-2d-textbaseline-alphabetic"><code>alphabetic</code></dfn>
   </dt><dd>The alphabetic baseline</dd>

   <dt><dfn data-anolis-xref="dom-context-2d-textBaseline-ideographic" id="dom-context-2d-textbaseline-ideographic"><code>ideographic</code></dfn>
   </dt><dd>The ideographic baseline</dd>

   <dt><dfn data-anolis-xref="dom-context-2d-textBaseline-bottom" id="dom-context-2d-textbaseline-bottom"><code>bottom</code></dfn>
   </dt><dd>The bottom of the em square</dd>

  </dl>

  <p>The <code data-anolis-xref="dom-context-2d-direction"><a href="#dom-context-2d-direction">direction</a></code> attribute's allowed keywords are
  as follows:</p>

  <dl>

   <dt><dfn data-anolis-xref="dom-concept-2d-direction-ltr" id="dom-concept-2d-direction-ltr"><code>ltr</code></dfn>

   </dt><dd><p>Treat input to the <a href="#text-preparation-algorithm">text preparation algorithm</a> as left-to-right text.</p></dd>

   <dt><dfn data-anolis-xref="dom-concept-2d-direction-rtl" id="dom-concept-2d-direction-rtl"><code>rtl</code></dfn>

   </dt><dd><p>Treat input to the <a href="#text-preparation-algorithm">text preparation algorithm</a> as right-to-left text.</p></dd>

<!--
   <dt><dfn data-x="dom-concept-2d-direction-auto"><code>auto</code></dfn>

   <dd><p>Determine the direction from the input to the <span>text preparation algorithm</span>.</p></dd>
-->

   <dt><dfn data-anolis-xref="dom-concept-2d-direction-inherit" id="dom-concept-2d-direction-inherit"><code>inherit</code></dfn>

   </dt><dd><p>Default to the directionality of the <code>canvas</code> element or <code>Document</code>
   as appropriate.</p></dd>

  </dl>

  <p>The <dfn id="text-preparation-algorithm">text preparation algorithm</dfn> is as follows. It takes as input a string <var data-anolis-xref="">text</var>, a <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> object <var data-anolis-xref="">target</var>, and an
  optional length <var data-anolis-xref="">maxWidth</var>. It returns an array of glyph shapes, each positioned
  on a common coordinate space, a <var data-anolis-xref="">physical alignment</var> whose value is one of
  <i>left</i>, <i>right</i>, and <i data-anolis-xref="">center</i>, and an inline box. (Most callers of this
  algorithm ignore the <var data-anolis-xref="">physical alignment</var> and the inline box.)</p>

  <ol>

   <li><p>If <var data-anolis-xref="">maxWidth</var> was provided but is less than or equal to zero, return an
   empty array.</p></li>

   <li><p>Replace all the <span data-anolis-xref="space character">space characters</span> in <var data-anolis-xref="">text</var> with U+0020 SPACE characters.</p></li>

   <li><p>Let <var data-anolis-xref="">font</var> be the current font of <var data-anolis-xref="">target</var>, as given
   by that object's <code data-anolis-xref="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code> attribute.</p></li>

   <li>

    <p>Apply the appropriate step from the following list to determine the value of <var data-anolis-xref="">direction</var>:</p>

    <dl class="switch">

     <dt>If the <var data-anolis-xref="">target</var> object's <code data-anolis-xref="dom-context-2d-direction"><a href="#dom-context-2d-direction">direction</a></code> attribute has the value "<code data-anolis-xref="dom-context-2d-direction-ltr">ltr</code>"</dt>
     <dd>Let <var data-anolis-xref="">direction</var> be '<span data-anolis-xref="concept-ltr">ltr</span>'.</dd>

     <dt>If the <var data-anolis-xref="">target</var> object's <code data-anolis-xref="dom-context-2d-direction"><a href="#dom-context-2d-direction">direction</a></code> attribute has the value "<code data-anolis-xref="dom-context-2d-direction-rtl">rtl</code>"</dt>
     <dd>Let <var data-anolis-xref="">direction</var> be '<span data-anolis-xref="concept-rtl">rtl</span>'.</dd>

<!--
     <dt>If the <var data-x="">target</var> object's <code
     data-x="dom-context-2d-direction">direction</code> attribute has the value "<code
     data-x="dom-context-2d-direction-auto">auto</code>"</dt>
     <dd>
      Find the first character in <var data-x="">text</var> of bidirectional character type L, AL, or
      R, if any. If such a character is found and it is of bidirectional character type AL or R,
      then let <var data-x="">direction</var> be '<span data-x="concept-rtl">rtl</span>'; otherwise,
      let <var data-x="">direction</var> be '<span data-x="concept-rtl">rtl</span>'. <a
      href="#refsBIDI">[BIDI]</a>
     </dd>
-->

     <dt>If the <var data-anolis-xref="">target</var> object's <a href="#font-style-source-object">font style source object</a> is an
     element</dt>

     <dd>Let <var data-anolis-xref="">direction</var> be <span>the directionality</span> of the <var data-anolis-xref="">target</var> object's <a href="#font-style-source-object">font style source object</a>.</dd>

     <dt>If the <var data-anolis-xref="">target</var> object's <a href="#font-style-source-object">font style source object</a> is a
     <code>Document</code> and that <code>Document</code> has a root element child</dt>

     <dd>Let <var data-anolis-xref="">direction</var> be <span>the directionality</span> of the <var data-anolis-xref="">target</var> object's <a href="#font-style-source-object">font style source object</a>'s root element child.</dd>

     <dt>Otherwise</dt>

     <dd>Let <var data-anolis-xref="">direction</var> be '<span data-anolis-xref="concept-ltr">ltr</span>'.</dd>

    </dl>

   </li>

   <li><p>Form a hypothetical infinitely-wide CSS line box containing a single inline box containing
   the text <var data-anolis-xref="">text</var>, with all the properties at their initial values except the
   'font' property of the inline box set to <var data-anolis-xref="">font</var>, the 'direction' property of
   the inline box set to <var data-anolis-xref="">direction</var>, and the 'white-space' property set to 'pre'.
   <a href="#refsCSS">[CSS]</a></p></li>

   <!-- if you insert a step here, make sure to adjust the next step's final words -->

   <li><p>If <var data-anolis-xref="">maxWidth</var> was provided and the hypothetical width of the inline box
   in the hypothetical line box is greater than <var data-anolis-xref="">maxWidth</var> CSS pixels, then change
   <var data-anolis-xref="">font</var> to have a more condensed font (if one is available or if a reasonably
   readable one can be synthesized by applying a horizontal scale factor to the font) or a smaller
   font, and return to the previous step.</p></li>

   <li>

    <p>The <var data-anolis-xref="">anchor point</var> is a point on the inline box, and the <var data-anolis-xref="">physical alignment</var> is one of the values <i>left</i>, <i>right</i>, and <i data-anolis-xref="">center</i>. These variables are determined by the <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> and <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> values as follows:</p>

    <p>Horizontal position:</p>

    <dl>

     <dt>If <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> is <code data-anolis-xref="dom-concept-2d-textAlign-left"><a href="#dom-concept-2d-textalign-left">left</a></code></dt>

     <dt>If <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> is <code data-anolis-xref="dom-concept-2d-textAlign-start"><a href="#dom-concept-2d-textalign-start">start</a></code> and <var data-anolis-xref="">direction</var> is
     'ltr'</dt>

     <dt>If <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> is <code data-anolis-xref="dom-concept-2d-textAlign-end"><a href="#dom-concept-2d-textalign-end">end</a></code> and <var data-anolis-xref="">direction</var> is 'rtl'</dt>

     <dd>Let the <var data-anolis-xref="">anchor point</var>'s horizontal position be the left edge of the
     inline box, and let <var data-anolis-xref="">physical alignment</var> be <i>left</i>.</dd>


     <dt>If <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> is <code data-anolis-xref="dom-concept-2d-textAlign-right"><a href="#dom-concept-2d-textalign-right">right</a></code></dt>

     <dt>If <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> is <code data-anolis-xref="dom-concept-2d-textAlign-end"><a href="#dom-concept-2d-textalign-end">end</a></code> and <var data-anolis-xref="">direction</var> is 'ltr'</dt>

     <dt>If <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> is <code data-anolis-xref="dom-concept-2d-textAlign-start"><a href="#dom-concept-2d-textalign-start">start</a></code> and <var data-anolis-xref="">direction</var> is
     'rtl'</dt>

     <dd>Let the <var data-anolis-xref="">anchor point</var>'s horizontal position be the right edge of the
     inline box, and let <var data-anolis-xref="">physical alignment</var> be <i>right</i>.</dd>


     <dt>If <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> is <code data-anolis-xref="dom-concept-2d-textAlign-center"><a href="#dom-concept-2d-textalign-center">center</a></code></dt>

     <dd>Let the <var data-anolis-xref="">anchor point</var>'s horizontal position be half way between the left
     and right edges of the inline box, and let <var data-anolis-xref="">physical alignment</var> be <i data-anolis-xref="">center</i>.</dd>

    </dl>

    <p>Vertical position:</p>

    <dl>

     <dt>If <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> is <code data-anolis-xref="dom-context-2d-textBaseline-top"><a href="#dom-context-2d-textbaseline-top">top</a></code></dt>

     <dd>Let the <var data-anolis-xref="">anchor point</var>'s vertical position be the top of the em box of
     the first available font of the inline box.</dd>


     <dt>If <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> is <code data-anolis-xref="dom-context-2d-textBaseline-hanging"><a href="#dom-context-2d-textbaseline-hanging">hanging</a></code></dt>

     <dd>Let the <var data-anolis-xref="">anchor point</var>'s vertical position be the hanging baseline of the
     first available font of the inline box.</dd>


     <dt>If <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> is <code data-anolis-xref="dom-context-2d-textBaseline-middle"><a href="#dom-context-2d-textbaseline-middle">middle</a></code></dt>

     <dd>Let the <var data-anolis-xref="">anchor point</var>'s vertical position be half way between the bottom
     and the top of the em box of the first available font of the inline box.</dd>


     <dt>If <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> is <code data-anolis-xref="dom-context-2d-textBaseline-alphabetic"><a href="#dom-context-2d-textbaseline-alphabetic">alphabetic</a></code></dt>

     <dd>Let the <var data-anolis-xref="">anchor point</var>'s vertical position be the alphabetic baseline of
     the first available font of the inline box.</dd>


     <dt>If <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> is <code data-anolis-xref="dom-context-2d-textBaseline-ideographic"><a href="#dom-context-2d-textbaseline-ideographic">ideographic</a></code></dt>

     <dd>Let the <var data-anolis-xref="">anchor point</var>'s vertical position be the ideographic baseline of
     the first available font of the inline box.</dd>


     <dt>If <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> is <code data-anolis-xref="dom-context-2d-textBaseline-bottom"><a href="#dom-context-2d-textbaseline-bottom">bottom</a></code></dt>

     <dd>Let the <var data-anolis-xref="">anchor point</var>'s vertical position be the bottom of the em box of
     the first available font of the inline box.</dd>

    </dl>

   </li>

   <li>

    <p>Let <var data-anolis-xref="">result</var> be an array constructed by iterating over each glyph in the
    inline box from left to right (if any), adding to the array, for each glyph, the shape of the
    glyph as it is in the inline box, positioned on a coordinate space using CSS pixels with its
    origin is at the <var data-anolis-xref="">anchor point</var>.</p>

   </li>

   <li><p>Return <var data-anolis-xref="">result</var>, <var data-anolis-xref="">physical alignment</var>, and the inline
   box.</p></li>

  </ol>


  <h6 id="building-paths"><span class="secno">1.1.6 </span>Building paths</h6>

  <p>Each object implementing the <code><a href="#canvaspathmethods">CanvasPathMethods</a></code> interface has a <a data-anolis-xref="concept-path" href="#concept-path">path</a>. A <dfn data-anolis-xref="concept-path" id="concept-path">path</dfn> has a list of zero or
  more subpaths. Each subpath consists of a list of one or more points, connected by straight or
  curved <dfn id="line-segments">line segments</dfn>, and a flag indicating whether the subpath is closed or not. A
  closed subpath is one where the last point of the subpath is connected to the first point of the
  subpath by a straight line. Subpaths with only one point are ignored when painting the path.</p>

  <p><a data-anolis-xref="concept-path" href="#concept-path">Paths</a> have a <dfn id="need-new-subpath">need new subpath</dfn> flag. When this
  flag is set, certain APIs create a new subpath rather than extending the previous one. When a
  <a data-anolis-xref="concept-path" href="#concept-path">path</a> is created, its <a href="#need-new-subpath">need new subpath</a> flag must be
  set.</p>

  <p>When an object implementing the <code><a href="#canvaspathmethods">CanvasPathMethods</a></code> interface is created, its <a data-anolis-xref="concept-path" href="#concept-path">path</a> must be initialised to zero subpaths.</p>

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-moveTo"><a href="#dom-context-2d-moveto">moveTo</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</dt>
   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-context-2d-moveTo"><a href="#dom-context-2d-moveto">moveTo</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</dt>

   <dd>

    <p>Creates a new subpath with the given point.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-closePath"><a href="#dom-context-2d-closepath">closePath</a></code>()</dt>
   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-context-2d-closePath"><a href="#dom-context-2d-closepath">closePath</a></code>()</dt>

   <dd>

    <p>Marks the current subpath as closed, and starts a new subpath with a point the same as the
    start and end of the newly closed subpath.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-lineTo"><a href="#dom-context-2d-lineto">lineTo</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</dt>
   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-context-2d-lineTo"><a href="#dom-context-2d-lineto">lineTo</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</dt>

   <dd>

    <p>Adds the given point to the current subpath, connected to the previous one by a straight
    line.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-quadraticCurveTo"><a href="#dom-context-2d-quadraticcurveto">quadraticCurveTo</a></code>(<var data-anolis-xref="">cpx</var>, <var data-anolis-xref="">cpy</var>, <var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</dt>
   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-context-2d-quadraticCurveTo"><a href="#dom-context-2d-quadraticcurveto">quadraticCurveTo</a></code>(<var data-anolis-xref="">cpx</var>, <var data-anolis-xref="">cpy</var>, <var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</dt>

   <dd>

    <p>Adds the given point to the current subpath, connected to the previous one by a quadratic
    Bézier curve with the given control point.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-bezierCurveTo"><a href="#dom-context-2d-beziercurveto">bezierCurveTo</a></code>(<var data-anolis-xref="">cp1x</var>, <var data-anolis-xref="">cp1y</var>, <var data-anolis-xref="">cp2x</var>, <var data-anolis-xref="">cp2y</var>, <var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</dt>
   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-context-2d-bezierCurveTo"><a href="#dom-context-2d-beziercurveto">bezierCurveTo</a></code>(<var data-anolis-xref="">cp1x</var>, <var data-anolis-xref="">cp1y</var>, <var data-anolis-xref="">cp2x</var>, <var data-anolis-xref="">cp2y</var>, <var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</dt>

   <dd>

    <p>Adds the given point to the current subpath, connected to the previous one by a cubic
    Bézier curve with the given control points.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-arcTo"><a href="#dom-context-2d-arcto">arcTo</a></code>(<var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>, <var data-anolis-xref="">x2</var>, <var data-anolis-xref="">y2</var>, <var data-anolis-xref="">radiusX</var> [, <var data-anolis-xref="">radiusY</var>, <var data-anolis-xref="">rotation</var> ] )</dt>
   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-context-2d-arcTo"><a href="#dom-context-2d-arcto">arcTo</a></code>(<var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>, <var data-anolis-xref="">x2</var>, <var data-anolis-xref="">y2</var>, <var data-anolis-xref="">radiusX</var> [, <var data-anolis-xref="">radiusY</var>, <var data-anolis-xref="">rotation</var> ] )</dt>

   <dd>

    <p>Adds an arc with the given control points and radius to the current subpath, connected to the
    previous point by a straight line.</p>

    <p>If two radii are provided, the first controls the width of the arc's ellipse, and the second
    controls the height. If only one is provided, or if they are the same, the arc is from a circle.
    In the case of an ellipse, the rotation argument controls the clockwise inclination of the
    ellipse relative to the x-axis.</p>

    <p>Throws an <code>IndexSizeError</code> exception if the given radius is negative.</p>

    <figure class="diagrams">
     <!-- if anyone wants to try writing alternative text for these,
     be my guest. I can't work out how to describe them. -->
     <img alt="" height="254" src="images/arcTo1.png" width="357">
     <img alt="" height="310" src="images/arcTo2.png" width="468">
     <img alt="" height="233" src="images/arcTo3.png" width="513">
    </figure>

<!--

c.clearRect(0, 0, 640, 480);
c.save();
try {
  var x0 = 150;
  var y0 = 100;
  var x1 = 375;
  var y1 = 100;
  var x2 = x1;
  var y2 = 250;
  var r = 50;

  var bottom = 210;
  var center = 100;

  var fontSize = 16;
  var margin = 50;
  var dotHalfSize = 5;

  // (also update the label positions at the bottom)


  // ========

  function extendLine(xa,ya,xb,yb) {
    var dx = xb-xa;
    var dy = yb-ya;
    var theta = Math.atan2(dx,dy);
    var extX = margin * Math.sin(theta);
    var extY = margin * Math.cos(theta);
    c.beginPath();
    c.moveTo(xa-extX,ya-extY);
    c.lineTo(xb+extX,yb+extY);
    c.stroke();
  }

  function dot(x,y,s) {
    c.beginPath();
    c.arc(x,y,dotHalfSize,0,Math.PI*2);
    c.fill();
    c.textAlign = 'left';
    c.textBaseline = 'top';
    c.fillText(s,x+dotHalfSize,y);
  }

  c.font = fontSize + 'px Gill Sans';
  c.fillStyle = 'black';
  c.lineWidth = 1;
  c.strokeStyle = 'red';
  extendLine(x0,y0,x1,y1);
  extendLine(x1,y1,x2,y2);

  c.lineWidth = 1;
  c.strokeStyle = 'silver';
  c.beginPath();
  c.moveTo(x0,y0);

  // based on http://lists.freedesktop.org/archives/cairo/2005-August/004801.html
  var angle0, angle1, angle2, angled;
  var xc, yc, dc;
  angle0 = Math.atan2(y0 - y1, x0 - x1);
  angle2 = Math.atan2(y2 - y1, x2 - x1);
  angle1 = (angle0 + angle2) / 2;
  angled = angle2 - angle0;
  if (angled > Math.PI || (angled < 0 && angled > -Math.PI)) {
    angle1 += Math.PI;
    angled = 2 * Math.PI - angled;
    angle0 += Math.PI*2;
    angle2 -= Math.PI*2;
  } else {
    angle0 -= Math.PI*2;
    angle2 += Math.PI*2;
  }
  dc = r / Math.sin (angled / 2);
  yc = Math.sin(angle1);
  xc = Math.cos(angle1);
  xc = x1 + xc * dc;
  yc = y1 + yc * dc;

  c.lineWidth = 1;
  c.strokeStyle = 'blue';
  c.beginPath();
  c.moveTo(xc,yc);
  c.arc(xc,yc,r, Math.PI*3/4, Math.PI*(3/4));
  c.stroke();
  c.beginPath();
  c.strokeStyle = 'silver';
  c.arc(xc,yc,r, Math.PI*3/4,Math.PI*(2+3/4));
  c.stroke();
  c.save();
  try {
    c.translate(xc, yc);
    c.rotate(-Math.PI/4);
    c.textAlign = 'center';
    c.textBaseline = 'top';
    c.fillText("radius", -r/2, 0);
  } finally {
    c.restore();
  }

  c.lineWidth = 15;
  c.lineCap = 'round';
  c.strokeStyle = 'rgba(20,200,40,0.8)';
  c.beginPath();
  c.moveTo(x0,y0);
  c.arcTo(x1,y1,x2,y2,r);
  c.stroke();

  dot(x0,y0, "x\u2080,y\u2080");
  dot(x1,y1, "x\u2081,y\u2081");
  dot(x2,y2, "x\u2082,y\u2082");
  dot(xc,yc, '');

  c.textAlign = 'left';
  c.textBaseline = 'alphabetic';
  var L = 0;

  function print(s) {
    c.fillText(s, center, bottom+L*fontSize*1.3);
    L += 1;
  }
  print('// the thick line corresponds to:');
  print('context.moveTo(x\u2080, y\u2080)');
  print('context.arcTo(x\u2081, y\u2081, x\u2082, y\u2082, radius)');
  print('context.stroke()');

  c.fillStyle = 'green';
  c.fillText("\u25be initial line", 160, 70);
  c.textAlign = 'right';
  c.fillText("arc \u25b8", x1-25, 115);

} finally {
  c.restore();
}

-->

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-arc"><a href="#dom-context-2d-arc">arc</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">radius</var>, <var data-anolis-xref="">startAngle</var>, <var data-anolis-xref="">endAngle</var> [, <var data-anolis-xref="">anticlockwise</var> ] )</dt>
   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-context-2d-arc"><a href="#dom-context-2d-arc">arc</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">radius</var>, <var data-anolis-xref="">startAngle</var>, <var data-anolis-xref="">endAngle</var> [, <var data-anolis-xref="">anticlockwise</var> ] )</dt>

   <dd>

    <p>Adds points to the subpath such that the arc described by the circumference of the circle
    described by the arguments, starting at the given start angle and ending at the given end angle,
    going in the given direction (defaulting to clockwise), is added to the path, connected to the
    previous point by a straight line.</p>

    <p>Throws an <code>IndexSizeError</code> exception if the given radius is negative.</p>

    <figure class="diagrams">
     <!-- if anyone wants to try writing alternative text for this, be my guest. I can't work out how to describe it. -->
     <img alt="" height="255" src="images/arc1.png" width="590">
    </figure>

<!--

c.clearRect(0, 0, 640, 480);
c.save();
try {
  var x0 = 50;
  var y0 = 200;
  var x = 255;
  var y = 150;
  var radius = 100;
  var startAngle = 2.0;
  var endAngle = 5.7;
  var direction = false;

  var bottom = 110;
  var center = 380;

  var fontSize = 16;
  var margin = 50;
  var dotHalfSize = 5;
  var arrowHead = 5;

  // (also update the label positions at the bottom)

  // ========

  function dot(x,y,s) {
    c.beginPath();
    c.arc(x,y,dotHalfSize,0,Math.PI*2);
    c.fill();
    c.textAlign = 'center';
    c.textBaseline = 'top';
    c.fillText(s,x,y+dotHalfSize);
  }

  function arc(x, y, r, sA, eA, d, fr, s) {
    c.lineWidth = 1;
    c.strokeStyle = 'red';
    c.beginPath();
    c.arc(x, y, r, sA, eA, d);
    c.stroke();

    c.save();
    c.translate(x, y);
    c.rotate(eA);
    c.beginPath();
    c.moveTo(r-arrowHead, d?arrowHead:-arrowHead);
    c.lineTo(r, 0);
    c.lineTo(r+arrowHead, d?arrowHead:-arrowHead);
    c.stroke();
    c.strokeStyle = 'silver';
    c.beginPath();
    c.moveTo(0, 0);
    c.lineTo(fr, 0);
    c.stroke();
    c.restore();

    c.fillStyle = 'black';
    if (eA<Math.PI) {
      c.save();
      c.translate(x, y);
      c.rotate(sA+(eA-sA)/2-Math.PI/2);
      c.translate(0, r);
      c.rotate(-(sA+(eA-sA)/2-Math.PI/2));
      c.beginPath();
      c.textAlign = 'center';
      c.textBaseline = 'bottom';
      c.fillText(s + '  ',0,0);
      c.restore();
    } else {
      c.save();
      c.beginPath();
      c.textAlign = 'left';
      c.textBaseline = 'middle';
      c.fillText(' ' + s,x-r,y);
      c.restore();
    }
  }

  function radial(x, y, length, rotation, s) {
    c.lineWidth = 1;
    c.strokeStyle = 'blue';
    c.save();
    c.translate(x, y);
    c.rotate(rotation);
    c.beginPath();
    c.moveTo(0, 0);
    c.lineTo(length, 0);
    c.stroke();
    c.textAlign = 'center';
    c.textBaseline = 'bottom';
    c.fillStyle = 'black';
    c.fillText(s,length/2,0);
    c.restore();
  }

  c.font = fontSize + 'px Gill Sans';

  // construction lines
  c.lineWidth = 1;
  c.strokeStyle = 'silver';
  // circle
  c.beginPath();
  c.arc(x, y, radius, 0, 2*Math.PI);
  c.stroke();
  // angles
  arc(x, y, radius/10+2*radius/3, 0, startAngle, false, radius, '\u03B1');
  arc(x, y, radius/10+radius/3, 0, endAngle, false, radius, '\u03B2');
  // radii
  radial(x, y, radius, 0, 'radius');

  // the line
  c.lineWidth = 15;
  c.lineCap = 'round';
  c.strokeStyle = 'rgba(20,200,40,0.8)';
  c.beginPath();
  c.moveTo(x0,y0);
  c.arc(x,y,radius,startAngle,endAngle,direction);
  c.stroke();

  dot(x0,y0, "x\u2080,y\u2080");
  dot(x,y, "x,y");

  c.textAlign = 'left';
  c.textBaseline = 'alphabetic';
  var L = 0;

  function print(s) {
    c.fillText(s, center, bottom+L*fontSize*1.3);
    L += 1;
  }
  print('// the thick line corresponds to:');
  print('context.moveTo(x\u2080, y\u2080)');
  print('context.arc(x, y, radius, \u03B1, \u03B2)');
  print('context.stroke()');

  c.fillStyle = 'green';

  c.textBaseline = 'top';
  c.fillText("initial line \u25b4", x0+20, y0+fontSize*2);

  c.textAlign = 'right';
  c.textBaseline = 'middle';
  c.fillText("arc \u25b8", x-radius-15, y);

} finally {
  c.restore();
}
-->

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-ellipse"><a href="#dom-context-2d-ellipse">ellipse</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">radiusX</var>, <var data-anolis-xref="">radiusY</var>, <var data-anolis-xref="">rotation</var>, <var data-anolis-xref="">startAngle</var>, <var data-anolis-xref="">endAngle</var> [, <var data-anolis-xref="">anticlockwise</var>] )</dt>
   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-context-2d-ellipse"><a href="#dom-context-2d-ellipse">ellipse</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">radiusX</var>, <var data-anolis-xref="">radiusY</var>, <var data-anolis-xref="">rotation</var>, <var data-anolis-xref="">startAngle</var>, <var data-anolis-xref="">endAngle</var> [, <var data-anolis-xref="">anticlockwise</var>] )</dt>

   <dd>

    <p>Adds points to the subpath such that the arc described by the circumference of the ellipse
    described by the arguments, starting at the given start angle and ending at the given end angle,
    going in the given direction (defaulting to clockwise), is added to the path, connected to the
    previous point by a straight line.</p>

    <p>Throws an <code>IndexSizeError</code> exception if the given radius is negative.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-rect"><a href="#dom-context-2d-rect">rect</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">w</var>, <var data-anolis-xref="">h</var>)</dt>
   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-context-2d-rect"><a href="#dom-context-2d-rect">rect</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">w</var>, <var data-anolis-xref="">h</var>)</dt>

   <dd>

    <p>Adds a new closed subpath to the path, representing the given rectangle.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The following methods allow authors to manipulate the <a data-anolis-xref="concept-path" href="#concept-path">paths</a>
  of objects implementing the <code><a href="#canvaspathmethods">CanvasPathMethods</a></code> interface.</p>

  <p>For <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> objects, the points passed to the methods, and the
  resulting lines added to <a href="#current-default-path">current default path</a> by these methods, must be transformed
  according to the <a data-anolis-xref="dom-context-2d-transformation" href="#transformations">current transformation matrix</a>
  before being added to the path.</p>


  <p>The <dfn data-anolis-xref="dom-context-2d-moveTo" id="dom-context-2d-moveto"><code>moveTo(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</code></dfn> method must create a new subpath with the specified point as its
  first (and only) point.</p>

  <p>When the user agent is to <dfn id="ensure-there-is-a-subpath">ensure there is a subpath</dfn> for a coordinate (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) on a <a data-anolis-xref="concept-path" href="#concept-path">path</a>, the user
  agent must check to see if the <a data-anolis-xref="concept-path" href="#concept-path">path</a> has its <a href="#need-new-subpath">need new
  subpath</a> flag set. If it does, the user agent must create a new subpath with the point (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) as its first (and only) point, as if the <code data-anolis-xref="dom-context-2d-moveTo"><a href="#dom-context-2d-moveto">moveTo()</a></code> method had been called, and must then unset the
  <a data-anolis-xref="concept-path" href="#concept-path">path</a>'s <a href="#need-new-subpath">need new subpath</a> flag.</p>


  <p>The <dfn data-anolis-xref="dom-context-2d-closePath" id="dom-context-2d-closepath"><code>closePath()</code></dfn> method must do nothing
  if the object's path has no subpaths. Otherwise, it must mark the last subpath as closed, create a
  new subpath whose first point is the same as the previous subpath's first point, and finally add
  this new subpath to the path.</p>

  <p class="note">If the last subpath had more than one point in its list of points, then this is
  equivalent to adding a straight line connecting the last point back to the first point, thus
  "closing" the shape, and then repeating the last (possibly implied) <code data-anolis-xref="dom-context-2d-moveTo"><a href="#dom-context-2d-moveto">moveTo()</a></code> call.</p>


  <p>New points and the lines connecting them are added to subpaths using the methods described
  below. In all cases, the methods only modify the last subpath in the object's path.</p>


  <p>The <dfn data-anolis-xref="dom-context-2d-lineTo" id="dom-context-2d-lineto"><code>lineTo(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</code></dfn> method must <a href="#ensure-there-is-a-subpath">ensure there is a subpath</a> for <span data-anolis-xref="">(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</span> if the object's path has no
  subpaths. Otherwise, it must connect the last point in the subpath to the given point (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) using a straight line, and must then add the given point
  (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) to the subpath.</p>


  <p>The <dfn data-anolis-xref="dom-context-2d-quadraticCurveTo" id="dom-context-2d-quadraticcurveto"><code>quadraticCurveTo(<var data-anolis-xref="">cpx</var>, <var data-anolis-xref="">cpy</var>, <var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</code></dfn> method must <a href="#ensure-there-is-a-subpath">ensure there is a subpath</a> for <span data-anolis-xref="">(<var data-anolis-xref="">cpx</var>, <var data-anolis-xref="">cpy</var>)</span>, and then must connect the last
  point in the subpath to the given point (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) using a
  quadratic Bézier curve with control point (<var data-anolis-xref="">cpx</var>, <var data-anolis-xref="">cpy</var>), and must then add the given point (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) to the subpath. <a href="#refsBEZIER">[BEZIER]</a></p>


  <p>The <dfn data-anolis-xref="dom-context-2d-bezierCurveTo" id="dom-context-2d-beziercurveto"><code>bezierCurveTo(<var data-anolis-xref="">cp1x</var>,
  <var data-anolis-xref="">cp1y</var>, <var data-anolis-xref="">cp2x</var>, <var data-anolis-xref="">cp2y</var>, <var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</code></dfn> method must <a href="#ensure-there-is-a-subpath">ensure there is a
  subpath</a> for <span data-anolis-xref="">(<var data-anolis-xref="">cp1x</var>, <var data-anolis-xref="">cp1y</var>)</span>, and
  then must connect the last point in the subpath to the given point (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) using a cubic Bézier curve with control points (<var data-anolis-xref="">cp1x</var>,
  <var data-anolis-xref="">cp1y</var>) and (<var data-anolis-xref="">cp2x</var>, <var data-anolis-xref="">cp2y</var>). Then, it must
  add the point (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) to the subpath. <a href="#refsBEZIER">[BEZIER]</a></p>

  <hr>

  <p>The <dfn data-anolis-xref="dom-context-2d-arcTo" id="dom-context-2d-arcto"><code>arcTo(<var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>, <var data-anolis-xref="">x2</var>, <var data-anolis-xref="">y2</var>, <var data-anolis-xref="">radiusX</var>,
  <var data-anolis-xref="">radiusY</var>, <var data-anolis-xref="">rotation</var>)</code></dfn> method must first
  <a href="#ensure-there-is-a-subpath">ensure there is a subpath</a> for <span data-anolis-xref="">(<var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>)</span>. Then, the behavior depends on the arguments and the last point in the
  subpath, as described below.</p>

  <p>Negative values for <var data-anolis-xref="">radiusX</var> or <var data-anolis-xref="">radiusY</var> must cause the
  implementation to throw an <code>IndexSizeError</code> exception. If <var data-anolis-xref="">radiusY</var>
  is omitted, user agents must act as if it had the same value as <var data-anolis-xref="">radiusX</var>.</p>

  <p>Let the point (<var data-anolis-xref="">x0</var>, <var data-anolis-xref="">y0</var>) be the last point in the
  subpath, transformed by the inverse of the <a data-anolis-xref="dom-context-2d-transformation" href="#transformations">current
  transformation matrix</a> (so that it is in the same coordinate system as the points passed to
  the method).</p>

  <p>If the point (<var data-anolis-xref="">x0</var>, <var data-anolis-xref="">y0</var>) is equal to the point (<var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>), or if the point (<var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>) is equal to the point (<var data-anolis-xref="">x2</var>, <var data-anolis-xref="">y2</var>), or if
  both <var data-anolis-xref="">radiusX</var> and <var data-anolis-xref="">radiusY</var> are zero, then the method must
  add the point (<var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>) to the subpath, and connect that
  point to the previous point (<var data-anolis-xref="">x0</var>, <var data-anolis-xref="">y0</var>) by a straight
  line.</p>

  <p>Otherwise, if the points (<var data-anolis-xref="">x0</var>, <var data-anolis-xref="">y0</var>), (<var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>), and (<var data-anolis-xref="">x2</var>, <var data-anolis-xref="">y2</var>)
  all lie on a single straight line, then the method must add the point (<var data-anolis-xref="">x1</var>,
  <var data-anolis-xref="">y1</var>) to the subpath, and connect that point to the previous point (<var data-anolis-xref="">x0</var>, <var data-anolis-xref="">y0</var>) by a straight line.</p>

  <p>Otherwise, let <var data-anolis-xref="">The Arc</var> be the shortest arc given by circumference of the
  ellipse that has radius <var data-anolis-xref="">radiusX</var> on the major axis and radius <var data-anolis-xref="">radiusY</var> on the minor axis, and whose semi-major axis is rotated <var data-anolis-xref="">rotation</var> radians clockwise from the positive x-axis, and that has one point tangent
  to the half-infinite line that crosses the point (<var data-anolis-xref="">x0</var>, <var data-anolis-xref="">y0</var>)
  and ends at the point (<var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>), and that has a different
  point tangent to the half-infinite line that ends at the point (<var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>) and crosses the point (<var data-anolis-xref="">x2</var>, <var data-anolis-xref="">y2</var>). The
  points at which this ellipse touches these two lines are called the start and end tangent points
  respectively. The method must connect the point (<var data-anolis-xref="">x0</var>, <var data-anolis-xref="">y0</var>)
  to the start tangent point by a straight line, adding the start tangent point to the subpath, and
  then must connect the start tangent point to the end tangent point by <var data-anolis-xref="">The Arc</var>,
  adding the end tangent point to the subpath.</p>

  <hr>

  <p>The <dfn data-anolis-xref="dom-context-2d-arc" id="dom-context-2d-arc"><code>arc(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>,
  <var data-anolis-xref="">radius</var>, <var data-anolis-xref="">startAngle</var>, <var data-anolis-xref="">endAngle</var>, <var data-anolis-xref="">anticlockwise</var>)</code></dfn> and <dfn data-anolis-xref="dom-context-2d-ellipse" id="dom-context-2d-ellipse"><code>ellipse(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">radiusX</var>, <var data-anolis-xref="">radiusY</var>, <var data-anolis-xref="">rotation</var>, <var data-anolis-xref="">startAngle</var>, <var data-anolis-xref="">endAngle</var>, <var data-anolis-xref="">anticlockwise</var>)</code></dfn> methods draw arcs.</p>

  <p>The <code data-anolis-xref="dom-context-2d-arc"><a href="#dom-context-2d-arc">arc()</a></code> method is equivalent to the <code data-anolis-xref="dom-context-2d-ellipse"><a href="#dom-context-2d-ellipse">ellipse()</a></code> method in the case where the two radii are equal.
  When the <code data-anolis-xref="dom-context-2d-arc"><a href="#dom-context-2d-arc">arc()</a></code> method is invoked, it must act as if the
  <code data-anolis-xref="dom-context-2d-ellipse"><a href="#dom-context-2d-ellipse">ellipse()</a></code> method had been invoked with the <var data-anolis-xref="">radiusX</var> and <var data-anolis-xref="">radiusY</var> arguments set to the value of the <var data-anolis-xref="">radius</var> argument, the <var data-anolis-xref="">rotation</var> argument set to zero, and the
  other arguments set to the same values as their identically named arguments on the <code data-anolis-xref="dom-context-2d-arc"><a href="#dom-context-2d-arc">arc()</a></code> method.</p>

  <p>When the <code data-anolis-xref="dom-context-2d-ellipse"><a href="#dom-context-2d-ellipse">ellipse()</a></code> method is invoked, it must
  proceed as follows. First, if the object's path has any subpaths, then the method must add a
  straight line from the last point in the subpath to the start point of the arc. Then, it must add
  the start and end points of the arc to the subpath, and connect them with an arc. The arc and its
  start and end points are defined as follows:</p>

  <p>Consider an ellipse that has its origin at (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>), that
  has a major-axis radius <var data-anolis-xref="">radiusX</var> and a minor-axis radius <var data-anolis-xref="">radiusY</var>, and that is rotated about its origin such that its semi-major axis is
  inclined <var data-anolis-xref="">rotation</var> radians clockwise from the x-axis.</p>

  <p>If the <var data-anolis-xref="">anticlockwise</var> argument is false and <span data-anolis-xref=""><var data-anolis-xref="">endAngle</var>-<var data-anolis-xref="">startAngle</var></span> is equal to or greater than <span data-anolis-xref="">2π</span>, or, if the <var data-anolis-xref="">anticlockwise</var> argument is <em>true</em>
  and <span data-anolis-xref=""><var data-anolis-xref="">startAngle</var>-<var data-anolis-xref="">endAngle</var></span> is equal
  to or greater than <span data-anolis-xref="">2π</span>, then the arc is the whole circumference of this
  ellipse, and the point at <var data-anolis-xref="">startAngle</var> along this circle's circumference,
  measured in radians clockwise from the ellipse's semi-major axis, acts as both the start point and
  the end point.</p>

  <p>Otherwise, the points at <var data-anolis-xref="">startAngle</var> and <var data-anolis-xref="">endAngle</var>
  along this circle's circumference, measured in radians clockwise from the ellipse's semi-major
  axis, are the start and end points respectively, and the arc is the path along the circumference
  of this ellipse from the start point to the end point, going anti-clockwise if the <var data-anolis-xref="">anticlockwise</var> argument is true, and clockwise otherwise. Since the points are on
  the ellipse, as opposed to being simply angles from zero, the arc can never cover an angle greater
  than <span data-anolis-xref="">2π</span> radians.</p>

  <p class="note">Even if the arc covers the entire circumference of the ellipse and there are no
  other points in the subpath, the path is not closed unless the <code data-anolis-xref="dom-context-2d-closePath"><a href="#dom-context-2d-closepath">closePath()</a></code> method is appropriately invoked.</p>

  <p>Negative values for <var data-anolis-xref="">radiusX</var> or <var data-anolis-xref="">radiusY</var> must cause the
  implementation to throw an <code>IndexSizeError</code> exception.</p>

  <hr>

  <p>The <dfn data-anolis-xref="dom-context-2d-rect" id="dom-context-2d-rect"><code>rect(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">w</var>, <var data-anolis-xref="">h</var>)</code></dfn> method must create
  a new subpath containing just the four points (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>),
  (<var data-anolis-xref="">x</var>+<var data-anolis-xref="">w</var>, <var data-anolis-xref="">y</var>), (<var data-anolis-xref="">x</var>+<var data-anolis-xref="">w</var>, <var data-anolis-xref="">y</var>+<var data-anolis-xref="">h</var>), (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>+<var data-anolis-xref="">h</var>), in that order, with those four
  points connected by straight lines, and must then mark the subpath as closed. It must then create
  a new subpath with the point (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) as the only point in
  the subpath.</p>

  <!-- v6 feature request:
        * points as a primitive shape
          http://home.comcast.net/~urbanjost/canvas/vogle4.html
  -->

  </div>



  <h6 id="path2d-objects"><span class="secno">1.1.7 </span><code><a href="#path2d">Path2D</a></code> objects</h6>

  <p><code><a href="#path2d">Path2D</a></code> objects can be used to declare paths that are then later used on
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> objects. In addition to many of the APIs described in
  earlier sections, <code><a href="#path2d">Path2D</a></code> objects have methods to combine paths, and to add text to
  paths.</p>

  <dl class="domintro">

   <dt><var data-anolis-xref="">path</var> = new <code data-anolis-xref="dom-Path2D"><a href="#dom-path2d">Path2D</a></code>()</dt>

   <dd>

    <p>Creates a new empty <code><a href="#path2d">Path2D</a></code> object.</p>

   </dd>

   <dt><var data-anolis-xref="">path</var> = new <code data-anolis-xref="dom-Path2D-copy"><a href="#dom-path2d-copy">Path2D</a></code>(<var data-anolis-xref="">path</var>)</dt>

   <dd>

    <p>Creates a new <code><a href="#path2d">Path2D</a></code> object that is a copy of the argument.</p>

   </dd>

   <dt><var data-anolis-xref="">path</var> = new <code data-anolis-xref="dom-Path2D-merge"><a href="#dom-path2d-merge">Path2D</a></code>(<var data-anolis-xref="">paths</var> [, <var data-anolis-xref="">fillRule</var> ] )</dt>

   <dd>

    <p>Creates a new <code><a href="#path2d">Path2D</a></code> object that describes a path that outlines the given <var data-anolis-xref="">paths</var>, using the given fill rule.</p>

   </dd>

   <dt><var data-anolis-xref="">path</var> = new <code data-anolis-xref="dom-Path2D-withdata"><a href="#dom-path2d-withdata">Path2D</a></code>(<var data-anolis-xref="">d</var>)</dt>

   <dd>

    <p>Creates a new path with the path described by the argument, interpreted as SVG path data. <a href="#refsSVG">[SVG]</a></p>

   </dd>

   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-Path2D-addPath"><a href="#dom-path2d-addpath">addPath</a></code>(<var data-anolis-xref="">path</var> [, <var data-anolis-xref="">transform</var> ] )</dt>
   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-Path2D-addPathByStrokingPath"><a href="#dom-path2d-addpathbystrokingpath">addPathByStrokingPath</a></code>(<var data-anolis-xref="">path</var>, <var data-anolis-xref="">styles</var> [, <var data-anolis-xref="">transform</var> ] )</dt>

   <dd>

    <p>Adds to the path the path given by the argument.</p>

    <p>In the case of the stroking variants, the line styles are taken from the <var data-anolis-xref="">styles</var> argument, which can be either a <code><a href="#drawingstyle">DrawingStyle</a></code> object or a
    <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object.</p>

   </dd>

   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-Path2D-addText"><a href="#dom-path2d-addtext">addText</a></code>(<var data-anolis-xref="">text</var>, <var data-anolis-xref="">styles</var>, <var data-anolis-xref="">transform</var>, <var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var> [, <var data-anolis-xref="">maxWidth</var> ] )</dt>
   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-Path2D-addText"><a href="#dom-path2d-addtext">addText</a></code>(<var data-anolis-xref="">text</var>, <var data-anolis-xref="">styles</var>, <var data-anolis-xref="">transform</var>, <var data-anolis-xref="">path</var> [, <var data-anolis-xref="">maxWidth</var> ] )</dt>
   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-Path2D-addPathByStrokingText"><a href="#dom-path2d-addpathbystrokingtext">addPathByStrokingText</a></code>(<var data-anolis-xref="">text</var>, <var data-anolis-xref="">styles</var>, <var data-anolis-xref="">transform</var>, <var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var> [, <var data-anolis-xref="">maxWidth</var> ] )</dt>
   <dt><var data-anolis-xref="">path</var> . <code data-anolis-xref="dom-Path2D-addPathByStrokingText"><a href="#dom-path2d-addpathbystrokingtext">addPathByStrokingText</a></code>(<var data-anolis-xref="">text</var>, <var data-anolis-xref="">styles</var>, <var data-anolis-xref="">transform</var>, <var data-anolis-xref="">path</var> [, <var data-anolis-xref="">maxWidth</var> ] )</dt>

   <dd>

    <p>Adds to the path a series of subpaths corresponding to the given text. If the arguments give
    a coordinate, the text is drawn horizontally at the given coordinates. If the arguments give a
    path, the text is drawn along the path. If a maximum width is provided, the text will be scaled
    to fit that width if necessary.</p>

    <p>The font, and in the case of the stroking variants, the line styles, are taken from the <var data-anolis-xref="">styles</var> argument, which can be either a <code><a href="#drawingstyle">DrawingStyle</a></code> object or a
    <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-Path2D" id="dom-path2d"><code>Path()</code></dfn> constructor, when invoked, must return a
  newly created <code><a href="#path2d">Path2D</a></code> object.</p>

  <hr>

  <p>The <dfn data-anolis-xref="dom-Path2D-copy" id="dom-path2d-copy"><code>Path(<var data-anolis-xref="">path</var>)</code></dfn>
  constructor, when invoked, must return a newly created <code><a href="#path2d">Path2D</a></code> object, to which the
  subpaths of the argument are added. (In other words, it returns a copy of the argument.)</p>

  <hr>

  <p>The <dfn data-anolis-xref="dom-Path2D-merge" id="dom-path2d-merge"><code>Path(<var data-anolis-xref="">paths</var>, <var data-anolis-xref="">fillRule</var>)</code></dfn> constructor, when invoked, must run the following
  steps:</p>

  <ol>

   <li>

    <p>Run the appropriate step from the following list, based on the constructor's sectond
    argument:</p>

    <dl class="switch">

     <dt>If it is "nonzero"</dt>

     <dd>

      <p>Let <var data-anolis-xref="">merged path</var> be a <a data-anolis-xref="concept-path" href="#concept-path">path</a> that
      consists of a set of non-overlapping subpaths that exactly outline the points from which, in
      any of the <a data-anolis-xref="concept-path" href="#concept-path">paths</a> provided in the constructor's first
      argument, the number of times a half-infinite straight line drawn from that point crosses a
      subpath going in one direction is not equal to the number of times it crosses a subpath going
      in the other direction.</p>

     </dd>

     <dt>If it is "evenodd"</dt>

     <dd>

      <p>Let <var data-anolis-xref="">merged path</var> be a <a data-anolis-xref="concept-path" href="#concept-path">path</a> that
      consists of a set of non-overlapping subpaths that exactly outline the points from which, in
      any of the <a data-anolis-xref="concept-path" href="#concept-path">paths</a> provided in the constructor's first
      argument, the number of times a half-infinite straight line drawn from that point crosses that
      path is odd.</p>

     </dd>

    </dl>

    <p>The subpaths in <var data-anolis-xref="">merged path</var> must be oriented such that for any point,
    the number of times a half-infinite straight line drawn from that point crosses a subpath is
    even if and only if the number of times a half-infinite straight line drawn from that same point
    crosses a subpath going in one direction is equal to the number of times it crosses a subpath
    going in the other direction.</p>

   </li>

   <li><p>Add all the subpaths in <var data-anolis-xref="">merged path</var> to the <code><a href="#path2d">Path2D</a></code>
   object.</p></li>

   <li><p>Set the <code><a href="#path2d">Path2D</a></code> object's <a href="#need-new-subpath">need new subpath</a> flag.</p></li>

  </ol>

  <hr>

  <p>The <dfn data-anolis-xref="dom-Path2D-withdata" id="dom-path2d-withdata"><code>Path(<var data-anolis-xref="">d</var>)</code></dfn>
  constructor must run the following steps:</p>

  <ol>

   <li>

    <p>Parse and interpret the <var data-anolis-xref="">d</var> argument according to the SVG specification's
    rules for path data, thus obtaining an SVG path. <a href="#refsSVG">[SVG]</a></p>

    <p class="note">The resulting path could be empty. SVG defines error handling rules for parsing
    and applying path data.</p>

   </li>

   <li><p>Let (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) be the last point in the SVG
   path.</p></li>

   <li><p>Create a new <code><a href="#path2d">Path2D</a></code> object and add all the subpaths in the SVG path, if any,
   to that <code><a href="#path2d">Path2D</a></code> object. </p>

   </li><li><p>Create a new subpath in the <code><a href="#path2d">Path2D</a></code> object with (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) as the only point in the subpath.</p></li>

   <li><p>Return the <code><a href="#path2d">Path2D</a></code> object as the constructed object.</p></li>

  </ol>

  <hr>

  <p>The <dfn data-anolis-xref="dom-Path2D-addPath" id="dom-path2d-addpath"><code>addPath(<var data-anolis-xref="">b</var>, <var data-anolis-xref="">transform</var>)</code></dfn> method, when invoked on a <code><a href="#path2d">Path2D</a></code> object <var data-anolis-xref="">a</var>, must run the following steps:</p>

  <ol>

   <li><p>If the <code><a href="#path2d">Path2D</a></code> object <var data-anolis-xref="">b</var> has no subpaths, abort these
   steps.</p></li>

   <li><p>Create a copy of all the subpaths in <var data-anolis-xref="">b</var>. Let this copy be known as <var data-anolis-xref="">c</var>.</p></li>

   <li><p>Transform all the coordinates and lines in <var data-anolis-xref="">c</var> by the transform matrix
   <var data-anolis-xref="">transform</var>, if it is not null.</p></li>

   <li><p>Let (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) be the last point in the last subpath
   of <var data-anolis-xref="">c</var>.</p></li>

   <li><p>Add all the subpaths in <var data-anolis-xref="">c</var> to <var data-anolis-xref="">a</var>.</p></li>

   <li><p>Create a new subpath in <var data-anolis-xref="">a</var> with (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) as the only point in the subpath.</p></li>

  </ol>

  <hr>

  <p>The <dfn data-anolis-xref="dom-Path2D-addPathByStrokingPath" id="dom-path2d-addpathbystrokingpath"><code>addPathByStrokingPath(<var data-anolis-xref="">b</var>, <var data-anolis-xref="">styles</var>, <var data-anolis-xref="">transform</var>)</code></dfn>
  method, when invoked on a <code><a href="#path2d">Path2D</a></code> object <var data-anolis-xref="">a</var>, must run the
  following steps:</p>

  <ol>

   <li><p>If the <code><a href="#path2d">Path2D</a></code> object <var data-anolis-xref="">b</var> has no subpaths, abort these
   steps.</p></li>

   <li><p>Create a copy of all the subpaths in <var data-anolis-xref="">b</var>. Let this copy be known as <var data-anolis-xref="">c</var>.</p></li>

   <li><p>Transform all the coordinates and lines in <var data-anolis-xref="">c</var> by transformation matrix
   <var data-anolis-xref="">transform</var>, if it is not null.</p></li>

   <li><p>Let a new list of subpaths <var data-anolis-xref="">d</var> be the result of <a data-anolis-xref="trace a
   path" href="#trace-a-path">tracing</a> <var data-anolis-xref="">c</var>, using the <var data-anolis-xref="">styles</var> argument for the
   line styles.</p>

   </li><li><p>Let (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) be the last point in the last subpath
   of <var data-anolis-xref="">d</var>.</p></li>

   <li><p>Add all the subpaths in <var data-anolis-xref="">d</var> to <var data-anolis-xref="">a</var>.</p></li>

   <li><p>Create a new subpath in <var data-anolis-xref="">a</var> with (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) as the only point in the subpath.</p></li>

  </ol>

  <hr>

  <p>The <dfn data-anolis-xref="dom-Path2D-addText" id="dom-path2d-addtext"><code>addText()</code></dfn> and <dfn data-anolis-xref="dom-Path2D-addPathByStrokingText" id="dom-path2d-addpathbystrokingtext"><code>addPathByStrokingText()</code></dfn> methods each
  come in two variants: one rendering text at a given coordinate, and one rendering text along a
  given path. In both cases, the methods take a <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> object argument for
  the text and (if appropriate) line styles to use, an <code>SVGMatrix</code> object <var data-anolis-xref="">transform</var> (which can be null), and a maximum width can optionally be provided.</p>

  <p>When one of the <code data-anolis-xref="dom-Path2D-addText"><a href="#dom-path2d-addtext">addText()</a></code> and <code data-anolis-xref="dom-Path2D-addPathByStrokingText"><a href="#dom-path2d-addpathbystrokingtext">addPathByStrokingText()</a></code> variants that take as
  argument an (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) coordinate is invoked, the method
  must run the following algorithm:</p>

  <ol>

   <li><p>Run the <a href="#text-preparation-algorithm">text preparation algorithm</a>, passing it <var data-anolis-xref="">text</var>, the
   <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> object argument, and, if the <var data-anolis-xref="">maxWidth</var>
   argument was provided, that argument. Let <var data-anolis-xref="">glyphs</var> be the result.</p>

   </li><li><p>Move all the shapes in <var data-anolis-xref="">glyphs</var> to the right by <var data-anolis-xref="">x</var>
   CSS pixels and down by <var data-anolis-xref="">y</var> CSS pixels.</p></li>

   <li><p>Let <var data-anolis-xref="">glyph paths</var> be a list of <a data-anolis-xref="concept-path" href="#concept-path">paths</a>
   describing the shapes given in <var data-anolis-xref="">glyphs</var>, with each CSS pixel in the coordinate
   space of <var data-anolis-xref="">glyphs</var> mapped to one coordinate space unit in <var data-anolis-xref="">glyph
   paths</var>. Subpaths in <var data-anolis-xref="">glyph paths</var> must wind clockwise, regardless of how
   the user agent's font subsystem renders fonts and regardless of how the fonts themselves are
   defined.</p>

   </li><li><p>Transform all the coordinates and lines in <var data-anolis-xref="">glyph paths</var> by the
   transformation matrix <var data-anolis-xref="">transform</var>, if it is not null.</p></li>

   <li><p>If the method is <code data-anolis-xref="dom-Path2D-addPathByStrokingText"><a href="#dom-path2d-addpathbystrokingtext">addPathByStrokingText()</a></code>, replace <var data-anolis-xref="">glyph paths</var> by the result of <a data-anolis-xref="trace a path" href="#trace-a-path">tracing</a> each
   <a data-anolis-xref="concept-path" href="#concept-path">path</a> in <var data-anolis-xref="">glyph paths</var>, using the
   <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> object argument for the line styles.</p>

   </li><li id="mergeGlyphs">

    <p>Let <var data-anolis-xref="">merged path</var> be a <a data-anolis-xref="concept-path" href="#concept-path">path</a> that
    consists of a set of non-overlapping subpaths that exactly outline the points from which, in any
    of the <a data-anolis-xref="concept-path" href="#concept-path">paths</a> in <var data-anolis-xref="">glyph paths</var>, the number
    of times a half-infinite straight line drawn from that point crosses that path is odd.</p>

    <p>The subpaths in <var data-anolis-xref="">merged path</var> must be oriented such that for any point,
    the number of times a half-infinite straight line drawn from that point crosses a subpath is
    even if and only if the number of times a half-infinite straight line drawn from that same point
    crosses a subpath going in one direction is equal to the number of times it crosses a subpath
    going in the other direction.</p>

    <div class="example">

     <p>For example, suppose <var data-anolis-xref="">text</var> consists of two overlapping glyphs "Q" and
     "p" (maybe the "Q" has a flourish that crosses into the tail of the "p"). The <var data-anolis-xref="">glyph paths</var> therefore consist of two paths, each with two subpaths: one for the
     outside of the letter shape, and one for the inside of the letter shape. There are points that,
     according to the even-odd fill rule, are filled in both shapes simultaneously: where they
     overlap. As such, the subpaths from the two glyphs actually cross each other.</p>

     <p><img alt="" src="images/Qp-overlap.png"></p> <!-- this image repeats the previous paragraph,
     so alternative text would be redundant -->
     <!--
          c.clearRect(0, 0, 640, 480);
          c.save();
          try {
            c.font = '100px Zapfino';
            c.fillStyle = 'blue';
            c.fillText('Q', 200, 200);
            c.fillStyle = 'fuchsia';
            c.fillText('p', 337, 200);
          } finally {
            c.restore();
          }
     -->

     <p>The resulting <var data-anolis-xref="">merged path</var> in such a situation would have just one path
     for these two letters, with a total of just three subpaths (one big outer outline, one for the
     inside of the "Q", and one for inside of the "p"). This single path would have no subpaths that
     cross each other.</p>

     <p><img alt="" src="images/Qp-overlap-outline.png"></p> <!-- this image again repeats the
     previous paragraph, so alternative text would be redundant -->
     <!-- this is just an edge-detected version of the previous image -->

    </div>

   </li>

   <li><p>Add all the subpaths in <var data-anolis-xref="">merged path</var> to the <code><a href="#path2d">Path2D</a></code>
   object.</p></li>

   <li><p>Set the <code><a href="#path2d">Path2D</a></code> object's <a href="#need-new-subpath">need new subpath</a> flag.</p></li>

  </ol>

  <p>When one of the <code data-anolis-xref="dom-Path2D-addText"><a href="#dom-path2d-addtext">addText()</a></code> and <code data-anolis-xref="dom-Path2D-addPathByStrokingText"><a href="#dom-path2d-addpathbystrokingtext">addPathByStrokingText()</a></code> variants that take as
  argument a <code><a href="#path2d">Path2D</a></code> object is invoked, the method must run the following algorithm:</p>

  <ol>

   <li><p>Let <var data-anolis-xref="">target</var> be the <code><a href="#path2d">Path2D</a></code> object on which the method was
   invoked.</p></li>

   <li><p>Let <var data-anolis-xref="">path</var> be the <code><a href="#path2d">Path2D</a></code> object that was provided in the
   method's arguments.</p></li>

   <li><p>Run the <a href="#text-preparation-algorithm">text preparation algorithm</a>, passing it <var data-anolis-xref="">text</var>, the
   <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> object argument, and, if the <var data-anolis-xref="">maxWidth</var>
   argument was provided, that argument. Let <var data-anolis-xref="">glyphs</var> be the resulting array, and
   <var data-anolis-xref="">physical alignment</var> be the resulting alignment value.</p>

   </li><li><p>Let <var data-anolis-xref="">width</var> be the aggregate length of all the subpaths in <var data-anolis-xref="">path</var>, including the distances from the last point of each closed subpath to the
   first point of that subpath.</p></li>

   <li><p>Define <var data-anolis-xref="">L</var> to be a linear coordinate line for of all the subpaths in
   <var data-anolis-xref="">path</var>, with additional lines drawn between the last point and the first point
   of each closed subpath, such that the first point of the first subpath is defined as point 0, and
   the last point of the last subpath, if the last subpath is not closed, or the second occurrence
   first point of that subpath, if it is closed, is defined as point <var data-anolis-xref="">width</var>.</p></li>

   <li>

    <p>Let <var data-anolis-xref="">offset</var> be determined according to the appropriate step below:</p>

    <dl class="switch">

     <dt>If <var data-anolis-xref="">physical alignment</var> is <i>left</i></dt> <dd>Let <var data-anolis-xref="">offset</var> be zero.</dd>

     <dt>If <var data-anolis-xref="">physical alignment</var> is <i>right</i></dt> <dd>Let <var data-anolis-xref="">offset</var> be <var data-anolis-xref="">width</var>.</dd>

     <dt>If <var data-anolis-xref="">physical alignment</var> is <i data-anolis-xref="">center</i></dt> <dd>Let <var data-anolis-xref="">offset</var> be half of <var data-anolis-xref="">width</var>.</dd>

    </dl>

   </li>

   <li><p>Move all the shapes in <var data-anolis-xref="">glyphs</var> to the right by <var data-anolis-xref="">offset</var> CSS pixels.</p></li>

   <li><p>Let <var data-anolis-xref="">transformed path list</var> be an empty list of paths.</p></li>

   <li>

    <p>For each glyph <var data-anolis-xref="">glyph</var> in the <var data-anolis-xref="">glyphs</var> array, run these
    substeps:</p>

    <ol>

     <li><p>Let <var data-anolis-xref="">dx</var> be the <var data-anolis-xref="">x</var>-coordinate of the horizontal
     center of the bounding box of the shape described by <var data-anolis-xref="">glyph</var>, in CSS
     pixels.</p></li>

     <li><p>If <var data-anolis-xref="">dx</var> is negative or greater than <var data-anolis-xref="">width</var>, skip
     the remainder of these substeps for this glyph.</p></li>

     <li><p>Recast <var data-anolis-xref="">dx</var> to coordinate spaces units in <var data-anolis-xref="">path</var>.
     (This just changes the dimensionality of <var data-anolis-xref="">dx</var>, not its numeric value.)</p>
     <!-- hide this step if people get confused by the pedancy -->

     </li><li><p>Find the point <var data-anolis-xref="">p</var> on <var data-anolis-xref="">path</var> (or implied closing
     lines in <var data-anolis-xref="">path</var>) that corresponds to the position <var data-anolis-xref="">dx</var> on
     the coordinate line <var data-anolis-xref="">L</var>.</p>

     </li><li><p>Let <var data-anolis-xref="">θ</var> be the clockwise angle from the positive x-axis to the
     side of the line that is tangential to <var data-anolis-xref="">path</var> at the point <var data-anolis-xref="">p</var> that is going in the same direction as the line at point <var data-anolis-xref="">p</var>.</p></li>

     <li><p>Rotate the shape described by <var data-anolis-xref="">glyph</var> clockwise by <var data-anolis-xref="">θ</var> about the point that is at the <var data-anolis-xref="">dx</var> coordinate
     horizontally and the zero coordinate vertically.</p></li>

     <li><p>Let (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) be the coordinate of the point <var data-anolis-xref="">p</var>.</p></li>

     <li><p>Move the shape described by <var data-anolis-xref="">glyph</var> to the right by <var data-anolis-xref="">x</var> and down by <var data-anolis-xref="">y</var>.</p></li>

     <li><p>Let <var data-anolis-xref="">glyph subpaths</var> be a list of subpaths describing the shape given
     in <var data-anolis-xref="">glyph</var>, with each CSS pixel in the coordinate space of <var data-anolis-xref="">glyph</var> mapped to one coordinate space unit in <var data-anolis-xref="">glyph subpaths</var>.
     Subpaths in <var data-anolis-xref="">glyph subpaths</var> must wind clockwise, regardless of how the user
     agent's font subsystem renders fonts and regardless of how the fonts themselves are
     defined.</p>

     </li><li><p>Transform all the coordinates and lines in <var data-anolis-xref="">glyph subpaths</var> by the
     transformation matrix <var data-anolis-xref="">transform</var>, if it is not null.</p></li>

     <li><p>If the method is <code data-anolis-xref="dom-Path2D-addPathByStrokingText"><a href="#dom-path2d-addpathbystrokingtext">addPathByStrokingText()</a></code>, replace <var data-anolis-xref="">glyph subpaths</var> by the result of <a data-anolis-xref="trace a path" href="#trace-a-path">tracing</a> <var data-anolis-xref="">glyph subpaths</var>, using the <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> object argument for
     the line styles.</p>

     </li><li><p>Add all the subpaths in <var data-anolis-xref="">glyph subpaths</var> to <var data-anolis-xref="">transformed path list</var>.</p></li>

    </ol>

   </li>

   <li>

    <p>Let <var data-anolis-xref="">merged path</var> be a <a data-anolis-xref="concept-path" href="#concept-path">path</a> that
    consists of a set of non-overlapping subpaths that exactly outline the points from which, in any
    of the <a data-anolis-xref="concept-path" href="#concept-path">paths</a> in <var data-anolis-xref="">transformed path list</var>,
    the number of times a half-infinite straight line drawn from that point crosses that path is
    odd.</p>

    <p>The subpaths in <var data-anolis-xref="">merged path</var> must be oriented such that for any point,
    the number of times a half-infinite straight line drawn from that point crosses a subpath is
    even if and only if the number of times a half-infinite straight line drawn from that same point
    crosses a subpath going in one direction is equal to the number of times it crosses a subpath
    going in the other direction.</p>

    <p class="note">See <a href="#mergeGlyphs">the equivalent step in the earlier algorithm</a> for
    an example of this step. It's even more likely that there will be overlap with this method,
    since neighboring glyphs are likely to be rotated relative to each other.</p>

   </li>

   <li><p>Add all the subpaths in <var data-anolis-xref="">merged path</var> to <var data-anolis-xref="">target</var>.</p></li>

   <li><p>Set the <code><a href="#path2d">Path2D</a></code> object's <a href="#need-new-subpath">need new subpath</a> flag.</p></li>

  </ol>

  </div>


  <h6 id="transformations"><span class="secno">1.1.8 </span><dfn data-anolis-xref="dom-context-2d-transformation" id="dom-context-2d-transformation">Transformations</dfn></h6>

  <p>Each <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object has a <i>current transformation matrix</i>,
  as well as methods (described in this section) to manipulate it. When a
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object is created, its transformation matrix must be
  initialised to the identity transform.</p>

  <p>The transformation matrix is applied to coordinates when creating the <a href="#current-default-path">current default
  path</a>, and when painting text, shapes, and <code><a href="#path2d">Path2D</a></code> objects, on
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> objects.</p> <!-- conformance criteria for actual drawing
  are described in the various sections below -->

  <p class="note">Most of the API uses <code>SVGMatrix</code> objects rather than this API. This API
  remains mostly for historical reasons.</p>

  <div class="impl">

  <p>The transformations must be performed in reverse order.</p>

  <p class="note">For instance, if a scale transformation that doubles the width is applied to the
  canvas, followed by a rotation transformation that rotates drawing operations by a quarter turn,
  and a rectangle twice as wide as it is tall is then drawn on the canvas, the actual result will be
  a square.</p> <!-- q.v. http://goo.gl/5RLrN -->

  </div>

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-currentTransform"><a href="#dom-context-2d-currenttransform">currentTransform</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the transformation matrix, as an <code>SVGMatrix</code> object.</p>

    <p>Can be set, to change the transformation matrix.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-scale"><a href="#dom-context-2d-scale">scale</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</dt>

   <dd>

    <p>Changes the transformation matrix to apply a scaling transformation with the given characteristics.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-rotate"><a href="#dom-context-2d-rotate">rotate</a></code>(<var data-anolis-xref="">angle</var>)</dt>

   <dd>

    <p>Changes the transformation matrix to apply a rotation transformation with the given characteristics. The angle is in radians.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-translate"><a href="#dom-context-2d-translate">translate</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</dt>

   <dd>

    <p>Changes the transformation matrix to apply a translation transformation with the given characteristics.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-transform"><a href="#dom-context-2d-transform">transform</a></code>(<var data-anolis-xref="">a</var>, <var data-anolis-xref="">b</var>, <var data-anolis-xref="">c</var>, <var data-anolis-xref="">d</var>, <var data-anolis-xref="">e</var>, <var data-anolis-xref="">f</var>)</dt>

   <dd>

    <p>Changes the transformation matrix to apply the matrix given by the arguments as described below.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-setTransform"><a href="#dom-context-2d-settransform">setTransform</a></code>(<var data-anolis-xref="">a</var>, <var data-anolis-xref="">b</var>, <var data-anolis-xref="">c</var>, <var data-anolis-xref="">d</var>, <var data-anolis-xref="">e</var>, <var data-anolis-xref="">f</var>)</dt>

   <dd>

    <p>Changes the transformation matrix <em>to</em> the matrix given by the arguments as described below.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-resetTransform"><a href="#dom-context-2d-resettransform">resetTransform</a></code>()</dt>

   <dd>

    <p>Changes the transformation matrix to the identity transform.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-context-2d-currentTransform" id="dom-context-2d-currenttransform"><code>currentTransform</code></dfn>, on
  getting, must return the last object that it was set to. On setting, its value must be changed to
  the new value, and the transformation matrix must be updated to match the matrix described by the
  new value. When the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object is created, the <code data-anolis-xref="dom-context-2d-currentTransform"><a href="#dom-context-2d-currenttransform">currentTransform</a></code> attribute must be set a newly
  created <code>SVGMatrix</code> object. When the transformation matrix is mutated by the methods
  described in this section, the last <code>SVGMatrix</code> object to which the attribute has been
  set must be mutated in a corresponding fashion.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-scale" id="dom-context-2d-scale"><code>scale(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</code></dfn> method must add the scaling transformation described by the
  arguments to the transformation matrix. The <var data-anolis-xref="">x</var> argument represents the scale
  factor in the horizontal direction and the <var data-anolis-xref="">y</var> argument represents the scale
  factor in the vertical direction. The factors are multiples.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-rotate" id="dom-context-2d-rotate"><code>rotate(<var data-anolis-xref="">angle</var>)</code></dfn>
  method must add the rotation transformation described by the argument to the transformation
  matrix. The <var data-anolis-xref="">angle</var> argument represents a clockwise rotation angle expressed in
  radians.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-translate" id="dom-context-2d-translate"><code>translate(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</code></dfn> method must add the translation transformation described by the
  arguments to the transformation matrix. The <var data-anolis-xref="">x</var> argument represents the
  translation distance in the horizontal direction and the <var data-anolis-xref="">y</var> argument represents
  the translation distance in the vertical direction. The arguments are in coordinate space
  units.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-transform" id="dom-context-2d-transform"><code>transform(<var data-anolis-xref="">a</var>, <var data-anolis-xref="">b</var>, <var data-anolis-xref="">c</var>, <var data-anolis-xref="">d</var>, <var data-anolis-xref="">e</var>, <var data-anolis-xref="">f</var>)</code></dfn> method must replace the current transformation matrix with the
  result of multiplying the current transformation matrix with the matrix described by:</p>

  </div>

  <table class="matrix">
   <tbody><tr>
    <td><var data-anolis-xref="">a</var></td>
    <td><var data-anolis-xref="">c</var></td>
    <td><var data-anolis-xref="">e</var></td>
   </tr>
   <tr>
    <td><var data-anolis-xref="">b</var></td>
    <td><var data-anolis-xref="">d</var></td>
    <td><var data-anolis-xref="">f</var></td>
   </tr>
   <tr>
    <td>0</td>
    <td>0</td>
    <td>1</td>
   </tr>
  </tbody></table>

  <p class="note">The arguments <var data-anolis-xref="">a</var>, <var data-anolis-xref="">b</var>, <var data-anolis-xref="">c</var>,
  <var data-anolis-xref="">d</var>, <var data-anolis-xref="">e</var>, and <var data-anolis-xref="">f</var> are sometimes called <var data-anolis-xref="">m11</var>, <var data-anolis-xref="">m12</var>, <var data-anolis-xref="">m21</var>, <var data-anolis-xref="">m22</var>,
  <var data-anolis-xref="">dx</var>, and <var data-anolis-xref="">dy</var> or <var data-anolis-xref="">m11</var>, <var data-anolis-xref="">m21</var>, <var data-anolis-xref="">m12</var>, <var data-anolis-xref="">m22</var>, <var data-anolis-xref="">dx</var>, and
  <var data-anolis-xref="">dy</var>. Care should be taken in particular with the order of the second and third
  arguments (<var data-anolis-xref="">b</var> and <var data-anolis-xref="">c</var>) as their order varies from API to API
  and APIs sometimes use the notation <var data-anolis-xref="">m12</var>/<var data-anolis-xref="">m21</var> and sometimes
  <var data-anolis-xref="">m21</var>/<var data-anolis-xref="">m12</var> for those positions.</p>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-context-2d-setTransform" id="dom-context-2d-settransform"><code>setTransform(<var data-anolis-xref="">a</var>, <var data-anolis-xref="">b</var>, <var data-anolis-xref="">c</var>, <var data-anolis-xref="">d</var>, <var data-anolis-xref="">e</var>, <var data-anolis-xref="">f</var>)</code></dfn> method must reset the current transform to the identity matrix, and
  then invoke the <code><a data-anolis-xref="dom-context-2d-transform" href="#dom-context-2d-transform">transform</a>(<var data-anolis-xref="">a</var>, <var data-anolis-xref="">b</var>, <var data-anolis-xref="">c</var>, <var data-anolis-xref="">d</var>, <var data-anolis-xref="">e</var>, <var data-anolis-xref="">f</var>)</code> method with the same arguments.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-resetTransform" id="dom-context-2d-resettransform"><code>resetTransform()</code></dfn> method must
  reset the current transform to the identity matrix.</p>

  </div>



  <h6 id="image-sources-for-2d-rendering-contexts"><span class="secno">1.1.9 </span>Image sources for 2D rendering contexts</h6>

  <p>Several methods in the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> API take the union type
  <code><a href="#canvasimagesource">CanvasImageSource</a></code> as an argument.</p>

  <p>This union type allows objects implementing any of the following interfaces to be used as image
  sources:</p>

  <ul>

   <li><code>HTMLImageElement</code> (<code>img</code> elements)</li>

   <li><code>HTMLVideoElement</code> (<code>video</code> elements)</li>

   <li><code>HTMLCanvasElement</code> (<code>canvas</code> elements)</li>

   <li><code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code></li>

   <li><code>ImageBitmap</code></li>

  </ul>

  <p class="note">The <code>ImageBitmap</code> interface can be created from a number of other
  image-representing types, including <code><a href="#imagedata">ImageData</a></code>.</p>

  <p>When a user agent is required to <dfn id="check-the-usability-of-the-image-argument">check the usability of the <var data-anolis-xref="">image</var>
  argument</dfn>, where <var data-anolis-xref="">image</var> is a <code><a href="#canvasimagesource">CanvasImageSource</a></code> object, the
  user agent must run these steps, which return either <i>good</i>, <i>bad</i>, or
  <i>aborted</i>:</p>

  <ol>

   <li><p>If the <var data-anolis-xref="">image</var> argument is an <code>HTMLImageElement</code> object that
   is in the <span data-anolis-xref="img-error">broken</span> state, then throw an
   <code>InvalidStateError</code> exception, return <i>aborted</i>, and abort these steps.</p>

   </li><li><p>If the <var data-anolis-xref="">image</var> argument is an <code>HTMLImageElement</code> object that
   is not <span data-anolis-xref="img-good">fully decodable</span>, or if the <var data-anolis-xref="">image</var>
   argument is an <code>HTMLVideoElement</code> object whose <code data-anolis-xref="dom-media-readyState">readyState</code> attribute is either <code data-anolis-xref="dom-media-HAVE_NOTHING">HAVE_NOTHING</code> or <code data-anolis-xref="dom-media-HAVE_METADATA">HAVE_METADATA</code>, then return <i>bad</i> and abort these
   steps.</p></li>

   <li><p>If the <var data-anolis-xref="">image</var> argument is an <code>HTMLImageElement</code> object with
   an intrinsic width or intrinsic height (or both) equal to zero, then return <i>bad</i> and abort
   these steps.</p> <!-- http://software.hixie.ch/utilities/js/live-dom-viewer/saved/2567 -->

   </li><li><p>If the <var data-anolis-xref="">image</var> argument is an <code>HTMLCanvasElement</code> object with
   either a horizontal dimension or a vertical dimension equal to zero, then return <i>bad</i> and
   abort these steps.</p>

   </li><li><p>Return <i>good</i>.</p></li>

  </ol>

  <p>When a <code><a href="#canvasimagesource">CanvasImageSource</a></code> object represents an <code>HTMLImageElement</code>, the
  element's image must be used as the source image.</p>

  <p>Specifically, when a <code><a href="#canvasimagesource">CanvasImageSource</a></code> object represents an animated image in an
  <code>HTMLImageElement</code>, the user agent must use the default image of the animation (the
  one that the format defines is to be used when animation is not supported or is disabled), or, if
  there is no such image, the first frame of the animation, when rendering the image for
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> APIs.</p>

  <p>When a <code><a href="#canvasimagesource">CanvasImageSource</a></code> object represents an <code>HTMLVideoElement</code>, then
  the frame at the <span>current playback position</span> when the method with the argument is
  invoked must be used as the source image when rendering the image for
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> APIs, and the source image's dimensions must be the <span data-anolis-xref="concept-video-intrinsic-width">intrinsic width</span> and <span data-anolis-xref="concept-video-intrinsic-height">intrinsic height</span> of the <span>media resource</span>
  (i.e. after any aspect-ratio correction has been applied).</p>

  <p>When a <code><a href="#canvasimagesource">CanvasImageSource</a></code> object represents an <code>HTMLCanvasElement</code>, the
  element's bitmap must be used as the source image.</p>

  <p>When a <code><a href="#canvasimagesource">CanvasImageSource</a></code> object represents a <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>, the
  object's <a href="#scratch-bitmap">scratch bitmap</a> must be used as the source image.</p>

  <p>When a <code><a href="#canvasimagesource">CanvasImageSource</a></code> object represents an element that is <span>being
  rendered</span> and that element has been resized, the original image data of the source image
  must be used, not the image as it is rendered (e.g. <code data-anolis-xref="attr-dim-width">width</code> and
  <code data-anolis-xref="attr-dim-height">height</code> attributes on the source element have no effect on how
  the object is interpreted when rendering the image for <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>
  APIs).</p>

  <p>When a <code><a href="#canvasimagesource">CanvasImageSource</a></code> object represents an <code>ImageBitmap</code>, the
  object's bitmap image data must be used as the source image.</p>

<!--ADD-TOPIC:Security-->
  <p><dfn id="the-image-argument-is-not-origin-clean">The <var data-anolis-xref="">image argument</var> is not origin-clean</dfn> if it is an
  <code>HTMLImageElement</code> or <code>HTMLVideoElement</code> whose <span>origin</span> is not
  the <span data-anolis-xref="same origin">same</span> as the <span>origin</span> specified by the <span>entry
  settings object</span>, or if it is an <code>HTMLCanvasElement</code> whose bitmap's <span data-anolis-xref="concept-canvas-origin-clean">origin-clean</span> flag is false, or if it is a
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object whose <a href="#scratch-bitmap">scratch bitmap</a>'s <span data-anolis-xref="concept-canvas-origin-clean">origin-clean</span> flag is false.</p>
<!--REMOVE-TOPIC:Security-->



  <h6 id="fill-and-stroke-styles"><span class="secno">1.1.10 </span>Fill and stroke styles</h6>

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current style used for filling shapes.</p>

    <p>Can be set, to change the fill style.</p>

    <p>The style can be either a string containing a CSS color, or a
    <code><a href="#canvasgradient">CanvasGradient</a></code> or <code><a href="#canvaspattern">CanvasPattern</a></code>
    object. Invalid values are ignored.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current style used for stroking shapes.</p>

    <p>Can be set, to change the stroke style.</p>

    <p>The style can be either a string containing a CSS color, or a
    <code><a href="#canvasgradient">CanvasGradient</a></code> or <code><a href="#canvaspattern">CanvasPattern</a></code>
    object. Invalid values are ignored.</p>

   </dd>

  </dl>

  <div class="impl">

  <!-- v6 feature requests:

   * Getting and setting colours by component to bypass the CSS value parsing.

     Either:
        context.fillStyle.red += 1;

     Or:
        var array = context.fillStyle;
        array[1] += 1;
        context.fillStyle = array;

   * A more performant way of setting colours in general, e.g.:

       context.setFillColor(r,g,b,a) // already supported by webkit

     Or:

       context.fillStyle = 0xRRGGBBAA; // set a 32bit int directly

  -->

  <p>The <dfn data-anolis-xref="dom-context-2d-fillStyle" id="dom-context-2d-fillstyle"><code>fillStyle</code></dfn> attribute represents the
  color or style to use inside shapes, and the <dfn data-anolis-xref="dom-context-2d-strokeStyle" id="dom-context-2d-strokestyle"><code>strokeStyle</code></dfn> attribute represents the color
  or style to use for the lines around the shapes.</p>

  <p>Both attributes can be either strings, <code><a href="#canvasgradient">CanvasGradient</a></code>s, or
  <code><a href="#canvaspattern">CanvasPattern</a></code>s. On setting, strings must be <span data-anolis-xref="parsed as a CSS
  <color> value">parsed as CSS &lt;color&gt; values</span> and the color assigned, and
  <code><a href="#canvasgradient">CanvasGradient</a></code> and <code><a href="#canvaspattern">CanvasPattern</a></code> objects must be assigned themselves. <a href="#refsCSSCOLOR">[CSSCOLOR]</a> If the value is a string but cannot be <span>parsed as a CSS
  &lt;color&gt; value</span>, then it must be ignored, and the attribute must retain its previous
  value.
<!--ADD-TOPIC:Security-->
  If the new value is a <code><a href="#canvaspattern">CanvasPattern</a></code> object that is marked as <a data-anolis-xref="concept-canvas-pattern-not-origin-clean" href="#concept-canvas-pattern-not-origin-clean">not origin-clean</a>, then the <a href="#scratch-bitmap">scratch
  bitmap</a>'s <span data-anolis-xref="concept-canvas-origin-clean">origin-clean</span> flag must be set to
  false.
<!--REMOVE-TOPIC:Security-->
  </p>

  <p>When set to a <code><a href="#canvaspattern">CanvasPattern</a></code> or <code><a href="#canvasgradient">CanvasGradient</a></code> object, the assignment
  is <span>live</span>, meaning that changes made to the object after the assignment do affect
  subsequent stroking or filling of shapes.</p>

  <p>On getting, if the value is a color, then the <a data-anolis-xref="serialization of a
  color" href="#serialization-of-a-color">serialization of the color</a> must be returned. Otherwise, if it is not a color but a
  <code><a href="#canvasgradient">CanvasGradient</a></code> or <code><a href="#canvaspattern">CanvasPattern</a></code>, then the respective object must be
  returned. (Such objects are opaque and therefore only useful for assigning to other attributes or
  for comparison to other gradients or patterns.)</p>

  <p>The <dfn id="serialization-of-a-color">serialization of a color</dfn> for a color value is a string, computed as follows: if
  it has alpha equal to 1.0, then the string is a lowercase six-digit hex value, prefixed with a "#"
  character (U+0023 NUMBER SIGN), with the first two digits representing the red component, the next
  two digits representing the green component, and the last two digits representing the blue
  component, the digits being <span>lowercase ASCII hex digits</span>. Otherwise, the color value
  has alpha less than 1.0, and the string is the color value in the CSS <code data-anolis-xref="">rgba()</code>
  functional-notation format: the literal string <code data-anolis-xref="">rgba</code> (U+0072 U+0067 U+0062
  U+0061) followed by a U+0028 LEFT PARENTHESIS, a base-ten integer in the range 0-255 representing
  the red component (using <span>ASCII digits</span> in the shortest form possible), a literal
  U+002C COMMA and U+0020 SPACE, an integer for the green component, a comma and a space, an integer
  for the blue component, another comma and space, a U+0030 DIGIT ZERO, if the alpha value is
  greater than zero then a U+002E FULL STOP (representing the decimal point), if the alpha value is
  greater than zero then one or more <span>ASCII digits</span> representing the fractional part of
  the alpha<!-- value with no trailing zeros (implied by next sentence)-->, and finally a U+0029
  RIGHT PARENTHESIS. User agents must express the fractional part of the alpha value, if any, with
  the level of precision necessary for the alpha value, when reparsed, to be interpreted as the same
  alpha value.</p> <!-- if people complain this is unreadable, expand it into a <dl> with two nested
  <ol>s -->

  <p>When the context is created, the <code data-anolis-xref="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code> and <code data-anolis-xref="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code> attributes
  must initially have the string value <code data-anolis-xref="">#000000</code>.</p>

  <p>When the value is a color, it must not be affected by the transformation matrix when used to
  draw on bitmaps.</p> <!-- so singular matrices don't affect solid color fillStyles -->

  </div>

  <hr>

  <p>There are two types of gradients, linear gradients and radial gradients, both represented by
  objects implementing the opaque <code><a href="#canvasgradient">CanvasGradient</a></code> interface.</p>

  <p id="interpolation">Once a gradient has been created (see below), stops are placed along it to
  define how the colors are distributed along the gradient. <span class="impl">The color of the
  gradient at each stop is the color specified for that stop. Between each such stop, the colors and
  the alpha component must be linearly interpolated over the RGBA space without premultiplying the
  alpha value to find the color to use at that offset. Before the first stop, the color must be the
  color of the first stop. After the last stop, the color must be the color of the last stop. When
  there are no stops, the gradient is transparent black.</span></p>

  <dl class="domintro">

   <dt><var data-anolis-xref="">gradient</var> . <code data-anolis-xref="dom-canvasgradient-addColorStop"><a href="#dom-canvasgradient-addcolorstop">addColorStop</a></code>(<var data-anolis-xref="">offset</var>, <var data-anolis-xref="">color</var>)</dt>

   <dd>

    <p>Adds a color stop with the given color to the gradient at the given offset. 0.0 is the offset
    at one end of the gradient, 1.0 is the offset at the other end.</p>

    <p>Throws an <code>IndexSizeError</code> exception if the offset is out of range. Throws a
    <code>SyntaxError</code> exception if the color cannot be parsed.</p>

   </dd>

   <dt><var data-anolis-xref="">gradient</var> = <var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-createLinearGradient"><a href="#dom-context-2d-createlineargradient">createLinearGradient</a></code>(<var data-anolis-xref="">x0</var>, <var data-anolis-xref="">y0</var>, <var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>)</dt>

   <dd>

    <p>Returns a <code><a href="#canvasgradient">CanvasGradient</a></code> object that represents a
    linear gradient that paints along the line given by the
    coordinates represented by the arguments.</p>

   </dd>

   <dt><var data-anolis-xref="">gradient</var> = <var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-createRadialGradient"><a href="#dom-context-2d-createradialgradient">createRadialGradient</a></code>(<var data-anolis-xref="">x0</var>, <var data-anolis-xref="">y0</var>, <var data-anolis-xref="">r0</var>, <var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>, <var data-anolis-xref="">r1</var>)</dt>

   <dd>

    <p>Returns a <code><a href="#canvasgradient">CanvasGradient</a></code> object that represents a
    radial gradient that paints along the cone given by the circles
    represented by the arguments.</p>

    <p>If either of the radii are negative, throws an
    <code>IndexSizeError</code> exception.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-canvasgradient-addColorStop" id="dom-canvasgradient-addcolorstop"><code>addColorStop(<var data-anolis-xref="">offset</var>,
  <var data-anolis-xref="">color</var>)</code></dfn> method on the <code><a href="#canvasgradient">CanvasGradient</a></code> interface adds a
  new stop to a gradient. If the <var data-anolis-xref="">offset</var> is less than 0 or greater than 1 then an
  <code>IndexSizeError</code> exception must be thrown. If the <var data-anolis-xref="">color</var> cannot be
  <span>parsed as a CSS &lt;color&gt; value</span>, then a <code>SyntaxError</code> exception must
  be thrown. Otherwise, the gradient must have a new stop placed, at offset <var data-anolis-xref="">offset</var> relative to the whole gradient, and with the color obtained by parsing <var data-anolis-xref="">color</var> as a CSS &lt;color&gt; value. If multiple stops are added at the same offset
  on a gradient, they must be placed in the order added, with the first one closest to the start of
  the gradient, and each subsequent one infinitesimally further along towards the end point (in
  effect causing all but the first and last stop added at each point to be ignored).</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-createLinearGradient" id="dom-context-2d-createlineargradient"><code>createLinearGradient(<var data-anolis-xref="">x0</var>, <var data-anolis-xref="">y0</var>, <var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>)</code></dfn> method takes four arguments that represent the start point (<var data-anolis-xref="">x0</var>, <var data-anolis-xref="">y0</var>) and end point (<var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>) of the gradient. The method must return a linear <code><a href="#canvasgradient">CanvasGradient</a></code>
  initialised with the specified line.</p>

  <p>Linear gradients must be rendered such that all points on a line perpendicular to the line that
  crosses the start and end points have the color at the point where those two lines cross (with the
  colors coming from the <a href="#interpolation">interpolation and extrapolation</a> described
  above). The points in the linear gradient must be transformed as described by the <a data-anolis-xref="dom-context-2d-transformation" href="#transformations">current transformation matrix</a> when rendering.</p>

  <p>If <span data-anolis-xref=""><var data-anolis-xref="">x0</var> = <var data-anolis-xref="">x1</var></span> and <span data-anolis-xref=""><var data-anolis-xref="">y0</var> = <var data-anolis-xref="">y1</var></span>, then the linear
  gradient must paint nothing.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-createRadialGradient" id="dom-context-2d-createradialgradient"><code>createRadialGradient(<var data-anolis-xref="">x0</var>, <var data-anolis-xref="">y0</var>, <var data-anolis-xref="">r0</var>, <var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>, <var data-anolis-xref="">r1</var>)</code></dfn> method takes six arguments, the first
  three representing the start circle with origin (<var data-anolis-xref="">x0</var>, <var data-anolis-xref="">y0</var>)
  and radius <var data-anolis-xref="">r0</var>, and the last three representing the end circle with origin
  (<var data-anolis-xref="">x1</var>, <var data-anolis-xref="">y1</var>) and radius <var data-anolis-xref="">r1</var>. The values are
  in coordinate space units. If either of <var data-anolis-xref="">r0</var> or <var data-anolis-xref="">r1</var> are
  negative, an <code>IndexSizeError</code> exception must be thrown. Otherwise, the method must
  return a radial <code><a href="#canvasgradient">CanvasGradient</a></code> initialised with the two specified circles.</p>

  <p>Radial gradients must be rendered by following these steps:</p>

  <ol>

   <li><p>If <span data-anolis-xref=""><var data-anolis-xref="">x<sub data-anolis-xref="">0</sub></var> = <var data-anolis-xref="">x<sub data-anolis-xref="">1</sub></var></span> and <span data-anolis-xref=""><var data-anolis-xref="">y<sub data-anolis-xref="">0</sub></var> = <var data-anolis-xref="">y<sub data-anolis-xref="">1</sub></var></span> and <span data-anolis-xref=""><var data-anolis-xref="">r<sub data-anolis-xref="">0</sub></var> = <var data-anolis-xref="">r<sub data-anolis-xref="">1</sub></var></span>, then the radial gradient must
   paint nothing. Abort these steps.</p></li>

   <li>

    <p>Let <span data-anolis-xref="">x(<var data-anolis-xref="">ω</var>) = (<var data-anolis-xref="">x<sub data-anolis-xref="">1</sub></var>-<var data-anolis-xref="">x<sub data-anolis-xref="">0</sub></var>)<var data-anolis-xref="">ω</var> + <var data-anolis-xref="">x<sub data-anolis-xref="">0</sub></var></span></p>

    <p>Let <span data-anolis-xref="">y(<var data-anolis-xref="">ω</var>) = (<var data-anolis-xref="">y<sub data-anolis-xref="">1</sub></var>-<var data-anolis-xref="">y<sub data-anolis-xref="">0</sub></var>)<var data-anolis-xref="">ω</var> + <var data-anolis-xref="">y<sub data-anolis-xref="">0</sub></var></span></p>

    <p>Let <span data-anolis-xref="">r(<var data-anolis-xref="">ω</var>) = (<var data-anolis-xref="">r<sub data-anolis-xref="">1</sub></var>-<var data-anolis-xref="">r<sub data-anolis-xref="">0</sub></var>)<var data-anolis-xref="">ω</var> + <var data-anolis-xref="">r<sub data-anolis-xref="">0</sub></var></span></p>

    <p>Let the color at <var data-anolis-xref="">ω</var> be the color at that position on the gradient
    (with the colors coming from the <a href="#interpolation">interpolation and extrapolation</a>
    described above).</p>

   </li>

   <li><p>For all values of <var data-anolis-xref="">ω</var> where <span data-anolis-xref="">r(<var data-anolis-xref="">ω</var>) &gt; 0</span>, starting with the value of <var data-anolis-xref="">ω</var> nearest to positive infinity and ending with the value of <var data-anolis-xref="">ω</var> nearest to negative infinity, draw the circumference of the circle with
   radius <span data-anolis-xref="">r(<var data-anolis-xref="">ω</var>)</span> at position (<span data-anolis-xref="">x(<var data-anolis-xref="">ω</var>)</span>, <span data-anolis-xref="">y(<var data-anolis-xref="">ω</var>)</span>), with the
   color at <var data-anolis-xref="">ω</var>, but only painting on the parts of the bitmap that have not
   yet been painted on by earlier circles in this step for this rendering of the gradient.</p></li>

  </ol>

  <p class="note">This effectively creates a cone, touched by the two circles defined in the
  creation of the gradient, with the part of the cone before the start circle (0.0) using the color
  of the first offset, the part of the cone after the end circle (1.0) using the color of the last
  offset, and areas outside the cone untouched by the gradient (transparent black).</p>

  <p>The resulting radial gradient must then be transformed as described by the <a data-anolis-xref="dom-context-2d-transformation" href="#transformations">current transformation matrix</a> when rendering.</p>

  <p>Gradients must be painted only where the relevant stroking or filling effects requires that
  they be drawn.</p>

  </div>

  <hr>

  <p>Patterns are represented by objects implementing the opaque <code><a href="#canvaspattern">CanvasPattern</a></code>
  interface.</p>

  <dl class="domintro">

   <dt><var data-anolis-xref="">pattern</var> = <var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-createPattern"><a href="#dom-context-2d-createpattern">createPattern</a></code>(<var data-anolis-xref="">image</var>, <var data-anolis-xref="">repetition</var>)</dt>

   <dd>

    <p>Returns a <code><a href="#canvaspattern">CanvasPattern</a></code> object that uses the given image and repeats in the
    direction(s) given by the <var data-anolis-xref="">repetition</var> argument.</p>

    <p>The allowed values for <var data-anolis-xref="">repetition</var> are <code data-anolis-xref="">repeat</code> (both
    directions), <code data-anolis-xref="">repeat-x</code> (horizontal only), <code data-anolis-xref="">repeat-y</code>
    (vertical only), and <code data-anolis-xref="">no-repeat</code> (neither). If the <var data-anolis-xref="">repetition</var> argument is empty, the value <code data-anolis-xref="">repeat</code> is used.</p>

    <p>If the image isn't yet fully decoded, then nothing is drawn. If the image is a canvas with no
    data, throws an <code>InvalidStateError</code> exception.</p>

   </dd>

   <dt><var data-anolis-xref="">pattern</var> . <code data-anolis-xref="dom-canvaspattern-setTransform"><a href="#dom-canvaspattern-settransform">setTransform</a></code>(<var data-anolis-xref="">transform</var>)</dt>

   <dd>

    <p>Sets the transformation matrix that will be used when rendering the pattern during a fill or
    stroke painting operation.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>To create objects of this type, the <dfn data-anolis-xref="dom-context-2d-createPattern" id="dom-context-2d-createpattern"><code>createPattern(<var data-anolis-xref="">image</var>, <var data-anolis-xref="">repetition</var>)</code></dfn> method is used. When the method is invoked, the user agent
  must run the following steps:</p>

  <ol>

   <li><p>Let <var data-anolis-xref="">image</var> be the first argument and <var data-anolis-xref="">repetition</var> be
   the second argument.</p></li>

   <li><p><a href="#check-the-usability-of-the-image-argument">Check the usability of the <var data-anolis-xref="">image</var> argument</a>. If this
   returns <i>aborted</i>, then an exception has been thrown and the method doesn't return anything;
   abort these steps. If it returns <i>bad</i>, then return null and abort these steps. Otherwise it
   returns <i>good</i>; continue with these steps.</p></li>

   <li><p>If <var data-anolis-xref="">repetition</var> is the empty string, let it be "<code data-anolis-xref="">repeat</code>".</p>

   </li><li><p>If <var data-anolis-xref="">repetition</var> is not a <span>case-sensitive</span> match for one of
   "<code data-anolis-xref="">repeat</code>", "<code data-anolis-xref="">repeat-x</code>", "<code data-anolis-xref="">repeat-y</code>", or "<code data-anolis-xref="">no-repeat</code>", throw a <code>SyntaxError</code>
   exception and abort these steps.</p></li>

   <li><p>Create a new <code><a href="#canvaspattern">CanvasPattern</a></code> object with the image <var data-anolis-xref="">image</var>
   and the repetition behavior given by <var data-anolis-xref="">repetition</var>.</p></li>

<!--ADD-TOPIC:Security-->
   <li><p>If <a href="#the-image-argument-is-not-origin-clean">the <var data-anolis-xref="">image argument</var> is not origin-clean</a>, then mark the
   <code><a href="#canvaspattern">CanvasPattern</a></code> object as <dfn data-anolis-xref="concept-canvas-pattern-not-origin-clean" id="concept-canvas-pattern-not-origin-clean">not
   origin-clean</dfn>.</p></li>
<!--REMOVE-TOPIC:Security-->

   <li><p>Return the <code><a href="#canvaspattern">CanvasPattern</a></code> object.</p></li>

  </ol>

  <p>Modifying the <var data-anolis-xref="">image</var> used when creating a <code><a href="#canvaspattern">CanvasPattern</a></code> object
  after calling the <code data-anolis-xref="dom-context-2d-createPattern"><a href="#dom-context-2d-createpattern">createPattern()</a></code> method must
  not affect the pattern(s) rendered by the <code><a href="#canvaspattern">CanvasPattern</a></code> object.</p>

  <p>Patterns have a transformation matrix, which controls how the pattern is used when it is
  painted. Initially, a pattern's transformation matrix must be the identity transform.</p>

  <p>When the <dfn data-anolis-xref="dom-canvaspattern-setTransform" id="dom-canvaspattern-settransform"><code>setTransform()</code></dfn> method
  is invoked on the pattern, the user agent must replace the pattern's transformation matrix with
  the one described by the <code>SVGMatrix</code> object provided as an argument to the method.</p>

  <p>When a pattern is to be rendered within an area, the user agent must run the following steps to
  determine what is rendered:</p>

  <ol>

   <li><p>Create an infinite transparent black bitmap.</p></li>

   <li>

    <p>Place a copy of the image on the bitmap, anchored such that its top left corner is at the
    origin of the coordinate space, with one coordinate space unit per CSS pixel of the image, then
    place repeated copies of this image horizontally to the left and right, if the repetition
    behavior is "<code data-anolis-xref="">repeat-x</code>", or vertically up and down, if the repetition
    behavior is "<code data-anolis-xref="">repeat-y</code>", or in all four directions all over the bitmap, if
    the repetition behavior is "<code data-anolis-xref="">repeat</code>".</p>

    <p>If the original image data is a bitmap image, the value painted at a point in the area of the
    repetitions is computed by filtering the original image data. When scaling up, if the <code data-anolis-xref="dom-context-2d-imageSmoothingEnabled"><a href="#dom-context-2d-imagesmoothingenabled">imageSmoothingEnabled</a></code> attribute is set to
    false, the image must be rendered using nearest-neighbor interpolation. Otherwise, the user agent
    may use any filtering algorithm (for example bilinear interpolation or nearest-neighbor). When
    such a filtering algorithm requires a pixel value from outside the original image data, it must
    instead use the value from wrapping the pixel's coordinates to the original image's dimensions.
    (That is, the filter uses 'repeat' behavior, regardless of the value of the pattern's repetition
    behavior.)</p>
    <!-- drawImage() has similar paragraphs with different rules -->

   </li>

   <li><p>Transform the resulting bitmap according to the pattern's transformation matrix.</p></li>

   <li><p>Transform the resulting bitmap again, this time according to the <a data-anolis-xref="dom-context-2d-transformation" href="#transformations">current transformation matrix</a>.</p></li>

   <li><p>Replace any part of the image outside the area in which the pattern is to be rendered with
   transparent black.</p></li>

   <li><p>The resulting bitmap is what is to be rendered, with the same origin and same
   scale.</p></li>

  </ol>

  <hr>

  <p>If a radial gradient or repeated pattern is used when the transformation matrix is singular,
  the resulting style must be transparent black (otherwise the gradient or pattern would be
  collapsed to a point or line, leaving the other pixels undefined). Linear gradients and solid
  colors always define all points even with singular tranformation matrices.</p>

  </div>




  <h6 id="drawing-rectangles-to-the-bitmap"><span class="secno">1.1.11 </span>Drawing rectangles to the bitmap</h6>

  <p>There are three methods that immediately draw rectangles to the bitmap. They each take four
  arguments; the first two give the <var data-anolis-xref="">x</var> and <var data-anolis-xref="">y</var> coordinates of
  the top left of the rectangle, and the second two give the width <var data-anolis-xref="">w</var> and height
  <var data-anolis-xref="">h</var> of the rectangle, respectively.</p>

  <div class="impl">

  <p>The <a data-anolis-xref="dom-context-2d-transformation" href="#transformations">current transformation matrix</a> must be
  applied to the following four coordinates, which form the path that must then be closed to get the
  specified rectangle: <span data-anolis-xref="">(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</span>, <span data-anolis-xref="">(<span data-anolis-xref=""><var data-anolis-xref="">x</var>+<var data-anolis-xref="">w</var></span>, <var data-anolis-xref="">y</var>)</span>, <span data-anolis-xref="">(<span data-anolis-xref=""><var data-anolis-xref="">x</var>+<var data-anolis-xref="">w</var></span>, <span data-anolis-xref=""><var data-anolis-xref="">y</var>+<var data-anolis-xref="">h</var></span>)</span>, <span data-anolis-xref="">(<var data-anolis-xref="">x</var>, <span data-anolis-xref=""><var data-anolis-xref="">y</var>+<var data-anolis-xref="">h</var></span>)</span>.</p>

  <p>Shapes are painted without affecting the <a href="#current-default-path">current default path</a>, and are subject to
  the <a href="#clipping-region">clipping region</a>, and, with the exception of <code data-anolis-xref="dom-context-2d-clearRect"><a href="#dom-context-2d-clearrect">clearRect()</a></code>, also <a data-anolis-xref="shadows" href="#shadows">shadow
  effects</a>, <a data-anolis-xref="dom-context-2d-globalAlpha" href="#dom-context-2d-globalalpha">global alpha</a>, and <a data-anolis-xref="dom-context-2d-globalCompositeOperation" href="#dom-context-2d-globalcompositeoperation">global composition operators</a>.</p>

  </div>

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-clearRect"><a href="#dom-context-2d-clearrect">clearRect</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">w</var>, <var data-anolis-xref="">h</var>)</dt>

   <dd>

    <p>Clears all pixels on the bitmap in the given rectangle to transparent black.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-fillRect"><a href="#dom-context-2d-fillrect">fillRect</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">w</var>, <var data-anolis-xref="">h</var>)</dt>

   <dd>

    <p>Paints the given rectangle onto the bitmap, using the current fill style.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-strokeRect"><a href="#dom-context-2d-strokerect">strokeRect</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">w</var>, <var data-anolis-xref="">h</var>)</dt>

   <dd>

    <p>Paints the box that outlines the given rectangle onto the bitmap, using the current stroke
    style.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-context-2d-clearRect" id="dom-context-2d-clearrect"><code>clearRect(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">w</var>, <var data-anolis-xref="">h</var>)</code></dfn> method must run the
  following steps:</p>

  <ol>

   <li><p>Let <var data-anolis-xref="">pixels</var> be the set of pixels in the specified rectangle that also
   intersect the current <a href="#clipping-region">clipping region</a>.</p></li>

   <li><p>Clear the pixels in <var data-anolis-xref="">pixels</var> to a fully transparent black, erasing any
   previous image.</p></li>

   <li><p><a href="#clear-regions-that-cover-the-pixels">Clear regions that cover the pixels</a> in <var data-anolis-xref="">pixels</var> on the
   <a href="#scratch-bitmap">scratch bitmap</a>.</p></li>

  </ol>

  <p class="note">If either height or width are zero, this method has no effect, since the set of
  pixels would be empty.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-fillRect" id="dom-context-2d-fillrect"><code>fillRect(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">w</var>, <var data-anolis-xref="">h</var>)</code></dfn> method must paint the
  specified rectangular area using the <code data-anolis-xref="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code>. If
  either height or width are zero, this method has no effect.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-strokeRect" id="dom-context-2d-strokerect"><code>strokeRect(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">w</var>, <var data-anolis-xref="">h</var>)</code></dfn> method must take the
  result of <a data-anolis-xref="trace a path" href="#trace-a-path">tracing the path</a> described below, using the
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object's line styles, and fill it with the <code data-anolis-xref="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code>.</p>

  <p>If both <var data-anolis-xref="">w</var> and <var data-anolis-xref="">h</var> are zero, the path has a single subpath
  with just one point (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>), and no lines, and this method
  thus has no effect (the <a href="#trace-a-path">trace a path</a> algorithm returns an empty path in that
  case).</p>

  <p>If just one of either <var data-anolis-xref="">w</var> or <var data-anolis-xref="">h</var> is zero, then the path has
  a single subpath consisting of two points, with coordinates (<span data-anolis-xref=""><var data-anolis-xref="">x</var></span>, <span data-anolis-xref=""><var data-anolis-xref="">y</var></span>) and (<span data-anolis-xref=""><var data-anolis-xref="">x</var>+<var data-anolis-xref="">w</var></span>, <span data-anolis-xref=""><var data-anolis-xref="">y</var></span>+<var data-anolis-xref="">h</var>), in that order, connected by a single straight line.</p>

  <p>Otherwise, the path has a single subpath consisting of four points, with coordinates (<span data-anolis-xref=""><var data-anolis-xref="">x</var></span>, <span data-anolis-xref=""><var data-anolis-xref="">y</var></span>), (<span data-anolis-xref=""><var data-anolis-xref="">x</var>+<var data-anolis-xref="">w</var></span>, <span data-anolis-xref=""><var data-anolis-xref="">y</var></span>), (<span data-anolis-xref=""><var data-anolis-xref="">x</var>+<var data-anolis-xref="">w</var></span>,
  <span data-anolis-xref=""><var data-anolis-xref="">y</var></span>+<var data-anolis-xref="">h</var>), and (<span data-anolis-xref=""><var data-anolis-xref="">x</var></span>, <span data-anolis-xref=""><var data-anolis-xref="">y</var>+<var data-anolis-xref="">h</var></span>),
  connected to each other in that order by straight lines.</p>

  </div>



  <h6 id="drawing-text-to-the-bitmap"><span class="secno">1.1.12 </span>Drawing text to the bitmap</h6>

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-fillText"><a href="#dom-context-2d-filltext">fillText</a></code>(<var data-anolis-xref="">text</var>, <var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var> [, <var data-anolis-xref="">maxWidth</var> ] )</dt>
   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-strokeText"><a href="#dom-context-2d-stroketext">strokeText</a></code>(<var data-anolis-xref="">text</var>, <var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var> [, <var data-anolis-xref="">maxWidth</var> ] )</dt>

   <dd>

    <p>Fills or strokes (respectively) the given text at the given position. If a maximum width is
    provided, the text will be scaled to fit that width if necessary.</p>

   </dd>

   <dt><var data-anolis-xref="">metrics</var> = <var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-measureText"><a href="#dom-context-2d-measuretext">measureText</a></code>(<var data-anolis-xref="">text</var>)</dt>

   <dd>

    <p>Returns a <code><a href="#textmetrics">TextMetrics</a></code> object with the metrics of the given text in the current
    font.</p>

   </dd>

   <dt><var data-anolis-xref="">metrics</var> . <code data-anolis-xref="dom-textmetrics-width"><a href="#dom-textmetrics-width">width</a></code></dt>
   <dt><var data-anolis-xref="">metrics</var> . <code data-anolis-xref="dom-textmetrics-actualBoundingBoxLeft"><a href="#dom-textmetrics-actualboundingboxleft">actualBoundingBoxLeft</a></code></dt>
   <dt><var data-anolis-xref="">metrics</var> . <code data-anolis-xref="dom-textmetrics-actualBoundingBoxRight"><a href="#dom-textmetrics-actualboundingboxright">actualBoundingBoxRight</a></code></dt>
   <dt><var data-anolis-xref="">metrics</var> . <code data-anolis-xref="dom-textmetrics-fontBoundingBoxAscent"><a href="#dom-textmetrics-fontboundingboxascent">fontBoundingBoxAscent</a></code></dt>
   <dt><var data-anolis-xref="">metrics</var> . <code data-anolis-xref="dom-textmetrics-fontBoundingBoxDescent"><a href="#dom-textmetrics-fontboundingboxdescent">fontBoundingBoxDescent</a></code></dt>
   <dt><var data-anolis-xref="">metrics</var> . <code data-anolis-xref="dom-textmetrics-actualBoundingBoxAscent"><a href="#dom-textmetrics-actualboundingboxascent">actualBoundingBoxAscent</a></code></dt>
   <dt><var data-anolis-xref="">metrics</var> . <code data-anolis-xref="dom-textmetrics-actualBoundingBoxDescent"><a href="#dom-textmetrics-actualboundingboxdescent">actualBoundingBoxDescent</a></code></dt>
   <dt><var data-anolis-xref="">metrics</var> . <code data-anolis-xref="dom-textmetrics-emHeightAscent"><a href="#dom-textmetrics-emheightascent">emHeightAscent</a></code></dt>
   <dt><var data-anolis-xref="">metrics</var> . <code data-anolis-xref="dom-textmetrics-emHeightDescent"><a href="#dom-textmetrics-emheightdescent">emHeightDescent</a></code></dt>
   <dt><var data-anolis-xref="">metrics</var> . <code data-anolis-xref="dom-textmetrics-hangingBaseline"><a href="#dom-textmetrics-hangingbaseline">hangingBaseline</a></code></dt>
   <dt><var data-anolis-xref="">metrics</var> . <code data-anolis-xref="dom-textmetrics-alphabeticBaseline"><a href="#dom-textmetrics-alphabeticbaseline">alphabeticBaseline</a></code></dt>
   <dt><var data-anolis-xref="">metrics</var> . <code data-anolis-xref="dom-textmetrics-ideographicBaseline"><a href="#dom-textmetrics-ideographicbaseline">ideographicBaseline</a></code></dt>

   <dd>

    <p>Returns the measurement described below.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> interface provides the following methods for
  rendering text.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-fillText" id="dom-context-2d-filltext"><code>fillText()</code></dfn> and <dfn data-anolis-xref="dom-context-2d-strokeText" id="dom-context-2d-stroketext"><code>strokeText()</code></dfn> methods take three or four
  arguments, <var data-anolis-xref="">text</var>, <var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, and optionally
  <var data-anolis-xref="">maxWidth</var>, and render the given <var data-anolis-xref="">text</var> at the given (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) coordinates ensuring that the text isn't wider than <var data-anolis-xref="">maxWidth</var> if specified, using the current <code data-anolis-xref="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code>, <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code>,
  and <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> values. Specifically, when the
  methods are called, the user agent must run the following steps:</p>

  <ol>

   <li><p>Run the <a href="#text-preparation-algorithm">text preparation algorithm</a>, passing it <var data-anolis-xref="">text</var>, the
   <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object, and, if the <var data-anolis-xref="">maxWidth</var> argument
   was provided, that argument. Let <var data-anolis-xref="">glyphs</var> be the result.</p>

   </li><li><p>Move all the shapes in <var data-anolis-xref="">glyphs</var> to the right by <var data-anolis-xref="">x</var>
   CSS pixels and down by <var data-anolis-xref="">y</var> CSS pixels.</p></li>

   <li>

    <p>Paint the shapes given in <var data-anolis-xref="">glyphs</var>, as transformed by the <a data-anolis-xref="dom-context-2d-transformation" href="#transformations">current transformation matrix</a>, with each CSS pixel
    in the coordinate space of <var data-anolis-xref="">glyphs</var> mapped to one coordinate space unit.</p>

    <p>For <code data-anolis-xref="dom-context-2d-fillText"><a href="#dom-context-2d-filltext">fillText()</a></code>, <code data-anolis-xref="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code> must be applied to the shapes and <code data-anolis-xref="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code> must be ignored. For <code data-anolis-xref="dom-context-2d-strokeText"><a href="#dom-context-2d-stroketext">strokeText()</a></code>, the reverse holds: <code data-anolis-xref="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code> must be applied to the result of <a data-anolis-xref="trace a path" href="#trace-a-path">tracing</a> the shapes using the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>
    object for the line styles, and <code data-anolis-xref="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code> must be
    ignored.</p>

    <p>These shapes are painted without affecting the current path, and are subject to <a data-anolis-xref="shadows" href="#shadows">shadow effects</a>, <a data-anolis-xref="dom-context-2d-globalAlpha" href="#dom-context-2d-globalalpha">global
    alpha</a>, the <a href="#clipping-region">clipping region</a>, and <a data-anolis-xref="dom-context-2d-globalCompositeOperation" href="#dom-context-2d-globalcompositeoperation">global composition operators</a>.</p>

   </li>

<!--ADD-TOPIC:Security-->
   <li><p>If the <a href="#text-preparation-algorithm">text preparation algorithm</a> used a font that has an <span>origin</span>
   that is not the <span data-anolis-xref="same origin">same</span> as the <span>origin</span> specified by
   the <span>entry settings object</span> (even if "using a font" means just checking if that font
   has a particular glyph in it before falling back to another font), then set the <a href="#scratch-bitmap">scratch
   bitmap</a>'s <span data-anolis-xref="concept-canvas-origin-clean">origin-clean</span> flag to
   false.</p></li> <!-- because fonts could consider sensitive material, I guess; and because that
   sensitivity could extend to whether or not a particular glyph is in the font in the first place.
   -->
<!--REMOVE-TOPIC:Security-->

  </ol>

<!--v6DVT - this is commented out until CSS can get its act together
enough to actual specify vertical text rendering (how long have we
been waiting now?)

WHEN EDITING THIS, FIX THE PARTS MARKED "&#x0058;&#x0058;&#x0058;" BELOW

ALSO NOTE THAT THIS PROBABLY NEEDS ENTIRELY REVISITING NOW THAT WE
HAVE REJIGGED HOW TEXT WORKS IN v5 (e.g. remember security)

  <p>The <dfn data-x="dom-context-2d-fillVerticalText"><code>fillVerticalText()</code></dfn> and <dfn
  data-x="dom-context-2d-strokeVerticalText"><code>strokeVerticalText()</code></dfn> methods take
  three or four arguments, <var data-x="">text</var>, <var data-x="">x</var>, <var data-x="">y</var>,
  and optionally <var data-x="">maxHeight</var>, and render the given <var data-x="">text</var> as
  vertical text at the given (<var data-x="">x</var>, <var data-x="">y</var>) coordinates ensuring
  that the text isn't taller than <var data-x="">maxHeight</var> if specified, using the current
  <code data-x="dom-context-2d-font">font</code> and <code
  data-x="dom-context-2d-textAlign">textAlign</code> values. Specifically, when the methods are
  called, the user agent must run the following steps:</p>

  <ol>

   <li><p>If <var data-x="">maxHeight</var> is present but less than or equal to zero, return without
   doing anything; abort these steps.</p></li>

   <li><p>Let <var data-x="">font</var> be the current font of the context, as given by the <code
   data-x="dom-context-2d-font">font</code> attribute.</p></li>

   <li><p>Replace all the <span data-x="space character">space characters</span> in <var
   data-x="">text</var> with U+0020 SPACE characters.</p></li>

   <li><p>Form a <em class="&#x0058;&#x0058;&#x0058;">whatever CSS ends up calling vertical line
   boxes and inline boxes</em> containing the text <var data-x="">text</var>, with all the properties
   at their initial values except the 'font' property of the inline box set to <var
   data-x="">font</var> and the 'direction' property of the inline box set to <span>the
   directionality</span> of the <code>canvas</code> element.</p></li>

   <!- - if you insert a step here, make sure to adjust the next step's final words - ->

   <li><p>If the <var data-x="">maxHeight</var> argument was specified and the hypothetical height of
   the <em class="&#x0058;&#x0058;&#x0058;">box</em> in the hypothetical line box is greater than
   <var data-x="">maxHeight</var> CSS pixels, then change <var data-x="">font</var> to have a more
   condensed font (if one is available or if a reasonably readable one can be synthesized by
   applying an appropriate scale factor to the font) or a smaller font, and return to the previous
   step.</p></li>

   <li>

    <p>Let the <var data-x="">anchor point</var> be a point on the <em
    class="&#x0058;&#x0058;&#x0058;">inline box</var>, determined by the <code
    data-x="dom-context-2d-textAlign">textAlign</code>, as follows:</p>

    <p>Vertical position:</p>

    <dl>

     <dt>If <code data-x="dom-context-2d-textAlign">textAlign</code> is <code
     data-x="">start</code></dt>

     <dt>If <code data-x="dom-context-2d-textAlign">textAlign</code> is <code data-x="">left</code>
     and <span>the directionality</span> of the <code>canvas</code> element is 'ltr'</dt>

     <dt>If <code data-x="dom-context-2d-textAlign">textAlign</code> is <code data-x="">right</code>
     and <span>the directionality</span> of the <code>canvas</code> element is 'rtl'</dt>

     <dd>Let the <var data-x="">anchor point</var>'s vertical position be the top edge of the <em
     class="&#x0058;&#x0058;&#x0058;">inline box</em>.</dd>


     <dt>If <code data-x="dom-context-2d-textAlign">textAlign</code> is <code
     data-x="">end</code></dt>

     <dt>If <code data-x="dom-context-2d-textAlign">textAlign</code> is <code data-x="">right</code>
     and <span>the directionality</span> of the <code>canvas</code> element is 'ltr'</dt>

     <dt>If <code data-x="dom-context-2d-textAlign">textAlign</code> is <code data-x="">left</code>
     and <span>the directionality</span> of the <code>canvas</code> element is 'rtl'</dt>

     <dd>Let the <var data-x="">anchor point</var>'s vertical
     position be the bottom edge of the <em class="&#x0058;&#x0058;&#x0058;">inline
     box</em>.</dd>


     <dt>If <code data-x="dom-context-2d-textAlign">textAlign</code> is <code
     data-x="">center</code></dt>

     <dd>Let the <var data-x="">anchor point</var>'s vertical position be half way between the top
     and bottom edges of the <em class="&#x0058;&#x0058;&#x0058;">inline box</em>.</dd>

    </dl>

    <p>Let the horizontal position be half way between the left and right edges of the em box of the
    first available font of the <em class="&#x0058;&#x0058;&#x0058;">inline box</em>.</p>

   </li>

   <li>

    <p>Paint the hypothetical inline box as the shape given by the text's glyphs, as transformed by
    the <span data-x="dom-context-2d-transformation">current transformation matrix</span>, and
    anchored and sized so that before applying the <span
    data-x="dom-context-2d-transformation">current transformation matrix</span>, the <var
    data-x="">anchor point</var> is at (<var data-x="">x</var>, <var data-x="">y</var>) and each CSS
    pixel is mapped to one coordinate space unit.</p>

    <p>For <code data-x="dom-context-2d-fillVerticalText">fillVerticalText()</code> <code
    data-x="dom-context-2d-fillStyle">fillStyle</code> must be applied and <code
    data-x="dom-context-2d-strokeStyle">strokeStyle</code> must be ignored. For <code
    data-x="dom-context-2d-strokeVerticalText">strokeVerticalText()</code> the reverse holds and
    <code data-x="dom-context-2d-strokeStyle">strokeStyle</code> must be applied and <code
    data-x="dom-context-2d-fillStyle">fillStyle</code> must be ignored.</p>

    <p>Text is painted without affecting the current path, and is subject to <span
    data-x="shadows">shadow effects</span>, <span data-x="dom-context-2d-globalAlpha">global
    alpha</span>, the <span>clipping region</span>, and <span
    data-x="dom-context-2d-globalCompositeOperation">global composition operators</span>.</p>

   </li>

  </ol>

v6DVT (also check for '- -' bits in the part above) -->

  <p>The <dfn data-anolis-xref="dom-context-2d-measureText" id="dom-context-2d-measuretext"><code>measureText()</code></dfn> method takes one
  argument, <var data-anolis-xref="">text</var>. When the method is invoked, the user agent must run the
  <a href="#text-preparation-algorithm">text preparation algorithm</a>, passing it <var data-anolis-xref="">text</var> and the
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object, and then using the returned inline box must create a
  new <code><a href="#textmetrics">TextMetrics</a></code> object with its attributes set as described in the following list.
<!--ADD-TOPIC:Security-->
  If doing these measurements requires using a font that has an <span>origin</span> that is not the
  <span data-anolis-xref="same origin">same</span> as that of the <code>Document</code> object that owns the
  <code>canvas</code> element (even if "using a font" means just checking if that font has a
  particular glyph in it before falling back to another font), then the method must throw a
  <code>SecurityError</code> exception.
<!--REMOVE-TOPIC:Security-->
  Otherwise, it must return the new <code><a href="#textmetrics">TextMetrics</a></code> object.
  <a href="#refsCSS">[CSS]</a>
  
  </p>

  </div>

  <dl>

   <dt><dfn data-anolis-xref="dom-textmetrics-width" id="dom-textmetrics-width"><code>width</code></dfn> attribute</dt>

   <dd><p>The width of that inline box, in CSS pixels. (The text's advance width.)</p></dd>

   <dt><dfn data-anolis-xref="dom-textmetrics-actualBoundingBoxLeft" id="dom-textmetrics-actualboundingboxleft"><code>actualBoundingBoxLeft</code></dfn> attribute</dt>

   <dd>

    <p>The distance parallel to the baseline from the alignment point given by the <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> attribute to the left side of the bounding
    rectangle of the given text, in CSS pixels; positive numbers indicating a distance going left
    from the given alignment point.

    </p><p class="note">The sum of this value and the next (<code data-anolis-xref="dom-textmetrics-actualBoundingBoxRight"><a href="#dom-textmetrics-actualboundingboxright">actualBoundingBoxRight</a></code>) can be wider than
    the width of the inline box (<code data-anolis-xref="dom-textmetrics-width"><a href="#dom-textmetrics-width">width</a></code>), in particular
    with slanted fonts where characters overhang their advance width.</p>

   </dd>

   <dt><dfn data-anolis-xref="dom-textmetrics-actualBoundingBoxRight" id="dom-textmetrics-actualboundingboxright"><code>actualBoundingBoxRight</code></dfn> attribute</dt>

   <dd>

    <p>The distance parallel to the baseline from the alignment point given by the <code data-anolis-xref="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> attribute to the right side of the bounding
    rectangle of the given text, in CSS pixels; positive numbers indicating a distance going right
    from the given alignment point.</p>

   </dd>

   <dt><dfn data-anolis-xref="dom-textmetrics-fontBoundingBoxAscent" id="dom-textmetrics-fontboundingboxascent"><code>fontBoundingBoxAscent</code></dfn> attribute</dt>

   <dd>

    <p>The distance from the horizontal line indicated by the <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> attribute to the top of the highest
    bounding rectangle of all the fonts used to render the text, in CSS pixels; positive numbers
    indicating a distance going up from the given baseline.</p>

    <p class="note">This value and the next are useful when rendering a background that must have a
    consistent height even if the exact text being rendered changes. The <code data-anolis-xref="dom-textmetrics-actualBoundingBoxAscent"><a href="#dom-textmetrics-actualboundingboxascent">actualBoundingBoxAscent</a></code> attribute (and
    its corresponding attribute for the descent) are useful when drawing a bounding box around
    specific text.</p>

   </dd>

   <dt><dfn data-anolis-xref="dom-textmetrics-fontBoundingBoxDescent" id="dom-textmetrics-fontboundingboxdescent"><code>fontBoundingBoxDescent</code></dfn> attribute</dt>

   <dd><p>The distance from the horizontal line indicated by the <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> attribute to the bottom of the lowest
   bounding rectangle of all the fonts used to render the text, in CSS pixels; positive numbers
   indicating a distance going down from the given baseline.</p></dd>

   <dt><dfn data-anolis-xref="dom-textmetrics-actualBoundingBoxAscent" id="dom-textmetrics-actualboundingboxascent"><code>actualBoundingBoxAscent</code></dfn> attribute</dt>

   <dd>

    <p>The distance from the horizontal line indicated by the <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> attribute to the top of the bounding
    rectangle of the given text, in CSS pixels; positive numbers indicating a distance going up from
    the given baseline.

    </p><p class="note">This number can vary greatly based on the input text, even if the first font
    specified covers all the characters in the input. For example, the <code data-anolis-xref="dom-textmetrics-actualBoundingBoxAscent"><a href="#dom-textmetrics-actualboundingboxascent">actualBoundingBoxAscent</a></code> of a lowercase
    "o" from an alphabetic baseline would be less than that of an uppercase "F". The value can
    easily be negative; for example, the distance from the top of the em box (<code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> value "<code data-anolis-xref="dom-context-2d-textBaseline-top"><a href="#dom-context-2d-textbaseline-top">top</a></code>") to the top of the bounding rectangle when
    the given text is just a single comma "<code data-anolis-xref="">,</code>" would likely (unless the font is
    quite unusual) be negative.</p>

   </dd>

   <dt><dfn data-anolis-xref="dom-textmetrics-actualBoundingBoxDescent" id="dom-textmetrics-actualboundingboxdescent"><code>actualBoundingBoxDescent</code></dfn> attribute</dt>

   <dd><p>The distance from the horizontal line indicated by the <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> attribute to the bottom of the bounding
   rectangle of the given text, in CSS pixels; positive numbers indicating a distance going down
   from the given baseline.</p></dd>

   <dt><dfn data-anolis-xref="dom-textmetrics-emHeightAscent" id="dom-textmetrics-emheightascent"><code>emHeightAscent</code></dfn> attribute</dt>

   <dd><p>The distance from the horizontal line indicated by the <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> attribute to the highest top of the em
   squares in the line box, in CSS pixels; positive numbers indicating that the given baseline is
   below the top of that em square (so this value will usually be positive). Zero if the given
   baseline is the top of that em square; half the font size if the given baseline is the middle of
   that em square.</p></dd>

   <dt><dfn data-anolis-xref="dom-textmetrics-emHeightDescent" id="dom-textmetrics-emheightdescent"><code>emHeightDescent</code></dfn> attribute</dt>

   <dd><p>The distance from the horizontal line indicated by the <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> attribute to the lowest bottom of the em
   squares in the line box, in CSS pixels; positive numbers indicating that the given baseline is
   below the bottom of that em square (so this value will usually be negative). (Zero if the given
   baseline is the top of that em square.)</p></dd>

   <dt><dfn data-anolis-xref="dom-textmetrics-hangingBaseline" id="dom-textmetrics-hangingbaseline"><code>hangingBaseline</code></dfn> attribute</dt>

   <dd><p>The distance from the horizontal line indicated by the <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> attribute to the hanging baseline of the
   line box, in CSS pixels; positive numbers indicating that the given baseline is below the hanging
   baseline. (Zero if the given baseline is the hanging baseline.)</p></dd>

   <dt><dfn data-anolis-xref="dom-textmetrics-alphabeticBaseline" id="dom-textmetrics-alphabeticbaseline"><code>alphabeticBaseline</code></dfn> attribute</dt>

   <dd><p>The distance from the horizontal line indicated by the <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> attribute to the alphabetic baseline of
   the line box, in CSS pixels; positive numbers indicating that the given baseline is below the
   alphabetic baseline. (Zero if the given baseline is the alphabetic baseline.)</p></dd>

   <dt><dfn data-anolis-xref="dom-textmetrics-ideographicBaseline" id="dom-textmetrics-ideographicbaseline"><code>ideographicBaseline</code></dfn> attribute</dt>

   <dd><p>The distance from the horizontal line indicated by the <code data-anolis-xref="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> attribute to the ideographic baseline of
   the line box, in CSS pixels; positive numbers indicating that the given baseline is below the
   ideographic baseline. (Zero if the given baseline is the ideographic baseline.)</p></dd>

  </dl>

  <p class="note">Glyphs rendered using <code data-anolis-xref="dom-context-2d-fillText"><a href="#dom-context-2d-filltext">fillText()</a></code> and
  <code data-anolis-xref="dom-context-2d-strokeText"><a href="#dom-context-2d-stroketext">strokeText()</a></code> can spill out of the box given by the
  font size (the em square size) and the width returned by <code data-anolis-xref="dom-context-2d-measureText"><a href="#dom-context-2d-measuretext">measureText()</a></code> (the text width). Authors are encouraged
  to use the bounding box values described above if this is an issue.</p>

  <p class="note">A future version of the 2D context API may provide a way to render fragments of
  documents, rendered using CSS, straight to the canvas. This would be provided in preference to a
  dedicated way of doing multiline layout.</p>



  <h6 id="drawing-paths-to-the-canvas"><span class="secno">1.1.13 </span>Drawing paths to the canvas</h6>

  <p>The context always has a <dfn id="current-default-path">current default path</dfn>. There is only one <a href="#current-default-path">current
  default path</a>, it is not part of the <a href="#drawing-state">drawing state</a>. The <a href="#current-default-path">current default
  path</a> is a <a data-anolis-xref="concept-path" href="#concept-path">path</a>, as described above.</p>

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-beginPath"><a href="#dom-context-2d-beginpath">beginPath</a></code>()</dt>

   <dd>

    <p>Resets the <a href="#current-default-path">current default path</a>.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-fill"><a href="#dom-context-2d-fill">fill</a></code>( [ <var data-anolis-xref="">fillRule</var> ] )</dt>
   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-fill"><a href="#dom-context-2d-fill">fill</a></code>(<var data-anolis-xref="">path</var> [, <var data-anolis-xref="">fillRule</var> ] )</dt>

   <dd>

    <p>Fills the subpaths of the <a href="#current-default-path">current default path</a> or the given path with the
    current fill style, obeying the given fill rule.</p>

   </dd>


   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-stroke"><a href="#dom-context-2d-stroke">stroke</a></code>()</dt>
   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-stroke"><a href="#dom-context-2d-stroke">stroke</a></code>(<var data-anolis-xref="">path</var>)</dt>

   <dd>

    <p>Strokes the subpaths of the <a href="#current-default-path">current default path</a> or the given path with the
    current stroke style.</p>

   </dd>

   <!-- START w3c-html-->
   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-drawFocusIfNeeded"><a href="#dom-context-2d-drawfocusifneeded">drawFocusIfNeeded</a></code>(<var data-anolis-xref="">element</var>)</dt>
   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-drawFocusIfNeeded"><a href="#dom-context-2d-drawfocusifneeded">drawFocusIfNeeded</a></code>(<var data-anolis-xref="">path</var>, <var data-anolis-xref="">element</var>)</dt>
   <!-- END FORK w3c-html-->
   <dd>


    <p>If the given element is <span>focused</span>, draws a focus outline around the <a href="#current-default-path">current
    default path</a> or the given path, following the platform conventions for focus outlines.</p>

   </dd>


   <dt><var data-anolis-xref="">shouldDraw</var> = <var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-drawCustomFocusRing"><a href="#dom-context-2d-drawcustomfocusring">drawCustomFocusRing</a></code>(<var data-anolis-xref="">element</var>)</dt>
   <dt><var data-anolis-xref="">shouldDraw</var> = <var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-drawCustomFocusRing"><a href="#dom-context-2d-drawcustomfocusring">drawCustomFocusRing</a></code>(<var data-anolis-xref="">path</var>, <var data-anolis-xref="">element</var>)</dt>

   <dd>

    <p>If the given element is <span>focused</span>, and the user has configured the system to draw
    focus outlines in a particular manner (for example, high contrast focus outlines), draws a focus outline
    around the <a href="#current-default-path">current default path</a> or the given path and returns false.</p>

    <p>Otherwise, returns true if the given element is <span>focused</span>, and false otherwise.
    This can thus be used to determine when to draw a focus outline (see <a href="#drawCustomFocusRingExample">the example</a> below).</p>

   </dd>


   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-scrollPathIntoView"><a href="#dom-context-2d-scrollpathintoview">scrollPathIntoView</a></code>()</dt>
   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-scrollPathIntoView"><a href="#dom-context-2d-scrollpathintoview">scrollPathIntoView</a></code>(<var data-anolis-xref="">path</var>)</dt>

   <dd>

    <p>Scrolls the <a href="#current-default-path">current default path</a> or the given path into view. This is especially
    useful on devices with small screens, where the whole canvas might not be visible at once.</p>

   </dd>


   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-clip"><a href="#dom-context-2d-clip">clip</a></code>( [ <var data-anolis-xref="">fillRule</var> ] )</dt>
   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-clip"><a href="#dom-context-2d-clip">clip</a></code>(<var data-anolis-xref="">path</var> [, <var data-anolis-xref="">fillRule</var> ] )</dt>

   <dd>

    <p>Further constrains the clipping region to the <a href="#current-default-path">current default path</a> or the given
    path, using the given fill rule to determine what points are in the path.</p>

   </dd>


   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-resetClip"><a href="#dom-context-2d-resetclip">resetClip</a></code>()</dt>

   <dd>

    <p>Unconstrains the clipping region.</p>

   </dd>


   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-isPointInPath"><a href="#dom-context-2d-ispointinpath">isPointInPath</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var> [, <var data-anolis-xref="">fillRule</var> ] )</dt>
   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-isPointInPath"><a href="#dom-context-2d-ispointinpath">isPointInPath</a></code>(<var data-anolis-xref="">path</var>, <var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var> [, <var data-anolis-xref="">fillRule</var> ] )</dt>

   <dd>

    <p>Returns true if the given point is in the <a href="#current-default-path">current default path</a> or the given
    path, using the given fill rule to determine what points are in the path.</p>

   </dd>


   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-isPointInStroke"><a href="#dom-context-2d-ispointinstroke">isPointInStroke</a></code>(<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</dt>
   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-isPointInStroke"><a href="#dom-context-2d-ispointinstroke">isPointInStroke</a></code>(<var data-anolis-xref="">path</var>, <var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>)</dt>

   <dd>

    <p>Returns true if the given point would be in the region covered by the stroke of the
    <a href="#current-default-path">current default path</a> or the given path, given the current stroke style.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-context-2d-beginPath" id="dom-context-2d-beginpath"><code>beginPath()</code></dfn> method must empty the
  list of subpaths in the context's <a href="#current-default-path">current default path</a> so that the it once again has
  zero subpaths.</p>

  <p>Where the following method definitions use the term <i>intended path</i>, it means the
  <code><a href="#path2d">Path2D</a></code> argument, if one was provided, or the <a href="#current-default-path">current default path</a>
  otherwise.</p>

  <p>When the intended path is a <code><a href="#path2d">Path2D</a></code> object, the coordinates and lines of its
  subpaths must be transformed according to the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object's <a data-anolis-xref="dom-context-2d-transformation" href="#transformations">current transformation matrix</a> when used by these
  methods (without affecting the <code><a href="#path2d">Path2D</a></code> object itself). When the intended path is the
  <a href="#current-default-path">current default path</a>, it is not affected by the transform. (This is because
  transformations already affect the <a href="#current-default-path">current default path</a> when it is constructed, so
  applying it when it is painted as well would result in a double transformation.)</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-fill" id="dom-context-2d-fill"><code>fill()</code></dfn> method must fill all the
  subpaths of the intended path, using <code data-anolis-xref="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code>, and
  using the <a href="#fill-rule">fill rule</a> indicated by the <var data-anolis-xref="">fillRule</var> argument. Open
  subpaths must be implicitly closed when being filled (without affecting the actual subpaths).</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-stroke" id="dom-context-2d-stroke"><code>stroke()</code></dfn> method must <a data-anolis-xref="trace a path" href="#trace-a-path">trace</a> the intended path, using the
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object for the line styles, and then fill the resulting path
  using the <code data-anolis-xref="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code> attribute, using the <a data-anolis-xref="dom-context-2d-fillRule-nonzero" href="#dom-context-2d-fillrule-nonzero">non-zero winding rule</a>.</p>

  <p class="note">As a result of how the algorithm to <a href="#trace-a-path">trace a path</a> is defined,
  overlapping parts of the paths in one stroke operation are treated as if their union was what was
  painted.</p>

  <p class="note">The stroke <em>style</em> is affected by the transformation during painting, even
  if the intended path is the <a href="#current-default-path">current default path</a>.</p>

  <p>Paths, when filled or stroked, must be painted without affecting the <a href="#current-default-path">current default
  path</a> or any <code><a href="#path2d">Path2D</a></code> objects, and must be subject to <a data-anolis-xref="shadows" href="#shadows">shadow effects</a>, <a data-anolis-xref="dom-context-2d-globalAlpha" href="#dom-context-2d-globalalpha">global
  alpha</a>, the <a href="#clipping-region">clipping region</a>, and <a data-anolis-xref="dom-context-2d-globalCompositeOperation" href="#dom-context-2d-globalcompositeoperation">global composition operators</a>. (The effect
  of transformations is described above and varies based on which path is being used.)</p>

  <hr>
<!-- START w3c-html-->
  <p id="dom-context-2d-drawosfocusring">The <dfn data-anolis-xref="dom-context-2d-drawFocusIfNeeded" id="dom-context-2d-drawfocusifneeded"><code>drawFocusIfNeeded(<var data-anolis-xref="">element</var>)</code></dfn> method, when invoked, must run the following steps:</p>

  <ol>
   <li><p>If the current path has zero subpaths, then abort these steps.</p></li> 
   <li><p>If <var data-anolis-xref="">element</var> is not focused or is not a descendant of the element with
   whose context the method is associated, then abort these steps.</p></li>

   <li>

    <p>If the user has requested the use of particular focus outline (e.g. high-contrast focus outlines),
    or if the <var data-anolis-xref="">element</var> would have a focus outline drawn around it, then draw a focus
    outline of the appropriate style along the intended path, following platform conventions.</p>

    <p class="note">Some platforms only draw focus outlines around elements that have been focused from
    the keyboard, and not those focused from the mouse. Other platforms simply don't draw focus
    outlines around some elements at all unless relevant accessibility features are enabled. This API
    is intended to follow these conventions. User agents that implement distinctions based on the
    manner in which the element was focused are encouraged to classify focus driven by the <code data-anolis-xref="dom-focus">focus()</code> method based on the kind of user interaction event from which
    the call was triggered (if any).</p>

    <p>The focus outline should not be subject to the <a data-anolis-xref="shadows" href="#shadows">shadow effects</a>, the
    <a data-anolis-xref="dom-context-2d-globalAlpha" href="#dom-context-2d-globalalpha">global alpha</a>, the <a data-anolis-xref="dom-context-2d-globalCompositeOperation" href="#dom-context-2d-globalcompositeoperation">global composition operators</a>, the <code data-anolis-xref="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code> attribute, the <code data-anolis-xref="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code> attribute, or any of the
    <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> members, but <em>should</em> be subject to the <a href="#clipping-region">clipping
    region</a>. (The effect of transformations is described above and varies based on which path
    is being used.) When the focus area is clipped by the canvas element, only the visual representation of the focus outline is clipped to the clipping region. </p>
	<p>If the focus area is not on the screen, then scroll the focus outline into view by aligning it to the top when it receives focus.</p>
   </li>
   
   <li>

    <p>Optionally, run the appropriate step from the following list:</p>

    <dl>

     <dt>If the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object's <span data-anolis-xref="concept-canvas-context-bitmap-mode">context bitmap mode</span> is <span data-anolis-xref="concept-canvas-fixed">fixed</span></dt>

     <dd><a href="#inform">Inform the user</a> of the location 
	given by the path. The full location 
	of the corresponding fallback element is passed to the
	accessibility API, if supported. User agents may wait until the next 
	time the <span>event loop</span> reaches its "update the 
	rendering" step to inform the user. <p></p></dd>

     <dt>Otherwise</dt>

     <dd><p>Add instructions to the <a href="#scratch-bitmap">scratch bitmap</a>'s <a href="#list-of-pending-interface-actions">list of pending interface
     actions</a> that <a href="#inform">inform the user</a> that the focus is at the location of
     the bitmap given by the intended path.</p></dd>

    </dl>

   </li>

  </ol>
    <p class="note" id="inform">"Inform the user", as used in this
  section, could mean calling a system accessibility API, which would
  notify assistive technologies such as magnification tools. To
  properly drive magnification based on a focus change, a system
  accessibility API driving a screen magnifier needs the bounds for
  the newly focused object. The methods above are intended to enable
  this by allowing the user agent to report the bounding box of the
  path used to render the focus outline as the bounds of the <var title="">element</var> element passed as an argument, if that
  element is focused, and the bounding box of the area to which the
  user agent is scrolling as the bounding box of the current
  selection.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-drawCustomFocusRing" id="dom-context-2d-drawcustomfocusring"><code>drawCustomFocusRing(<var data-anolis-xref="">element</var>)</code></dfn> method, when invoked, must run the following steps:</p>

  <ol>
   <li><p>If the current path has zero subpaths, then abort these steps.</p></li> 
   <li><p>If <var data-anolis-xref="">element</var> is not focused or is not a descendant of the element with
   whose context the method is associated, then return false and abort these steps.</p></li>

   <li><p>Let <var data-anolis-xref="">result</var> be true.</p></li>

   <li>

    <p>If the user has requested the use of particular focus outlines (e.g. high-contrast focus outlines),
    then draw a focus outline of the appropriate style along the intended path, and set <var data-anolis-xref="">result</var> to false.</p>

    <p>The focus outline should not be subject to the <a data-anolis-xref="shadows" href="#shadows">shadow effects</a>, the
    <a data-anolis-xref="dom-context-2d-globalAlpha" href="#dom-context-2d-globalalpha">global alpha</a>, the <a data-anolis-xref="dom-context-2d-globalCompositeOperation" href="#dom-context-2d-globalcompositeoperation">global composition operators</a>, the <code data-anolis-xref="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code> attribute, the <code data-anolis-xref="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code> attribute, or any of the
    <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> members, but <em>should</em> be subject to the <a href="#clipping-region">clipping
    region</a>. (The effect of transformations is described above and varies based on which path
    is being used.)</p>

   </li>

   <li>

    <p>Optionally, run the appropriate step from the following list:</p>

    <dl>

     <dt>If the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object's <span data-anolis-xref="concept-canvas-context-bitmap-mode">context bitmap mode</span> is <span data-anolis-xref="concept-canvas-fixed">fixed</span></dt>

     <dd><p><a href="#inform">Inform the user</a> that the focus is at the location given by the
     intended path. The user agent may wait until the next time the <span>event loop</span> reaches
     its <i>update the rendering</i> step to optionally inform the user.</p></dd>

     <dt>Otherwise</dt>

     <dd><p>Add instructions to the <a href="#scratch-bitmap">scratch bitmap</a>'s <a href="#list-of-pending-interface-actions">list of pending interface
     actions</a> that <a href="#inform">inform the user</a> that the focus is at the location of
     the bitmap given by the intended path.</p></dd>

    </dl>

   </li>

   <li><p>Return <var data-anolis-xref="">result</var>.</p></li>

  </ol>

  <p>User agents should not implicitly close open subpaths in the intended path when drawing the
  focus outline.</p>

  <p class="note">This might be a moot point, however. For example, if the focus outline is drawn as an
  axis-aligned bounding rectangle around the points in the intended path, then whether the subpaths
  are closed or not has no effect. This specification intentionally does not specify precisely how
  focus outlines are to be drawn: user agents are expected to honor their platform's native
  conventions.</p>
<!-- END FORK w3c-html-->
  <hr>

  <p>The <dfn data-anolis-xref="dom-context-2d-scrollPathIntoView" id="dom-context-2d-scrollpathintoview"><code>scrollPathIntoView()</code></dfn>
  method, when invoked, if the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object's <span data-anolis-xref="concept-canvas-context-bitmap-mode">context bitmap mode</span> is <span data-anolis-xref="concept-canvas-fixed">fixed</span>, must run the following steps; and otherwise, must add
  instructions to the <a href="#scratch-bitmap">scratch bitmap</a>'s <a href="#list-of-pending-interface-actions">list of pending interface actions</a>
  that run the following steps:</p>

  <ol>

   <li><p>Let <var data-anolis-xref="">the specified rectangle</var> be the rectangle of the bounding box of
   the intended path.</p></li>

   <li><p>Let <var data-anolis-xref="">notional child</var> be a hypothetical element that is a rendered child
   of the <code>canvas</code> element whose dimensions are those of <var data-anolis-xref="">the specified
   rectangle</var>.</p></li>

   <li><p><span data-anolis-xref="scroll an element into view">Scroll <var data-anolis-xref="">notional child</var> into
   view</span> with the <var data-anolis-xref="">align to top flag</var> set.</p>

   </li><li><p>Optionally, <a href="#inform">inform the user</a> that the caret or selection (or both)
   cover <var data-anolis-xref="">the specified rectangle</var> of the canvas. If the
   <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object's <span data-anolis-xref="concept-canvas-context-bitmap-mode">context bitmap mode</span> was <span data-anolis-xref="concept-canvas-fixed">fixed</span> when the method was invoked, the user agent may wait
   until the next time the <span>event loop</span> reaches its <i>update the rendering</i> step to
   optionally inform the user.</p></li>

  </ol>

  <p>"Inform the user", as used in this section, does not imply any persistent state
  change. It could mean, for instance, calling a system accessibility API to notify assistive
  technologies such as magnification tools so that the user's magnifier moves to the given area of
  the canvas. However, it does not associate the path with the element, or provide a region for
  tactile feedback, etc. To persistently associate a region with information provided to
  accessibility tools, use the <code data-anolis-xref="dom-context-2d-addHitRegion"><a href="#dom-context-2d-addhitregion">addHitRegion()</a></code>
  API.</p>

  <hr>

  <p>The <dfn data-anolis-xref="dom-context-2d-clip" id="dom-context-2d-clip"><code>clip()</code></dfn> method must create a new
  <dfn id="clipping-region">clipping region</dfn> by calculating the intersection of the current clipping region and the
  area described by the intended path, using the <a href="#fill-rule">fill rule</a> indicated by the <var data-anolis-xref="">fillRule</var> argument. Open subpaths must be implicitly closed when computing the
  clipping region, without affecting the actual subpaths. The new clipping region replaces the
  current clipping region.</p>

  <p>When the context is initialized, the clipping region must be set to the largest infinite
  surface (i.e. by default, no clipping occurs).</p>

  <!-- v6
   Jordan OSETE suggests:
    * support ways of extending the clipping region (union instead of intersection)
       - also "add", "subtract", "replace", "intersect" and "xor"
       - maybe just support creating unions, intersections, and other -ions of paths
  -->

  <p>The <dfn data-anolis-xref="dom-context-2d-resetClip" id="dom-context-2d-resetclip"><code>resetClip()</code></dfn> method must create a
  new <a href="#clipping-region">clipping region</a> that is the largest infinite surface. The new clipping region
  replaces the current clipping region.</p>

  <hr>

  <p>The <dfn data-anolis-xref="dom-context-2d-isPointInPath" id="dom-context-2d-ispointinpath"><code>isPointInPath()</code></dfn> method must
  return true if the point given by the <var data-anolis-xref="">x</var> and <var data-anolis-xref="">y</var> coordinates
  passed to the method, when treated as coordinates in the canvas coordinate space unaffected by the
  current transformation, is inside the intended path as determined by the <a href="#fill-rule">fill rule</a>
  indicated by the <var data-anolis-xref="">fillRule</var> argument; and must return false otherwise. Open
  subpaths must be implicitly closed when computing the area inside the path, without affecting the
  actual subpaths. Points on the path itself must be considered to be inside the path. If either of
  the arguments is infinite or NaN, then the method must return false.</p>

  <hr>

  <p>The <dfn data-anolis-xref="dom-context-2d-isPointInStroke" id="dom-context-2d-ispointinstroke"><code>isPointInStroke()</code></dfn> method
  must return true if the point given by the <var data-anolis-xref="">x</var> and <var data-anolis-xref="">y</var>
  coordinates passed to the method, when treated as coordinates in the canvas coordinate space
  unaffected by the current transformation, is inside the path that results from <a data-anolis-xref="trace
  a path" href="#trace-a-path">tracing</a> the intended path, using the <a data-anolis-xref="dom-context-2d-fillRule-nonzero" href="#dom-context-2d-fillrule-nonzero">non-zero winding rule</a>, and using the
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object for the line styles; and must return false otherwise.
  Points on the resulting path must be considered to be inside the path. If either of the arguments
  is infinite or NaN, then the method must return false.</p>

  <hr>

  </div>

  <div class="example" id="drawCustomFocusRingExample">

   <p>This <code>canvas</code> element has a couple of checkboxes. The path-related commands are
   highlighted:</p>

   <pre>&lt;canvas height=400 width=750&gt;
 &lt;label&gt;&lt;input type=checkbox id=showA&gt; Show As&lt;/label&gt;
 &lt;label&gt;&lt;input type=checkbox id=showB&gt; Show Bs&lt;/label&gt;
 &lt;!-- ... --&gt;
&lt;/canvas&gt;
&lt;script&gt;
 function drawCheckbox(context, element, x, y, paint) {
   context.save();
   context.font = '10px sans-serif';
   context.textAlign = 'left';
   context.textBaseline = 'middle';
   var metrics = context.measureText(element.labels[0].textContent);
   if (paint) {
<strong>     context.beginPath();
     context.strokeStyle = 'black';
     context.rect(x-5, y-5, 10, 10);
     context.stroke();
     context.addHitRegion({ control: element });
</strong>     if (element.checked) {
<strong>       context.fillStyle = 'black';
       context.fill();
</strong>     }
     context.fillText(element.labels[0].textContent, x+5, y);
   }
<strong>   context.beginPath();
   context.rect(x-7, y-7, 12 + metrics.width+2, 14);
   if (paint &amp;&amp; context.drawCustomFocusRing(element)) {
     context.strokeStyle = 'silver';
     context.stroke();
   }
</strong>   context.restore();
 }
 function drawBase() { /* ... */ }
 function drawAs() { /* ... */ }
 function drawBs() { /* ... */ }
 function redraw() {
   var canvas = document.getElementsByTagName('canvas')[0];
   var context = canvas.getContext('2d');
   context.clearRect(0, 0, canvas.width, canvas.height);
   drawCheckbox(context, document.getElementById('showA'), 20, 40, true);
   drawCheckbox(context, document.getElementById('showB'), 20, 60, true);
   drawBase();
   if (document.getElementById('showA').checked)
     drawAs();
   if (document.getElementById('showB').checked)
     drawBs();
 }
 function processClick(event) {
   var canvas = document.getElementsByTagName('canvas')[0];
   var context = canvas.getContext('2d');
   var x = event.clientX;
   var y = event.clientY;
   var node = event.target;
   while (node) {
     x -= node.offsetLeft - node.scrollLeft;
     y -= node.offsetTop - node.scrollTop;
     node = node.offsetParent;
   }
   drawCheckbox(context, document.getElementById('showA'), 20, 40, false);
   if (<strong>context.isPointInPath(x, y)</strong>)
     document.getElementById('showA').checked = !(document.getElementById('showA').checked);
   drawCheckbox(context, document.getElementById('showB'), 20, 60, false);
   if (<strong>context.isPointInPath(x, y)</strong>)
     document.getElementById('showB').checked = !(document.getElementById('showB').checked);
   redraw();
 }
 document.getElementsByTagName('canvas')[0].addEventListener('focus', redraw, true);
 document.getElementsByTagName('canvas')[0].addEventListener('blur', redraw, true);
 document.getElementsByTagName('canvas')[0].addEventListener('change', redraw, true);
 document.getElementsByTagName('canvas')[0].addEventListener('click', processClick, false);
 redraw();
&lt;/script&gt;</pre>
<!-- http://software.hixie.ch/utilities/js/live-dom-viewer/saved/340 -->

  </div>



  <h6 id="drawing-images"><span class="secno">1.1.14 </span>Drawing images</h6>

  <p>To draw images, the <dfn data-anolis-xref="dom-context-2d-drawImage" id="dom-context-2d-drawimage"><code>drawImage</code></dfn> method
  can be used.</p>

  <div class="impl">

  <p>This method can be invoked with three different sets of arguments:</p>

  <ul class="brief">
   <li><code data-anolis-xref="">drawImage(<var data-anolis-xref="">image</var>, <var data-anolis-xref="">dx</var>, <var data-anolis-xref="">dy</var>)</code>
   </li><li><code data-anolis-xref="">drawImage(<var data-anolis-xref="">image</var>, <var data-anolis-xref="">dx</var>, <var data-anolis-xref="">dy</var>, <var data-anolis-xref="">dw</var>, <var data-anolis-xref="">dh</var>)</code>
   </li><li><code data-anolis-xref="">drawImage(<var data-anolis-xref="">image</var>, <var data-anolis-xref="">sx</var>, <var data-anolis-xref="">sy</var>, <var data-anolis-xref="">sw</var>, <var data-anolis-xref="">sh</var>, <var data-anolis-xref="">dx</var>, <var data-anolis-xref="">dy</var>, <var data-anolis-xref="">dw</var>, <var data-anolis-xref="">dh</var>)</code>
  </li></ul>

  </div>

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-drawImage"><a href="#dom-context-2d-drawimage">drawImage</a></code>(<var data-anolis-xref="">image</var>, <var data-anolis-xref="">dx</var>, <var data-anolis-xref="">dy</var>)</dt>
   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-drawImage"><a href="#dom-context-2d-drawimage">drawImage</a></code>(<var data-anolis-xref="">image</var>, <var data-anolis-xref="">dx</var>, <var data-anolis-xref="">dy</var>, <var data-anolis-xref="">dw</var>, <var data-anolis-xref="">dh</var>)</dt>
   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-drawImage"><a href="#dom-context-2d-drawimage">drawImage</a></code>(<var data-anolis-xref="">image</var>, <var data-anolis-xref="">sx</var>, <var data-anolis-xref="">sy</var>, <var data-anolis-xref="">sw</var>, <var data-anolis-xref="">sh</var>, <var data-anolis-xref="">dx</var>, <var data-anolis-xref="">dy</var>, <var data-anolis-xref="">dw</var>, <var data-anolis-xref="">dh</var>)</dt>

   <dd>

    <p>Draws the given image onto the canvas. The arguments are
    interpreted as follows:</p>

    <p><img alt="The sx and sy parameters give the x and y coordinates of the source rectangle; the sw and sh arguments give the width and height of the source rectangle; the dx and dy give the x and y coordinates of the destination rectangle; and the dw and dh arguments give the width and height of the destination rectangle." height="356" src="images/drawImage.png" width="356"></p>

    <p>If the image isn't yet fully decoded, then nothing is drawn. If the image is a canvas with no
    data, throws an <code>InvalidStateError</code> exception.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>When the <code data-anolis-xref="dom-context-2d-drawImage"><a href="#dom-context-2d-drawimage">drawImage()</a></code> method is invoked, the user
  agent must run the following steps:</p>

  <ol>

   <li><p><a href="#check-the-usability-of-the-image-argument">Check the usability of the <var data-anolis-xref="">image</var> argument</a>. If this
   returns <i>aborted</i>, then an exception has been thrown and the method doesn't return anything;
   abort these steps. If it returns <i>bad</i>, then abort these steps without drawing anything.
   Otherwise it returns <i>good</i>; continue with these steps.</p></li>

   <li>

    <p>Establish the source and destination rectangles as follows:</p>

    <p>If not specified, the <var data-anolis-xref="">dw</var> and <var data-anolis-xref="">dh</var> arguments must
    default to the values of <var data-anolis-xref="">sw</var> and <var data-anolis-xref="">sh</var>, interpreted such
    that one CSS pixel in the image is treated as one unit in the <a href="#scratch-bitmap">scratch bitmap</a>'s
    coordinate space. If the <var data-anolis-xref="">sx</var>, <var data-anolis-xref="">sy</var>, <var data-anolis-xref="">sw</var>,
    and <var data-anolis-xref="">sh</var> arguments are omitted, they must default to 0, 0, the image's
    intrinsic width in image pixels, and the image's intrinsic height in image pixels, respectively.
    If the image has no intrinsic dimensions, the <i>concrete object size</i> must be used instead,
    as determined using the CSS "<a href="http://dev.w3.org/csswg/css3-images/#default-sizing">Concrete Object Size Resolution</a>"
    algorithm, with the <i>specified size</i> having neither a definite width nor height, nor any
    additional contraints, the object's intrinsic properties being those of the <var data-anolis-xref="">image</var> argument, and the <i>default object size</i> being the size of the
    <a href="#scratch-bitmap">scratch bitmap</a>. <a href="#refsCSSIMAGES">[CSSIMAGES]</a></p>

    <p>The source rectangle is the rectangle whose corners are the four points (<var data-anolis-xref="">sx</var>, <var data-anolis-xref="">sy</var>), (<span data-anolis-xref=""><var data-anolis-xref="">sx</var>+<var data-anolis-xref="">sw</var></span>, <var data-anolis-xref="">sy</var>), (<span data-anolis-xref=""><var data-anolis-xref="">sx</var>+<var data-anolis-xref="">sw</var></span>, <span data-anolis-xref=""><var data-anolis-xref="">sy</var>+<var data-anolis-xref="">sh</var></span>),
    (<var data-anolis-xref="">sx</var>, <span data-anolis-xref=""><var data-anolis-xref="">sy</var>+<var data-anolis-xref="">sh</var></span>).</p>

    <p>The destination rectangle is the rectangle whose corners are the four points (<var data-anolis-xref="">dx</var>, <var data-anolis-xref="">dy</var>), (<span data-anolis-xref=""><var data-anolis-xref="">dx</var>+<var data-anolis-xref="">dw</var></span>, <var data-anolis-xref="">dy</var>), (<span data-anolis-xref=""><var data-anolis-xref="">dx</var>+<var data-anolis-xref="">dw</var></span>, <span data-anolis-xref=""><var data-anolis-xref="">dy</var>+<var data-anolis-xref="">dh</var></span>),
    (<var data-anolis-xref="">dx</var>, <span data-anolis-xref=""><var data-anolis-xref="">dy</var>+<var data-anolis-xref="">dh</var></span>).</p>

    <p>When the source rectangle is outside the source image, the source rectangle must be clipped
    to the source image and the destination rectangle must be clipped in the same proportion.</p>

    <p class="note">When the destination rectangle is outside the destination image (the
    <a href="#scratch-bitmap">scratch bitmap</a>), the pixels that land outside the <a href="#scratch-bitmap">scratch bitmap</a> are
    discarded, as if the destination was an infinite canvas whose rendering was clipped to the
    dimensions of the <a href="#scratch-bitmap">scratch bitmap</a>.</p>

   </li>

   <li><p>If one of the <var data-anolis-xref="">sw</var> or <var data-anolis-xref="">sh</var> arguments is zero, abort
   these steps. Nothing is painted.</p></li>

   <li>

    <p>Paint the region of the <var data-anolis-xref="">image</var> argument specified by the source rectangle
    on the region of the rendering context's <a href="#scratch-bitmap">scratch bitmap</a> specified by the
    destination rectangle, after applying the <a data-anolis-xref="dom-context-2d-transformation" href="#transformations">current
    transformation matrix</a> to the destination rectangle.</p>

    <p>The image data must be processed in the original direction, even if the dimensions given are
    negative. <!-- note: that last sentence has several times been needed to correct people who
    suggested that 5,5,-2,-2 was different than 3,3,2,2 --></p>

    <p>When scaling up, if the <code data-anolis-xref="dom-context-2d-imageSmoothingEnabled"><a href="#dom-context-2d-imagesmoothingenabled">imageSmoothingEnabled</a></code> attribute is set to
    true, the user agent should attempt to apply a smoothing algorithm to the image data when it is
    scaled. Otherwise, the image must be rendered using nearest-neighbor interpolation.</p>

    <p class="note">This specification does not define the precise algorithm to use when scaling an
    image down, or when scaling an image up when the <code data-anolis-xref="dom-context-2d-imageSmoothingEnabled"><a href="#dom-context-2d-imagesmoothingenabled">imageSmoothingEnabled</a></code> attribute is set to
    true.</p>

    <p class="note">When a <code>canvas</code> or <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object is
    drawn onto itself, the <a href="#drawing-model">drawing model</a> requires the source to be copied before the
    image is drawn, so it is possible to copy parts of a <code>canvas</code> or <a href="#scratch-bitmap">scratch
    bitmap</a> onto overlapping parts of itself.</p>

    <p>If the original image data is a bitmap image, the value painted at a point in the destination
    rectangle is computed by filtering the original image data. The user agent may use any filtering
    algorithm (for example bilinear interpolation or nearest-neighbor). When the filtering algorithm
    requires a pixel value from outside the original image data, it must instead use the value from
    the nearest edge pixel. (That is, the filter uses 'clamp-to-edge' behavior.) When the filtering
    algorithm requires a pixel value from outside the source rectangle but inside the original image
    data, then the value from the original image data must be used.</p>
    <!-- see CORE-32111 and:
         http://krijnhoetmer.nl/irc-logs/whatwg/20100818#l-737
         http://www.w3.org/Bugs/Public/show_bug.cgi?id=10799#c11
    -->
    <!-- createPattern() has a similar paragraph with different rules -->

    <p class="note">Thus, scaling an image in parts or in whole will have the same effect. This does
    mean that when sprites coming from a single sprite sheet are to be scaled, adjacent images in
    the sprite sheet can interfere. This can be avoided by ensuring each sprite in the sheet is
    surrounded by a border of transparent black, or by copying sprites to be scaled into temporary
    <code>canvas</code> elements and drawing the scaled sprites from there.</p>

    <p>Images are painted without affecting the current path, and are subject to <a data-anolis-xref="shadows" href="#shadows">shadow effects</a>, <a data-anolis-xref="dom-context-2d-globalAlpha" href="#dom-context-2d-globalalpha">global
    alpha</a>, the <a href="#clipping-region">clipping region</a>, and <a data-anolis-xref="dom-context-2d-globalCompositeOperation" href="#dom-context-2d-globalcompositeoperation">global composition operators</a>.</p>

   </li>

<!--ADD-TOPIC:Security-->
   <li><p>If <a href="#the-image-argument-is-not-origin-clean">the <var data-anolis-xref="">image argument</var> is not origin-clean</a>, set the
   <a href="#scratch-bitmap">scratch bitmap</a>'s <span data-anolis-xref="concept-canvas-origin-clean">origin-clean</span> flag
   to false.</p></li>
<!--REMOVE-TOPIC:Security-->

  </ol>

  </div>


  <h6 id="hit-regions"><span class="secno">1.1.15 </span>Hit regions</h6>

  <p>A <dfn id="hit-region-list">hit region list</dfn> is a list of <a data-anolis-xref="hit region" href="#hit-region">hit regions</a> for a
  bitmap.</p>

  <p>Each <dfn id="hit-region">hit region</dfn> consists of the following information:</p>

  <ul>

   <li><p>A <dfn data-anolis-xref="hit region's set of pixels" id="hit-region's-set-of-pixels">set of pixels</dfn> on the bitmap for which this
   region is responsible.</p></li>

   <li><p>A <dfn data-anolis-xref="hit region's bounding circumference" id="hit-region's-bounding-circumference">bounding circumference</dfn> on the
   bitmap that surrounds the <a href="#hit-region's-set-of-pixels">hit region's set of pixels</a> as they stood when it was
   created.</p></li>

   <li><p>Optionally, a non-empty string representing an <dfn data-anolis-xref="hit region's ID" id="hit-region's-id">ID</dfn> for
   distinguishing the region from others.</p></li> <!-- cannot be the empty string -->

   <li><p>Optionally, a reference to another region that acts as the <dfn data-anolis-xref="hit region's
   parent" id="hit-region's-parent">parent</dfn> for this one.</p></li>

   <li><p>A count of regions that have this one as their <a data-anolis-xref="hit region's
   parent" href="#hit-region's-parent">parent</a>, known as the <dfn id="hit-region's-child-count">hit region's child count</dfn>.</p></li>

   <li><p>A <dfn data-anolis-xref="hit region's cursor specification" id="hit-region's-cursor-specification">cursor specification</dfn>, in the form
   of either a CSS cursor value, or the string "<code data-anolis-xref="">inherit</code>" meaning that the
   cursor of the <a href="#hit-region's-parent">hit region's parent</a>, if any, or of the <code>canvas</code> element, if
   not, is to be used instead.</p></li>

   <li>

    <p>Optionally, either a <a data-anolis-xref="hit region's control" href="#hit-region's-control">control</a>, or an <a data-anolis-xref="hit region's unbacked region description" href="#hit-region's-unbacked-region-description">unbacked region description</a>.</p>

    <p>A <dfn data-anolis-xref="hit region's control" id="hit-region's-control">control</dfn> is a reference to an <code>Element</code>
    node, to which, in certain conditions, the user agent will route events, and from which the user
    agent will determine the state of the hit region for the purposes of accessibility tools. (The
    control is ignored when it is not a descendant of the <code>canvas</code> element.)</p>

    <p>An <dfn data-anolis-xref="hit region's unbacked region description" id="hit-region's-unbacked-region-description">unbacked region description</dfn>
    consists of the following:</p>

    <ul class="brief">

     <li><p>Optionally, a <dfn data-anolis-xref="hit region's label" id="hit-region's-label">label</dfn>.</p>

     </li><li><p>An <dfn data-anolis-xref="hit region's ARIA role" id="hit-region's-aria-role">ARIA role</dfn>, which, if the <a data-anolis-xref="hit
     region's unbacked region description" href="#hit-region's-unbacked-region-description">unbacked region description</a> also has a label,
     could be the empty string.</p></li>

    </ul>

   </li>

  </ul>

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-addHitRegion"><a href="#dom-context-2d-addhitregion">addHitRegion</a></code>(<var data-anolis-xref="">options</var>)</dt>

   <dd>

    <p>Adds a hit region to the bitmap. The argument is an object with the following members:</p>

    <dl>

     <dt><dfn data-anolis-xref="dom-HitRegionOptions-path" id="dom-hitregionoptions-path"><code>path</code></dfn> (default null)</dt>

     <dd>A <code><a href="#path2d">Path2D</a></code> object that describes the pixels that form part of the region. If
     this member is not provided or is set to null, the <a href="#current-default-path">current default path</a> is used
     instead.</dd>

     <dt><dfn data-anolis-xref="dom-HitRegionOptions-fillRule" id="dom-hitregionoptions-fillrule"><code>fillRule</code></dfn> (default "<code data-anolis-xref="dom-context-2d-fillRule-nonzero"><a href="#dom-context-2d-fillrule-nonzero">nonzero</a></code>")</dt>

     <dd>The <a href="#fill-rule">fill rule</a> to use when determining which pixels are inside the path.</dd>

<!--
     <dt><dfn data-x="dom-HitRegionOptions-transform"><code>transform</code></dfn> (default null)</dt>

     <dd>An <code>SVGMatrix</code> object that describes a
     transformation to apply to the path described by the <code
     data-x="dom-HitRegionOptions-path">path</code> member.</dd>
-->

     <dt><dfn data-anolis-xref="dom-HitRegionOptions-id" id="dom-hitregionoptions-id"><code>id</code></dfn> (default empty string) <!-- empty string is treated as null internally --></dt>

     <dd>The ID to use for this region. This is used in <code>MouseEvent</code> events on the
     <code>canvas</code> (<code data-anolis-xref="dom-MouseEvent-region"><a href="#dom-mouseevent-region">event.region</a></code>) and as a way to
     reference this region in later calls to <code data-anolis-xref="dom-context-2d-addHitRegion"><a href="#dom-context-2d-addhitregion">addHitRegion()</a></code>.</dd>

     <dt><dfn data-anolis-xref="dom-HitRegionOptions-parentID" id="dom-hitregionoptions-parentid"><code>parentID</code></dfn> (default null)</dt>

     <dd>The ID of the parent region, for purposes of navigation by accessibility tools and for
     cursor fallback.</dd>

     <dt><dfn data-anolis-xref="dom-HitRegionOptions-cursor" id="dom-hitregionoptions-cursor"><code>cursor</code></dfn> (default "<code data-anolis-xref="">inherit</code>")</dt>

     <dd>The cursor to use when the mouse is over this region. The value "<code data-anolis-xref="">inherit</code>" means to use the cursor for the parent region (as specified by the
     <code data-anolis-xref="dom-HitRegionOptions-parentID"><a href="#dom-hitregionoptions-parentid">parentID</a></code> member), if any, or to use the
     <code>canvas</code> element's cursor if the region has no parent.</dd>

     <dt><dfn data-anolis-xref="dom-HitRegionOptions-control" id="dom-hitregionoptions-control"><code>control</code></dfn> (default null)</dt>

     <dd>An element (that is a descendant of the <code>canvas</code>) to which events are to be
     routed, and which accessibility tools are to use as a surrogate for describing and interacting
     with this region.</dd>

     <dt><dfn data-anolis-xref="dom-HitRegionOptions-label" id="dom-hitregionoptions-label"><code>label</code></dfn> (default null)</dt>

     <dd>A text label for accessibility tools to use as a description of this region, if there is no
     control.</dd>

     <dt><dfn data-anolis-xref="dom-HitRegionOptions-role" id="dom-hitregionoptions-role"><code>role</code></dfn> (default null)</dt>

     <dd>An ARIA role for accessibility tools to use to determine how to represent this region, if
     there is no control.</dd>

    </dl>

    <p>Hit regions can be used for a variety of purposes:</p>

    <ul>

     <li>With an ID, they can make hit detection easier by having the user agent check which region
     the mouse is over and include the ID in the mouse events.</li>

     <li>With a control, they can make routing events to DOM elements automatic, allowing e.g.
     clicks on a <code>canvas</code> to automatically submit a form via a <code>button</code>
     element.</li>

     <li>With a label, they can make it easier for users to explore a <code>canvas</code> without
     seeing it, e.g. by touch on a mobile device.</li>

     <li>With a cursor, they can make it easier for different regions of the <code>canvas</code> to
     have different cursors, with the user agent automatically switching between them.</li>

    </ul>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-removeHitRegion"><a href="#dom-context-2d-removehitregion">removeHitRegion</a></code>(<var data-anolis-xref="">id</var>)</dt>

   <dd>

    <p>Removes a hit region (and all its descendants) from the canvas bitmap. The argument is the ID
    of a region added using <code data-anolis-xref="dom-context-2d-addHitRegion"><a href="#dom-context-2d-addhitregion">addHitRegion()</a></code>.</p>

    <p>The pixels that were covered by this region and its descendants are effectively cleared by
    this operation, leaving the regions non-interactive. In particular, regions that occupied the
    same pixels before the removed regions were added, overlapping them, do not resume their
    previous role.</p>

   </dd>
   
   <dt><var title="">context</var> . <code title="dom-context-2d-clearHitRegions"><a href="#dom-context-2d-clearhitregions">
	clearHitRegions</a></code>()</dt>

   <dd>

   <p>Removes all hit regions from the canvas
   bitmap. </p>
   
   <p>The paths that were covered by these regions are effectively 
   cleared by this operation, leaving all regions
   non-interactive. </p>

   </dd>
   
  </dl>

  <div class="impl">

  <p>A <a href="#hit-region">hit region</a> <var data-anolis-xref="">A</var> is an <dfn id="ancestor-region">ancestor region</dfn> of a <a href="#hit-region">hit
  region</a> <var data-anolis-xref="">B</var> if <var data-anolis-xref="">B</var> has a <a data-anolis-xref="hit region's
  parent" href="#hit-region's-parent">parent</a> and its <a data-anolis-xref="hit region's parent" href="#hit-region's-parent">parent</a> is either <var data-anolis-xref="">A</var> or another <a href="#hit-region">hit region</a> for which <var data-anolis-xref="">A</var> is an
  <a href="#ancestor-region">ancestor region</a>.</p>

  <p><dfn id="the-region-identified-by-the-id">The region identified by the ID</dfn> <var data-anolis-xref="">ID</var> in a bitmap <var data-anolis-xref="">bitmap</var> is the value returned by the following algorithm (which can return a
  <a href="#hit-region">hit region</a> or nothing):</p>

  <ol>

   <li><p>If <var data-anolis-xref="">ID</var> is null, return nothing and abort these steps.</p></li> <!--
   this step is redundant but makes sure people don't confuse 'null' for 'not having an ID' -->

   <li><p>Let <var data-anolis-xref="">list</var> be the <a href="#hit-region-list">hit region list</a> associated with <var data-anolis-xref="">bitmap</var>.</p></li>

   <li><p>If there is a <a href="#hit-region">hit region</a> in <var data-anolis-xref="">list</var> whose <a data-anolis-xref="hit
   region's ID" href="#hit-region's-id">ID</a> is a <span>case-sensitive</span> match for <var data-anolis-xref="">ID</var>, then
   return that <a href="#hit-region">hit region</a> and abort these steps.</p></li>

   <li><p>Otherwise, return nothing.</p></li>

  </ol>

  <p><dfn id="the-region-representing-the-control">The region representing the control</dfn> <var data-anolis-xref="">control</var> for a bitmap <var data-anolis-xref="">bitmap</var> is the value returned by the following algorithm (which can return a
  <a href="#hit-region">hit region</a> or nothing):</p>

  <ol>

   <li><p>Let <var data-anolis-xref="">list</var> be the <a href="#hit-region-list">hit region list</a> associated with <var data-anolis-xref="">bitmap</var>.</p></li>

   <li><p>If there is a <a href="#hit-region">hit region</a> in <var data-anolis-xref="">list</var> whose <a data-anolis-xref="hit
   region's control" href="#hit-region's-control">control</a> is <var data-anolis-xref="">control</var>, then return that <a href="#hit-region">hit
   region</a> and abort these steps.</p></li>

   <li><p>Otherwise, return nothing.</p></li>

  </ol>

  <p><dfn id="the-control-represented-by-a-region">The control represented by a region</dfn> <var data-anolis-xref="">region</var> for a
  <code>canvas</code> element <var data-anolis-xref="">ancestor</var> is the value returned by the following
  algorithm (which can return an element or nothing):</p>

  <ol>

   <li><p>If <var data-anolis-xref="">region</var> has no <a data-anolis-xref="hit region's control" href="#hit-region's-control">control</a>,
   return nothing and abort these steps.</p></li>

   <li><p>Let <var data-anolis-xref="">control</var> be <var data-anolis-xref="">region</var>'s <a data-anolis-xref="hit region's
   control" href="#hit-region's-control">control</a>.</p></li>

   <li><p>If <var data-anolis-xref="">control</var> is not a descendant of <var data-anolis-xref="">ancestor</var>, then
   return nothing and abort these steps.</p></li>

   <li><p>If <var data-anolis-xref="">control</var> is no longer a <a href="#supported-interactive-canvas-fallback-element">supported interactive canvas fallback
   element</a>, then return nothing and abort these steps.</p></li>

   <li><p>Otherwise, return <var data-anolis-xref="">control</var>.</p></li>

  </ol>

  <p><dfn id="the-cursor-for-a-hit-region">The cursor for a hit region</dfn> <var data-anolis-xref="">region</var> of a <code>canvas</code>
  element <var data-anolis-xref="">ancestor</var> is the value returned by the following algorithm:</p>

  <ol>

   <li><p><i>Loop</i>: If <var data-anolis-xref="">region</var> has a <a data-anolis-xref="hit region's cursor
   specification" href="#hit-region's-cursor-specification">cursor specification</a> other than "<code data-anolis-xref="">inherit</code>", then
   return that <a href="#hit-region's-cursor-specification">hit region's cursor specification</a> and abort these steps.</p></li>

   <li><p>If <var data-anolis-xref="">region</var> has a <a data-anolis-xref="hit region's parent" href="#hit-region's-parent">parent</a>, then
   let <var data-anolis-xref="">region</var> be that <a href="#hit-region's-parent">hit region's parent</a>, and return to the step
   labeled <i>loop</i>.</p></li>

   <li><p>Otherwise, return the used value of the 'cursor' property for the <code>canvas</code>
   element, if any; if there isn't one, return 'auto'. <a href="#refsCSSUI">[CSSUI]</a></p></li>

  </ol>

  <p><dfn id="the-region-for-a-pixel">The region for a pixel</dfn> <var data-anolis-xref="">pixel</var> on a bitmap <var data-anolis-xref="">bitmap</var> is the value returned by the following algorithm (which can return a
  <a href="#hit-region">hit region</a> or nothing):</p>

  <ol>

   <li><p>Let <var data-anolis-xref="">list</var> be the <a href="#hit-region-list">hit region list</a> associated with <var data-anolis-xref="">bitmap</var>.</p></li>

   <li><p>If there is a <a href="#hit-region">hit region</a> in <var data-anolis-xref="">list</var> whose <a data-anolis-xref="hit
   region's set of pixels" href="#hit-region's-set-of-pixels">set of pixels</a> contains <var data-anolis-xref="">pixel</var>, then return that
   <a href="#hit-region">hit region</a> and abort these steps.</p></li>

   <li><p>Otherwise, return nothing.</p></li>

  </ol>

  <p>To <dfn id="clear-regions-that-cover-the-pixels">clear regions that cover the pixels</dfn> <var data-anolis-xref="">pixels</var> on a bitmap <var data-anolis-xref="">bitmap</var>, the user agent must run the following steps:</p>

  <ol>

   <li><p>Let <var data-anolis-xref="">list</var> be the <a href="#hit-region-list">hit region list</a> associated with <var data-anolis-xref="">bitmap</var>.</p></li>

   <li><p>Remove all pixels in <var data-anolis-xref="">pixels</var> from the <a data-anolis-xref="hit region's set of
   pixels" href="#hit-region's-set-of-pixels">set of pixels</a> of each <a href="#hit-region">hit region</a> in <var data-anolis-xref="">list</var>.</p></li>

   <li><p><a href="#garbage-collect-the-regions">Garbage-collect the regions</a> of <var data-anolis-xref="">bitmap</var>.</p></li>

  </ol>

  <p>To <dfn id="garbage-collect-the-regions">garbage-collect the regions</dfn> of a bitmap <var data-anolis-xref="">bitmap</var>, the user
  agent must run the following steps:</p>

  <ol>

   <li><p>Let <var data-anolis-xref="">list</var> be the <a href="#hit-region-list">hit region list</a> associated with <var data-anolis-xref="">bitmap</var>.</p></li>

   <li><p><i>Loop</i>: Let <var data-anolis-xref="">victim</var> be the first <a href="#hit-region">hit region</a> in <var data-anolis-xref="">list</var> to have an empty <a data-anolis-xref="hit region's set of pixels" href="#hit-region's-set-of-pixels">set of
   pixels</a> and a zero <a data-anolis-xref="hit region's child count" href="#hit-region's-child-count">child count</a>, if any. If
   there is no such <a href="#hit-region">hit region</a>, abort these steps.</p></li>

   <li><p>If <var data-anolis-xref="">victim</var> has a <a data-anolis-xref="hit region's parent" href="#hit-region's-parent">parent</a>, then
   decrement that <a href="#hit-region's-child-count">hit region's child count</a> by one.</p></li>

   <li><p>Remove <var data-anolis-xref="">victim</var> from <var data-anolis-xref="">list</var>.</p></li>

   <li><p>Jump back to the step labeled <i>loop</i>.</p></li>

  </ol>

  <p class="note">Adding a new region and calling <code data-anolis-xref="dom-context-2d-clearRect"><a href="#dom-context-2d-clearrect">clearRect()</a></code> are the two ways this clearing algorithm can
  be invoked. The <a href="#hit-region-list">hit region list</a> itself is also reset when the rendering context is
  reset, e.g. when a <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object is bound to or unbound from a
  <code>canvas</code>, or when the dimensions of the bitmap are changed.</p>

  <hr>

  <p>An element is a <dfn id="supported-interactive-canvas-fallback-element">supported interactive canvas fallback element</dfn> if it is one of the
  following:</p>

  <ul class="brief">

   <li><p>an <code>a</code> element that <span>represents</span> a
   <span>hyperlink</span> and that does not have any <code>img</code> descendants</p></li>

   <li><p>a <code>button</code> element</p></li>

   <li><p>an <code>input</code> element whose <code data-anolis-xref="attr-input-type">type</code>
   attribute is in one of the <span data-anolis-xref="attr-input-type-checkbox">Checkbox</span> or <span data-anolis-xref="attr-input-type-radio">Radio Button</span> states</p></li>

   <li><p>an <code>input</code> element that is a <span data-anolis-xref="concept-button">button</span> but
   its <code data-anolis-xref="attr-input-type">type</code> attribute is not in the <span data-anolis-xref="attr-input-type-image">Image Button</span> state</p></li>

   <li><p>a <code>select</code> element with a <code data-anolis-xref="attr-select-multiple">multiple</code> attribute or a <span data-anolis-xref="concept-select-size">display size</span> greater than 1</p></li>

   <li><p>an <code>option</code> element that is in a <span data-anolis-xref="concept-select-option-list">list of options</span> of a <code>select</code> element
   with a <code data-anolis-xref="attr-select-multiple">multiple</code> attribute or a <span data-anolis-xref="concept-select-size">display size</span> greater than 1</p></li>

   <li><p>a <span>sorting interface <code>th</code> element</span></p></li>

   <li><p>an element that would not be <span>interactive content</span> except for having the
   <code data-anolis-xref="attr-tabindex">tabindex</code> attribute specified</p></li>

   <!-- so that people can do grids, like crosswords, yet let AT users select rows, or the
   entire table, to see the whole context -->
   <li><p>a non-<span data-anolis-xref="interactive content">interactive</span> <code>table</code>,
   <code>caption</code>, <code>thead</code>, <code>tbody</code>, <code>tfoot</code>,
   <code>tr</code>, <code>td</code>, or <code>th</code> element</p></li>

  </ul>

  <hr>

  <p>When the <dfn data-anolis-xref="dom-context-2d-addHitRegion" id="dom-context-2d-addhitregion"><code>addHitRegion()</code></dfn> method is
  invoked, the user agent must run the following steps:</p>

  <ol>

   <li><p>Let <var data-anolis-xref="">arguments</var> be the dictionary object provided as the method's
   argument.</p></li>

   <li><p>If the <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-path"><a href="#dom-hitregionoptions-path">path</a></code> member is not null, let <var data-anolis-xref="">source
   path</var> be the <code data-anolis-xref="dom-HitRegionOptions-path"><a href="#dom-hitregionoptions-path">path</a></code> member's value. Otherwise,
   let it be the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object's <a href="#current-default-path">current default
   path</a>.</p></li>

<!--
   <li><p>If the <var data-x="">arguments</var> object's <code
   data-x="dom-HitRegionOptions-path">path</code> member is null, but the <code
   data-x="dom-HitRegionOptions-transform">transform</code> member is not, then throw a
   <code>NotSupportedError</code> exception and abort these steps.</p></li>

   <li><p>Transform all the coordinates and lines in <var data-x="">source path</var> by the
   transform matrix given by the <var data-x="">arguments</var> object's <code
   data-x="dom-HitRegionOptions-transform">transform</code> member, if it is not null.</p></li>
-->

   <li><p>Transform all the coordinates and lines in <var data-anolis-xref="">source path</var> by the current
   transform matrix, if the <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-path"><a href="#dom-hitregionoptions-path">path</a></code> member is not null.</p></li>

   <li><p>Let <var data-anolis-xref="">specified pixels</var> be the pixels contained in <var data-anolis-xref="">source
   path</var>, using the <a href="#fill-rule">fill rule</a> indicated by the <code data-anolis-xref="dom-HitRegionOptions-fillRule"><a href="#dom-hitregionoptions-fillrule">fillRule</a></code> member.</p></li>

   <li><p>Remove from <var data-anolis-xref="">specified pixels</var> any pixels not contained within the
   <a href="#clipping-region">clipping region</a>.</p></li>

   <li><p>If the <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-id"><a href="#dom-hitregionoptions-id">id</a></code> member is the empty string, let it be null
   instead.</p></li>

   <li><p>If the <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-id"><a href="#dom-hitregionoptions-id">id</a></code> member is not null, then let <var data-anolis-xref="">previous
   region for this ID</var> be <a href="#the-region-identified-by-the-id">the region identified by the ID</a> given by the <code data-anolis-xref="dom-HitRegionOptions-id"><a href="#dom-hitregionoptions-id">id</a></code> member's value in this <a href="#scratch-bitmap">scratch bitmap</a>, if
   any. If the <code data-anolis-xref="dom-HitRegionOptions-id"><a href="#dom-hitregionoptions-id">id</a></code> member is null or no such region
   currently exists, let <var data-anolis-xref="">previous region for this ID</var> be null.</p></li>

   <li><p>If the <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-parentID"><a href="#dom-hitregionoptions-parentid">parentID</a></code> member is the empty string, let it be null
   instead.</p></li>

   <li><p>If the <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-parentID"><a href="#dom-hitregionoptions-parentid">parentID</a></code> member is not null, then let <var data-anolis-xref="">parent region</var> be <a href="#the-region-identified-by-the-id">the region identified by the ID</a> given by the <code data-anolis-xref="dom-HitRegionOptions-parentID"><a href="#dom-hitregionoptions-parentid">parentID</a></code> member's value in the <a href="#scratch-bitmap">scratch
   bitmap</a>, if any. If the <code data-anolis-xref="dom-HitRegionOptions-parentID"><a href="#dom-hitregionoptions-parentid">parentID</a></code> member
   is null or no such region currently exists, let <var data-anolis-xref="">parent region</var> be
   null.</p></li>

   <li><p>If the <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-label"><a href="#dom-hitregionoptions-label">label</a></code> member is the empty string, let it be null
   instead.</p></li>

   <li>

    <p>If any of the following conditions are met, throw a <code>NotSupportedError</code> exception
    and abort these steps.</p>

    <ul class="brief">

<!--
     <li><p>The <var data-x="">arguments</var> object's <code
     data-x="dom-HitRegionOptions-path">path</code> member is null, but its <code
     data-x="dom-HitRegionOptions-transform">transform</code> member is not.</p></li>
-->

     <li><p>The <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-control"><a href="#dom-hitregionoptions-control">control</a></code> and <code data-anolis-xref="dom-HitRegionOptions-label"><a href="#dom-hitregionoptions-label">label</a></code> members are both non-null.</p></li>

     <li><p>The <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-control"><a href="#dom-hitregionoptions-control">control</a></code> and <code data-anolis-xref="dom-HitRegionOptions-role"><a href="#dom-hitregionoptions-role">role</a></code> members are both non-null.</p></li>

     <li><p>The <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-role"><a href="#dom-hitregionoptions-role">role</a></code> member's value is the empty string, and the
     <code data-anolis-xref="dom-HitRegionOptions-label"><a href="#dom-hitregionoptions-label">label</a></code> member's value is either null or the
     empty string.</p></li>

     <li><p>The <var data-anolis-xref="">specified hit region</var> has no pixels.</p></li>

     <li><p>The <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-control"><a href="#dom-hitregionoptions-control">control</a></code> member is neither null nor a
     <a href="#supported-interactive-canvas-fallback-element">supported interactive canvas fallback element</a>.</p></li>

     <li><p>The <var data-anolis-xref="">parent region</var> is not null but has a <a data-anolis-xref="hit region's
     control" href="#hit-region's-control">control</a>.</p></li>

     <li><p>The <var data-anolis-xref="">previous region for this ID</var> is the same <a href="#hit-region">hit region</a> as
     the <var data-anolis-xref="">parent region</var>.</p></li>

     <li><p>The <var data-anolis-xref="">previous region for this ID</var> is an <a href="#ancestor-region">ancestor region</a>
     of the <var data-anolis-xref="">parent region</var>.</p></li>

    </ul>

   </li>

   <li><p>If the <code data-anolis-xref="dom-HitRegionOptions-parentID"><a href="#dom-hitregionoptions-parentid">parentID</a></code> member is not null but
   <var data-anolis-xref="">parent region</var> is null, then throw a <code>NotFoundError</code> exception and
   abort these steps.</p></li>

   <li>

    <p>If any of the following conditions are met, throw a <code>SyntaxError</code> exception and
    abort these steps.</p>

    <ul class="brief">

     <li>The <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-cursor"><a href="#dom-hitregionoptions-cursor">cursor</a></code> member is not null but is neither an
     <span>ASCII case-insensitive</span> match for the string "<code data-anolis-xref="">inherit</code>", nor a
     valid CSS 'cursor' property value. <a href="#refsCSSUI">[CSSUI]</a></li>

     <li>The <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-role"><a href="#dom-hitregionoptions-role">role</a></code> member is not null but its value is not an
     <span>ordered set of unique space-separated tokens</span> whose tokens are all
     <span>case-sensitive</span> matches for names of non-abstract WAI-ARIA roles. <a href="#refsARIA">[ARIA]</a></li>

    </ul>

   </li>

   <li>

    <p>Let <var data-anolis-xref="">region</var> be a newly created <a href="#hit-region">hit region</a>, with its
    information configured as follows:</p>

    <dl>

     <dt><a href="#hit-region's-set-of-pixels">Hit region's set of pixels</a>

     </dt><dd><p>The <var data-anolis-xref="">specified pixels</var>


     </p></dd><dt><a href="#hit-region's-bounding-circumference">Hit region's bounding circumference</a>

     </dt><dd><p>A user-agent-defined shape that wraps the pixels contained in <var data-anolis-xref="">source
     path</var>. (In the simplest case, this can just be the bounding rectangle; this specification
     allows it to be any shape in order to allow other interfaces.)


     </p></dd><dt><a href="#hit-region's-id">Hit region's ID</a>

     </dt><dd><p>If the <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-id"><a href="#dom-hitregionoptions-id">id</a></code> member is not null: the value of the <code data-anolis-xref="dom-HitRegionOptions-id"><a href="#dom-hitregionoptions-id">id</a></code> member. Otherwise, <var data-anolis-xref="">region</var> has no
     <a data-anolis-xref="hit region's id" href="#hit-region's-id">id</a>.


     </p></dd><dt><a href="#hit-region's-parent">Hit region's parent</a>

     </dt><dd><p>If <var data-anolis-xref="">parent region</var> is not null: <var data-anolis-xref="">parent region</var>.
     Otherwise, <var data-anolis-xref="">region</var> has no <a data-anolis-xref="hit region's parent" href="#hit-region's-parent">parent</a>.


     </p></dd><dt><a href="#hit-region's-child-count">Hit region's child count</a>

     </dt><dd><p>Initially zero.


     </p></dd><dt><a href="#hit-region's-cursor-specification">Hit region's cursor specification</a>

     </dt><dd><p>If the <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-cursor"><a href="#dom-hitregionoptions-cursor">cursor</a></code> member is not null: the value of the <code data-anolis-xref="dom-HitRegionOptions-cursor"><a href="#dom-hitregionoptions-cursor">cursor</a></code> member. Otherwise, the string "<code data-anolis-xref="">inherit</code>".


     </p></dd><dt><a href="#hit-region's-control">Hit region's control</a>

     </dt><dd><p>If the <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-control"><a href="#dom-hitregionoptions-control">control</a></code> member is not null: the value of the <code data-anolis-xref="dom-HitRegionOptions-control"><a href="#dom-hitregionoptions-control">control</a></code> member. Otherwise, <var data-anolis-xref="">region</var> has no <a data-anolis-xref="hit region's control" href="#hit-region's-control">control</a>.


     </p></dd><dt><a href="#hit-region's-label">Hit region's label</a>

     </dt><dd><p>If the <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-label"><a href="#dom-hitregionoptions-label">label</a></code> member is not null: the value of the <code data-anolis-xref="dom-HitRegionOptions-label"><a href="#dom-hitregionoptions-label">label</a></code> member. Otherwise, <var data-anolis-xref="">region</var>
     has no <a data-anolis-xref="hit region's label" href="#hit-region's-label">label</a>.


     </p></dd><dt><a href="#hit-region's-aria-role">Hit region's ARIA role</a>

     </dt><dd><p>If the <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-role"><a href="#dom-hitregionoptions-role">role</a></code> member is not null: the value of the <code data-anolis-xref="dom-HitRegionOptions-role"><a href="#dom-hitregionoptions-role">role</a></code> member (which might be the empty string).
     Otherwise, if the <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-label"><a href="#dom-hitregionoptions-label">label</a></code> member is not null: the empty string.
     Otherwise, <var data-anolis-xref="">region</var> has no <a data-anolis-xref="hit region's ARIA role" href="#hit-region's-aria-role">ARIA
     role</a>.


    </p></dd></dl>

   </li>

   <li>

    <p>If the <var data-anolis-xref="">arguments</var> object's <code data-anolis-xref="dom-HitRegionOptions-cursor"><a href="#dom-hitregionoptions-cursor">cursor</a></code> member is not null, then act as if a CSS rule
    for the <code>canvas</code> element setting its 'cursor' property had been seen, whose value was
    the <a href="#hit-region's-cursor-specification">hit region's cursor specification</a>.</p>

    <p class="note">For example, if the user agent prefetches cursor values, this would cause that
    to happen in response to an appropriately-formed <code data-anolis-xref="dom-context-2d-addHitRegion"><a href="#dom-context-2d-addhitregion">addHitRegion()</a></code> call.</p>

   </li>

   <li><p>If there is a <var data-anolis-xref="">previous region with this ID</var>, remove it, and all <a data-anolis-xref="hit region" href="#hit-region">hit regions</a> for which it is an <a href="#ancestor-region">ancestor region</a>, from the
   <a href="#scratch-bitmap">scratch bitmap</a>'s <a href="#hit-region-list">hit region list</a>; then, if it had a <a data-anolis-xref="hit
   region's parent" href="#hit-region's-parent">parent</a> region, decrement that <a href="#hit-region's-child-count">hit region's child count</a> by
   one.</p></li> <!-- we garbage collect the regions below -->

   <li><p>If there is a <var data-anolis-xref="">parent region</var>, increment its <a href="#hit-region's-child-count">hit region's child
   count</a> by one.</p></li>

   <li><p><a href="#clear-regions-that-cover-the-pixels">Clear regions that cover the pixels</a> in <var data-anolis-xref="">region</var>'s <a data-anolis-xref="hit region's set of pixels" href="#hit-region's-set-of-pixels">set of pixels</a> on this <a href="#scratch-bitmap">scratch
   bitmap</a>.</p></li> <!-- this is what garbage collects the earlier regions -->

   <li><p>Add <var data-anolis-xref="">region</var> to the <a href="#scratch-bitmap">scratch bitmap</a>'s element's <a href="#hit-region-list">hit
   region list</a>.</p></li>

  </ol>

  <p>When the <dfn data-anolis-xref="dom-context-2d-removeHitRegion" id="dom-context-2d-removehitregion"><code>removeHitRegion()</code></dfn>
  method is invoked, the user agent must run the following steps:</p>

  <ol>

   <li>

    <p>Let <var data-anolis-xref="">region</var> be <a href="#the-region-identified-by-the-id">the region identified by the ID</a> given by the
    method's argument in the rendering context's <a href="#scratch-bitmap">scratch bitmap</a>. If no such region
    currently exists, abort these steps.</p>

    <p class="note">If the method's argument is the empty string, then no region will match.</p>

   </li>

   <li><p>Remove <var data-anolis-xref="">region</var>, and all <a data-anolis-xref="hit region" href="#hit-region">hit regions</a> for
   which it is an <a href="#ancestor-region">ancestor region</a>, from the rendering context's <a href="#scratch-bitmap">scratch
   bitmap</a>'s <a href="#hit-region-list">hit region list</a>; then, if it had a <a data-anolis-xref="hit region's
   parent" href="#hit-region's-parent">parent</a> region, decrement that <a href="#hit-region's-child-count">hit region's child count</a> by
   one.</p></li> <!-- we garbage collect the regions below -->

   <li><p><a href="#garbage-collect-the-regions">Garbage-collect the regions</a> of the rendering context's <a href="#scratch-bitmap">scratch
   bitmap</a>.</p></li>

  </ol>

   <p>When the <dfn id="dom-context-2d-clearhitregions" title="dom-context-2d-clearHitRegions"><code>clearHitRegions()</code></dfn>
  method is invoked, the user agent must run the following steps:</p>

  <ol>

   <li><p>Remove all <var title="">hit regions</var>
   from the <code>canvas</code> element and clear the element's <a href="#hit-region-list">hit region list</a>. If no regions currently
   exist, abort these steps.</p></li>

  </ol>

  <p class="note">Calling <code title="dom-context-2d-clearRect"><a href="#dom-context-2d-clearrect">clearRect()</a></code> is a way
  to clear all or some hit regions. Calling clearHitRegions()  
  removes all hit regions and clears the hit region list. The <a href="#hit-region-list">hit region
  list</a> itself is also reset when the rendering context is reset. 
  For example, when a <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object is 
  bound to or unbound from a <code>canvas</code>, or the dimensions of the bitmap are changed.</p>
  </div>

  <hr>

  <p>The <code>MouseEvent</code> interface is extended to support hit regions:</p>

  <pre class="idl">partial interface <span id="MouseEvent-partial">MouseEvent</span> {
  readonly attribute DOMString? <a data-anolis-xref="dom-MouseEvent-region" href="#dom-mouseevent-region">region</a>;
};

partial dictionary <span>MouseEventInit</span> {
  DOMString? region;
};</pre>

  <dl class="domintro">

   <dt><var data-anolis-xref="">event</var> . <code data-anolis-xref="dom-MouseEvent-region"><a href="#dom-mouseevent-region">region</a></code></dt>

   <dd>

    <p>If the mouse was over a <a href="#hit-region">hit region</a>, then this returns the <a href="#hit-region's-id">hit region's
    ID</a>, if it has one.</p>

    <p>Otherwise, returns null.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-MouseEvent-region" id="dom-mouseevent-region"><code>region</code></dfn> attribute on
  <code>MouseEvent</code> objects must return the value it was initialised to. When the object is
  created, this attribute must be initialised to null. It represents the <a href="#hit-region's-id">hit region's
  ID</a> if the mouse was over a hit region when the event was fired.</p>

  <p>When a <code>MouseEvent</code> is to be fired at a <code>canvas</code> element by the user
  agent in response to a pointing device action other than a click (e.g. a <code data-anolis-xref="event-mousedown">mousedown</code> event or a <code data-anolis-xref="event-mousemove">mousemove</code> event), the user agent must run the <a href="#canvas-mouseevent-rerouting-steps">canvas
  <code>MouseEvent</code> rerouting steps</a> immediately prior to dispatching the event<!--
  interaction event spec point -->. This does not affect default actions (so for instance, if the
  event gets rerouted to an element that has a default action for <code data-anolis-xref="event-mousemove">mousemove</code> events, this default action doesn't trigger<!-- this
  would be significantly more obvious if there was a real spec defining how mouse events trigger
  that we could actually properly hook into -->).</p>

  <p class="note">Actual clicks are handled by the <span>run authentic click activation
  steps</span>, which also invoke these steps.</p>

  <p>The <dfn id="canvas-mouseevent-rerouting-steps">canvas <code>MouseEvent</code> rerouting steps</dfn> are as follows. If these steps
  say to <i>act as normal</i>, that means that the event must be fired as it would have had these
  requirements not been applied.</p>

  <ol>

   <li><p>If the pointing device is not indicating a pixel on the <code>canvas</code>, then act as
   normal and abort these steps.</p></li>

   <li><p>If the <code>canvas</code> element has no <a href="#hit-region-list">hit region list</a>, then act as normal
   and abort these steps.</p></li>

   <li><p>Let <var data-anolis-xref="">pixel</var> be the pixel indicated by the pointing device.</p></li>

   <li><p>Let <var data-anolis-xref="">region</var> be the <a href="#hit-region">hit region</a> that is <a data-anolis-xref="the
   region for a pixel" href="#the-region-for-a-pixel">the region for the pixel</a> <var data-anolis-xref="">pixel</var> on this
   <code>canvas</code> element's bitmap, if any.</p></li>

   <li><p>If there is no <var data-anolis-xref="">region</var>, then act as normal and abort these
   steps.</p></li>

   <li><p>Let <var data-anolis-xref="">id</var> be the <var data-anolis-xref="">region</var>'s <a data-anolis-xref="hit region's
   ID" href="#hit-region's-id">ID</a>, if any.</p></li>

   <li><p>If there is an <var data-anolis-xref="">id</var>, then initialise the event object's <code data-anolis-xref="dom-MouseEvent-region"><a href="#dom-mouseevent-region">region</a></code> attribute to <var data-anolis-xref="">id</var>.</p></li>

   <li><p>Let <var data-anolis-xref="">control</var> be the <a data-anolis-xref="the control represented by a
   region" href="#the-control-represented-by-a-region">control represented by</a> <var data-anolis-xref="">region</var> for this <code>canvas</code>
   element, if any.</p></li>

   <li><p>If there is a <var data-anolis-xref="">control</var>, then target the event object at <var data-anolis-xref="">control</var> instead of the <code>canvas</code> element.</p></li>

   <li><p>Continue dispatching the event, but with the updated event object and target as given in
   the above steps.</p></li>

  </ol>

  <hr>

  </div>

  <p>The <code>Touch</code> interface is extended to support hit regions also: <a href="#refsTOUCH">[TOUCH]</a></p>

  <pre class="idl">partial interface <span id="Touch-partial">Touch</span> {
  readonly attribute DOMString? <a data-anolis-xref="dom-Touch-region" href="#dom-touch-region">region</a>;
};</pre>

  <dl class="domintro">

   <dt><var data-anolis-xref="">touch</var> . <code data-anolis-xref="dom-Touch-region"><a href="#dom-touch-region">region</a></code></dt>

   <dd>

    <p>If the <span>touch point</span> was over a <a href="#hit-region">hit region</a> when it was first placed
    on the surface, then this returns the <a href="#hit-region's-id">hit region's ID</a>, if it has one.</p>

    <p>Otherwise, returns null.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-Touch-region" id="dom-touch-region"><code>region</code></dfn> attribute on a <code>Touch</code>
  object representing a <span>touch point</span> <var data-anolis-xref="">T</var> must return the value
  obtained by running the following algorithm when <var data-anolis-xref="">T</var> was first placed on the
  surface: <a href="#refsTOUCH">[TOUCH]</a></p>

  <ol>

   <li><p>If the <span>touch point</span> is not on a pixel on the <code>canvas</code>, then return
   null and abort these steps.</p></li>

   <li><p>If the <code>canvas</code> element has no <a href="#hit-region-list">hit region list</a>, then return null
   and abort these steps.</p></li>

   <li><p>Let <var data-anolis-xref="">pixel</var> be the pixel that the <span>touch point</span> is
   on.</p></li>

   <li><p>Let <var data-anolis-xref="">region</var> be the <a href="#hit-region">hit region</a> that is <a data-anolis-xref="the
   region for a pixel" href="#the-region-for-a-pixel">the region for the pixel</a> <var data-anolis-xref="">pixel</var> on this
   <code>canvas</code> element's bitmap, if any.</p></li>

   <li><p>If there is no <var data-anolis-xref="">region</var>, then return null and abort these
   steps.</p></li>

   <li><p>Let <var data-anolis-xref="">id</var> be the <var data-anolis-xref="">region</var>'s <a data-anolis-xref="hit region's
   ID" href="#hit-region's-id">ID</a>, if any, or else null.</p></li>

   <li><p>Return <var data-anolis-xref="">id</var>.</p></li>

  </ol>

  </div>

  <div class="impl">

  <hr>

  <p>When a user's pointing device cursor is positioned over a <code>canvas</code> element, user
  agents should render the pointing device cursor according to the cursor specification described by
  <a data-anolis-xref="the cursor for a hit region" href="#the-cursor-for-a-hit-region">the cursor for the hit region</a> that is <a data-anolis-xref="the region for a pixel" href="#the-region-for-a-pixel">the region for the pixel</a> that the pointing device designates
  on the <code>canvas</code> element's bitmap.</p>

  <hr>

  <p>User agents are encouraged to make use of the information present in a <code>canvas</code>
  element's <a href="#hit-region-list">hit region list</a> to improve the accessibility of <code>canvas</code>
  elements.</p>

  <p>Each <a href="#hit-region">hit region</a> should be handled in a fashion equivalent to a node in a virtual
  DOM tree rooted at the <code>canvas</code> element. The hierarchy of this virtual DOM tree must
  match the hierarchy of the <a data-anolis-xref="hit region" href="#hit-region">hit regions</a>, as described by the <a data-anolis-xref="hit region's parent" href="#hit-region's-parent">parent</a> of each region. Regions without a <a data-anolis-xref="hit
  region's parent" href="#hit-region's-parent">parent</a> must be treated as children of the <code>canvas</code> element for
  the purpose of this virtual DOM tree. For each node in such a DOM tree, the <a href="#hit-region's-bounding-circumference">hit region's
  bounding circumference</a> gives the region of the screen to use when representing the node (if
  appropriate).</p>

  <p>The semantics of a <a href="#hit-region">hit region</a> for the purposes of this virtual DOM tree are those
  of the <a data-anolis-xref="the control represented by a region" href="#the-control-represented-by-a-region">the control represented by the
  region</a>, if it has one, or else of a non-interactive element whose ARIA role, if any, is
  that given by the <a href="#hit-region's-aria-role">hit region's ARIA role</a>, and whose textual representation, if any,
  is given by the <a href="#hit-region's-label">hit region's label</a>.</p>

  <p>For the purposes of accessibility tools, when an element <var data-anolis-xref="">C</var> is a descendant
  of a <code>canvas</code> element and there is <a data-anolis-xref="the region representing the control" href="#the-region-representing-the-control">a
  region representing the control</a> <var data-anolis-xref="">C</var> for that <code>canvas</code>
  element's bitmap, then the element's position relative to the document should be presented as if
  it was that region in the <code>canvas</code> element's virtual DOM tree.</p>

  <p>The semantics of a <a href="#hit-region">hit region</a> for the purposes of this virtual DOM tree are those
  of the <a data-anolis-xref="the control represented by a region" href="#the-control-represented-by-a-region">the control represented by the
  region</a>, if it has one, or else of a non-interactive element whose ARIA role, if any, is
  that given by the <a href="#hit-region's-aria-role">hit region's ARIA role</a>, and whose textual representation, if any,
  is given by the <a href="#hit-region's-label">hit region's label</a>.</p>

  <p class="note">Thus, for instance, a user agent on a touch-screen device could provide haptic
  feedback when the user croses over a <a href="#hit-region's-bounding-circumference">hit region's bounding circumference</a>, and then
  read the <a href="#hit-region's-label">hit region's label</a> to the user. Similarly, a desktop user agent with a
  virtual accessibility focus separate from the keyboard input focus could allow the user to
  navigate through the hit regions, using the virtual DOM tree described above to enable
  hierarchical navigation. When an interactive control inside the <code>canvas</code> element
  <span>gains focus</span>, if the control has a corresponding region, then that <a href="#hit-region's-bounding-circumference">hit region's
  bounding circumference</a> could be used to determine what area of the display to magnify.</p>

  </div>


  <h6 id="pixel-manipulation"><span class="secno">1.1.16 </span><dfn>Pixel manipulation</dfn></h6>

  <dl class="domintro">

   <dt><var data-anolis-xref="">imagedata</var> = new <code data-anolis-xref="dom-imagedata"><a href="#dom-imagedata">ImageData</a></code>(<var data-anolis-xref="">sw</var>, <var data-anolis-xref="">sh</var>)</dt>
   <dt><var data-anolis-xref="">imagedata</var> = <var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-createImageData"><a href="#dom-context-2d-createimagedata">createImageData</a></code>(<var data-anolis-xref="">sw</var>, <var data-anolis-xref="">sh</var>)</dt>

   <dd>

    <p>Returns an <code><a href="#imagedata">ImageData</a></code> object with the given dimensions. All the pixels in the
    returned object are transparent black.</p>

    <p>Throws an <code>IndexSizeError</code> exception if either of the width or height
    arguments are zero.</p>

   </dd>

   <dt><var data-anolis-xref="">imagedata</var> = <var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-createImageData"><a href="#dom-context-2d-createimagedata">createImageData</a></code>(<var data-anolis-xref="">imagedata</var>)</dt>

   <dd>

    <p>Returns an <code><a href="#imagedata">ImageData</a></code> object with the same dimensions as the argument. All the
    pixels in the returned object are transparent black.</p>

   </dd>

   <dt><var data-anolis-xref="">imagedata</var> = new <code data-anolis-xref="dom-imagedata"><a href="#dom-imagedata">ImageData</a></code>(<var data-anolis-xref="">data</var>, <var data-anolis-xref="">sw</var> [, <var data-anolis-xref="">sh</var> ] )</dt>

   <dd>

    <p>Returns an <code><a href="#imagedata">ImageData</a></code> object using the data provided in the <code>Uint8ClampedArray</code> argument, interpreted using the given dimensions.</p>

    <p>As each pixel in the data is represented by four numbers, the length of the data needs to be
    a multiple of four times the given width. If the height is provided as well, then the length
    needs to be exactly the width times the height times 4.</p>

    <p>Throws an <code>IndexSizeError</code> exception if the given data and dimensions can't be
    interpreted consistently, or if either dimension is zero.</p>

   </dd>

   <dt><var data-anolis-xref="">imagedata</var> = <var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">getImageData</a></code>(<var data-anolis-xref="">sx</var>, <var data-anolis-xref="">sy</var>, <var data-anolis-xref="">sw</var>, <var data-anolis-xref="">sh</var>)</dt>

   <dd>

    <p>Returns an <code><a href="#imagedata">ImageData</a></code> object containing the image data for the given rectangle of
    the bitmap.</p>

    <p>Throws an <code>IndexSizeError</code> exception if the either of the width or height
    arguments are zero.</p>

   </dd>

   <dt><var data-anolis-xref="">imagedata</var> . <code data-anolis-xref="dom-imagedata-width"><a href="#dom-imagedata-width">width</a></code></dt>
   <dt><var data-anolis-xref="">imagedata</var> . <code data-anolis-xref="dom-imagedata-height"><a href="#dom-imagedata-height">height</a></code></dt>

   <dd>

    <p>Returns the actual dimensions of the data in the <code><a href="#imagedata">ImageData</a></code> object, in
    pixels.</p>

   </dd>

   <dt><var data-anolis-xref="">imagedata</var> . <code data-anolis-xref="dom-imagedata-data"><a href="#dom-imagedata-data">data</a></code></dt>

   <dd>

    <p>Returns the one-dimensional array containing the data in RGBA order, as integers in the range
    0 to 255.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-putImageData"><a href="#dom-context-2d-putimagedata">putImageData</a></code>(<var data-anolis-xref="">imagedata</var>, <var data-anolis-xref="">dx</var>, <var data-anolis-xref="">dy</var> [, <var data-anolis-xref="">dirtyX</var>, <var data-anolis-xref="">dirtyY</var>, <var data-anolis-xref="">dirtyWidth</var>, <var data-anolis-xref="">dirtyHeight</var> ] )</dt>

   <dd>

    <p>Paints the data from the given <code><a href="#imagedata">ImageData</a></code> object onto the bitmap. If a dirty
    rectangle is provided, only the pixels from that rectangle are painted.</p>

    <p>The <code data-anolis-xref="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code> and <code data-anolis-xref="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code> attributes, as
    well as the shadow attributes, are ignored for the purposes of this method call; pixels in the
    canvas are replaced wholesale, with no composition, alpha blending, no shadows, etc.</p>

    <p>Throws a <code>NotSupportedError</code> exception if any of the arguments are not finite.</p>

    <p>Throws an <code>InvalidStateError</code> exception if the <var data-anolis-xref="">imagedata</var>
    object's data has been <span data-anolis-xref="concept-Transferable-neutered">neutered</span>.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-imagedata" id="dom-imagedata"><code>ImageData()</code></dfn> constructors and the <dfn data-anolis-xref="dom-context-2d-createImageData" id="dom-context-2d-createimagedata"><code>createImageData()</code></dfn> methods are used to
  instantiate new <code><a href="#imagedata">ImageData</a></code> objects.</p>

  <p>When the <code data-anolis-xref="dom-imagedata"><a href="#dom-imagedata">ImageData()</a></code> constructor is invoked with two
  numeric arguments <var data-anolis-xref="">sw</var> and <var data-anolis-xref="">sh</var>, it must return a new
  <code><a href="#imagedata">ImageData</a></code> object representing a transparent black rectangle with a width equal to
  <var data-anolis-xref="">sw</var> and a height equal to <var data-anolis-xref="">sh</var>, if both <var data-anolis-xref="">sw</var> and <var data-anolis-xref="">sh</var> are non-zero. If one or both of <var data-anolis-xref="">sw</var> and <var data-anolis-xref="">sh</var> are zero, then the constructor must throw an
  <code>IndexSizeError</code> exception instead.</p>

  <p>When the <code data-anolis-xref="dom-imagedata"><a href="#dom-imagedata">ImageData()</a></code> constructor is invoked with its first
  argument being an <code>Uint8ClampedArray</code> <var data-anolis-xref="">source</var> and its second and
  (optionally) third argument(s) being numeric arguments <var data-anolis-xref="">sw</var> and <var data-anolis-xref="">sh</var>, it must run the following steps:

  </p><ol>

   <li><p>Let <var data-anolis-xref="">length</var> be the number of bytes in <var data-anolis-xref="">source</var>.</p></li>

   <li><p>If <var data-anolis-xref="">length</var> is not a non-zero integral multiple of four, throw an
   <code>InvalidStateError</code> exception and abort these steps.</p></li>

   <li><p>Let <var data-anolis-xref="">length</var> be <var data-anolis-xref="">length</var> divided by four.</p>

   </li><li>

    <p>If <var data-anolis-xref="">length</var> is not an integral multiple of <var data-anolis-xref="">sw</var>,
    throw an <code>IndexSizeError</code> exception and abort these steps.</p>

    <p class="note">At this step, the length is guaranteed to be greater than zero (otherwise the
    second step above would have aborted the steps), so if <var data-anolis-xref="">sw</var> is zero, this
    step will throw the exception and abort these steps.</p>

   </li>

   <li><p>Let <var data-anolis-xref="">height</var> be <var data-anolis-xref="">length</var> divided by <var data-anolis-xref="">sw</var>.</p></li>

   <li><p>If the <var data-anolis-xref="">sh</var> argument was not omitted, and its value is not equal to
   <var data-anolis-xref="">height</var>, then throw an <code>IndexSizeError</code> exception and abort these
   steps.</p></li>

   <li>

    <p>Return a new <code><a href="#imagedata">ImageData</a></code> object whose width is <var data-anolis-xref="">sw</var>, whose
    height is <var data-anolis-xref="">height</var>, and whose data is <var data-anolis-xref="">source</var>.</p>

    <p class="note">The resulting object's data is not a <em>copy</em> of <var data-anolis-xref="">source</var>, it's the actual <code>Uint8ClampedArray</code> object passed as the
    first argument to the constructor.</p>

   </li>

  </ol>

  <p>When the <code data-anolis-xref="dom-context-2d-createImageData"><a href="#dom-context-2d-createimagedata">createImageData()</a></code> method is
  invoked with two numeric arguments <var data-anolis-xref="">sw</var> and <var data-anolis-xref="">sh</var>, it must
  return a new <code><a href="#imagedata">ImageData</a></code> object representing a transparent black rectangle with a width
  equal to the absolute magnitude of <var data-anolis-xref="">sw</var> and a height equal to the absolute
  magnitude of <var data-anolis-xref="">sh</var>, if both <var data-anolis-xref="">sw</var> and <var data-anolis-xref="">sh</var>
  are non-zero. If one or both of <var data-anolis-xref="">sw</var> and <var data-anolis-xref="">sh</var> are zero, then
  the constructor must throw an <code>IndexSizeError</code> exception instead.</p>

  <p>When the <code data-anolis-xref="dom-context-2d-createImageData"><a href="#dom-context-2d-createimagedata">createImageData()</a></code> method is
  invoked with a single <var data-anolis-xref="">imagedata</var> argument, it must return a new
  <code><a href="#imagedata">ImageData</a></code> object representing a transparent black rectangle with the same dimensions
  as the <code><a href="#imagedata">ImageData</a></code> object passed as the argument.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-getImageData" id="dom-context-2d-getimagedata"><code>getImageData(<var data-anolis-xref="">sx</var>,
  <var data-anolis-xref="">sy</var>, <var data-anolis-xref="">sw</var>, <var data-anolis-xref="">sh</var>)</code></dfn> method must,
  if either the <var data-anolis-xref="">sw</var> or <var data-anolis-xref="">sh</var> arguments are zero, throw an
  <code>IndexSizeError</code> exception; otherwise,
  <!--ADD-TOPIC:Security-->
  if the <a href="#scratch-bitmap">scratch bitmap</a>'s <span data-anolis-xref="concept-canvas-origin-clean">origin-clean</span>
  flag is set to false, it must throw a <code>SecurityError</code> exception;
  <!--REMOVE-TOPIC:Security-->
  otherwise, it must return an <code><a href="#imagedata">ImageData</a></code> object with width <var data-anolis-xref="">sw</var> and
  height <var data-anolis-xref="">sh</var> representing the <a href="#scratch-bitmap">scratch bitmap</a> for the area of that
  bitmap denoted by the rectangle whose corners are the four points (<var data-anolis-xref="">sx</var>, <var data-anolis-xref="">sy</var>), (<span data-anolis-xref=""><var data-anolis-xref="">sx</var>+<var data-anolis-xref="">sw</var></span>, <var data-anolis-xref="">sy</var>), (<span data-anolis-xref=""><var data-anolis-xref="">sx</var>+<var data-anolis-xref="">sw</var></span>,
  <span data-anolis-xref=""><var data-anolis-xref="">sy</var>+<var data-anolis-xref="">sh</var></span>), (<var data-anolis-xref="">sx</var>,
  <span data-anolis-xref=""><var data-anolis-xref="">sy</var>+<var data-anolis-xref="">sh</var></span>), in the bitmap's
  coordinate space units. Pixels outside the <a href="#scratch-bitmap">scratch bitmap</a> must be returned as
  transparent black. Pixels must be returned as non-premultiplied alpha values.</p>

  <p>New <code><a href="#imagedata">ImageData</a></code> objects must be initialised so that their <dfn data-anolis-xref="dom-imagedata-width" id="dom-imagedata-width"><code>width</code></dfn> attribute is set to the number of pixels per
  row in the image data, their <dfn data-anolis-xref="dom-imagedata-height" id="dom-imagedata-height"><code>height</code></dfn>
  attribute is set to the number of rows in the image data, and their <dfn data-anolis-xref="dom-imagedata-data" id="dom-imagedata-data"><code>data</code></dfn> attribute, except where an existing array is
  provided, is initialised to a new <code>Uint8ClampedArray</code> object. The
  <code>Uint8ClampedArray</code> object must use a new <a href="#canvas-pixel-arraybuffer">Canvas Pixel
  <code>ArrayBuffer</code></a> for its storage, and must have a zero start offset and a length
  equal to the length of its storage, in bytes. The <a href="#canvas-pixel-arraybuffer">Canvas Pixel
  <code>ArrayBuffer</code></a> must contain the image data. At least one pixel's worth of image
  data must be returned. <a href="#refsECMA262">[ECMA262]</a></p>

<!--CLEANUP-->
  <p>A <dfn id="canvas-pixel-arraybuffer">Canvas Pixel <code>ArrayBuffer</code></dfn> is an <code>ArrayBuffer</code> whose
  data is represented in left-to-right order, row by row top to bottom, starting with the top left,
  with each pixel's red, green, blue, and alpha components being given in that order for each pixel.
  Each component of each pixel represented in this array must be in the range 0..255, representing
  the 8 bit value for that component. The components must be assigned consecutive indices starting
  with 0 for the top left pixel's red component. <a href="#refsECMA262">[ECMA262]</a></p>

  <p>The <dfn data-anolis-xref="dom-context-2d-putImageData" id="dom-context-2d-putimagedata"><code>putImageData()</code></dfn> method writes
  data from <code><a href="#imagedata">ImageData</a></code> structures back to the rendering context's <a href="#scratch-bitmap">scratch
  bitmap</a>. Its arguments are: <var data-anolis-xref="">imagedata</var>, <var data-anolis-xref="">dx</var>, <var data-anolis-xref="">dy</var>, <var data-anolis-xref="">dirtyX</var>, <var data-anolis-xref="">dirtyY</var>, <var data-anolis-xref="">dirtyWidth</var>, and <var data-anolis-xref="">dirtyHeight</var>.</p>

  <p>When the last four arguments to this method are omitted, they must be assumed to have the
  values 0, 0, the <code data-anolis-xref="dom-imagedata-width"><a href="#dom-imagedata-width">width</a></code> member of the <var data-anolis-xref="">imagedata</var> structure, and the <code data-anolis-xref="dom-imagedata-height"><a href="#dom-imagedata-height">height</a></code>
  member of the <var data-anolis-xref="">imagedata</var> structure, respectively.</p>

  <p>When invoked, the method must act as follows:</p>

  <ol>

   <li>

    <p>If the <var data-anolis-xref="">imagedata</var> argument's <code data-anolis-xref="dom-imagedata-data"><a href="#dom-imagedata-data">data</a></code> attribute has been <span data-anolis-xref="concept-Transferable-neutered">neutered</span>, throw an <code>InvalidStateError</code>
    exception and abort these steps.</p>

   </li><li>

    <p>If <var data-anolis-xref="">dirtyWidth</var> is negative, let <var data-anolis-xref="">dirtyX</var> be <span data-anolis-xref=""><var data-anolis-xref="">dirtyX</var>+<var data-anolis-xref="">dirtyWidth</var></span>, and let <var data-anolis-xref="">dirtyWidth</var> be equal to the absolute magnitude of <var data-anolis-xref="">dirtyWidth</var>.</p>

    <p>If <var data-anolis-xref="">dirtyHeight</var> is negative, let <var data-anolis-xref="">dirtyY</var> be <span data-anolis-xref=""><var data-anolis-xref="">dirtyY</var>+<var data-anolis-xref="">dirtyHeight</var></span>, and let <var data-anolis-xref="">dirtyHeight</var> be equal to the absolute magnitude of <var data-anolis-xref="">dirtyHeight</var>.</p>

   </li>

   <li>

    <p>If <var data-anolis-xref="">dirtyX</var> is negative, let <var data-anolis-xref="">dirtyWidth</var> be <span data-anolis-xref=""><var data-anolis-xref="">dirtyWidth</var>+<var data-anolis-xref="">dirtyX</var></span>, and let <var data-anolis-xref="">dirtyX</var> be zero.</p>

    <p>If <var data-anolis-xref="">dirtyY</var> is negative, let <var data-anolis-xref="">dirtyHeight</var> be <span data-anolis-xref=""><var data-anolis-xref="">dirtyHeight</var>+<var data-anolis-xref="">dirtyY</var></span>, and let <var data-anolis-xref="">dirtyY</var> be zero.</p>

   </li>

   <li>

    <p>If <span data-anolis-xref=""><var data-anolis-xref="">dirtyX</var>+<var data-anolis-xref="">dirtyWidth</var></span> is greater
    than the <code data-anolis-xref="dom-imagedata-width"><a href="#dom-imagedata-width">width</a></code> attribute of the <var data-anolis-xref="">imagedata</var> argument, let <var data-anolis-xref="">dirtyWidth</var> be the value of that <code data-anolis-xref="dom-imagedata-width"><a href="#dom-imagedata-width">width</a></code> attribute, minus the value of <var data-anolis-xref="">dirtyX</var>.</p>

    <p>If <span data-anolis-xref=""><var data-anolis-xref="">dirtyY</var>+<var data-anolis-xref="">dirtyHeight</var></span> is
    greater than the <code data-anolis-xref="dom-imagedata-height"><a href="#dom-imagedata-height">height</a></code> attribute of the <var data-anolis-xref="">imagedata</var> argument, let <var data-anolis-xref="">dirtyHeight</var> be the value of that
    <code data-anolis-xref="dom-imagedata-height"><a href="#dom-imagedata-height">height</a></code> attribute, minus the value of <var data-anolis-xref="">dirtyY</var>.</p>

   </li>

   <li>

    <p>If, after those changes, either <var data-anolis-xref="">dirtyWidth</var> or <var data-anolis-xref="">dirtyHeight</var> is negative or zero, stop these steps without affecting any
    bitmaps.</p>

   </li>

   <li><p>For all integer values of <var data-anolis-xref="">x</var> and <var data-anolis-xref="">y</var> where <span data-anolis-xref=""><var data-anolis-xref="">dirtyX</var> ≤ <var data-anolis-xref="">x</var> &lt; <span data-anolis-xref=""><var data-anolis-xref="">dirtyX</var>+<var data-anolis-xref="">dirtyWidth</var></span></span> and <span data-anolis-xref=""><var data-anolis-xref="">dirtyY</var> ≤ <var data-anolis-xref="">y</var> &lt; <span data-anolis-xref=""><var data-anolis-xref="">dirtyY</var>+<var data-anolis-xref="">dirtyHeight</var></span></span>, copy the
   four channels of the pixel with coordinate (<var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>) in
   the <var data-anolis-xref="">imagedata</var> data structure's <a href="#canvas-pixel-arraybuffer">Canvas Pixel
   <code>ArrayBuffer</code></a> to the pixel with coordinate (<span data-anolis-xref=""><var data-anolis-xref="">dx</var>+<var data-anolis-xref="">x</var></span>, <span data-anolis-xref=""><var data-anolis-xref="">dy</var>+<var data-anolis-xref="">y</var></span>) in the rendering context's <a href="#scratch-bitmap">scratch bitmap</a>.</p></li>

  </ol>

  <p>The handling of pixel rounding when the specified coordinates are not integers is not defined
  by this specification, except that the following must result in no visible changes to the
  rendering:</p>

  <pre>context.putImageData(context.getImageData(x, y, w, h), p, q);</pre>

  <p>...for any value of <var data-anolis-xref="">x</var>, <var data-anolis-xref="">y</var>, <var data-anolis-xref="">w</var>, and
  <var data-anolis-xref="">h</var> and where <var data-anolis-xref="">p</var> is the smaller of <var data-anolis-xref="">x</var>
  and the sum of <var data-anolis-xref="">x</var> and <var data-anolis-xref="">w</var>, and <var data-anolis-xref="">q</var> is
  the smaller of <var data-anolis-xref="">y</var> and the sum of <var data-anolis-xref="">y</var> and <var data-anolis-xref="">h</var>; and except that the following two calls:</p>

  <pre>context.createImageData(w, h);
context.getImageData(0, 0, w, h);</pre>

  <p>...must return <code><a href="#imagedata">ImageData</a></code> objects with the same dimensions as each other, for any
  value of <var data-anolis-xref="">w</var> and <var data-anolis-xref="">h</var>. In other words, while user agents may
  round the arguments of these methods, any rounding performed must be performed consistently for
  all of the methods described in this section. (The constructors only work with integer
  values.)</p>

  <p class="note">Due to the lossy nature of converting to and from premultiplied alpha color
  values, pixels that have just been set using <code data-anolis-xref="dom-context-2d-putImageData"><a href="#dom-context-2d-putimagedata">putImageData()</a></code> might be returned to an equivalent
  <code data-anolis-xref="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">getImageData()</a></code> as different values.</p>

  <p>The current path, <a data-anolis-xref="dom-context-2d-transformation" href="#transformations">transformation matrix</a>,
  <a data-anolis-xref="shadows" href="#shadows">shadow attributes</a>, <a data-anolis-xref="dom-context-2d-globalAlpha" href="#dom-context-2d-globalalpha">global
  alpha</a>, the <a href="#clipping-region">clipping region</a>, and <a data-anolis-xref="dom-context-2d-globalCompositeOperation" href="#dom-context-2d-globalcompositeoperation">global composition operator</a> must not
  affect the methods described in this section.</p>

  </div>

  <div class="example">

   <p>In the following example, the script generates an <code><a href="#imagedata">ImageData</a></code> object so that it can
   draw onto it.</p>

   <pre>// canvas is a reference to a &lt;canvas&gt; element
var context = canvas.getContext('2d');

// create a blank slate
var data = context.createImageData(canvas.width, canvas.height);

// create some plasma
FillPlasma(data, 'green'); // green plasma

// add a cloud to the plasma
AddCloud(data, data.width/2, data.height/2); // put a cloud in the middle

// paint the plasma+cloud on the canvas
context.putImageData(data, 0, 0);

// support methods
function FillPlasma(data, color) { ... }
function AddCloud(data, x, y) { ... }</pre>

  </div>

  <div class="example">

   <p>Here is an example of using <code data-anolis-xref="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">getImageData()</a></code> and <code data-anolis-xref="dom-context-2d-putImageData"><a href="#dom-context-2d-putimagedata">putImageData()</a></code> to implement an edge detection
   filter.</p>

   <pre>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;Edge detection demo&lt;/title&gt;
  &lt;script&gt;
   var image = new Image();
   function init() {
     image.onload = demo;
     image.src = "image.jpeg";
   }
   function demo() {
     var canvas = document.getElementsByTagName('canvas')[0];
     var context = canvas.getContext('2d');

     // draw the image onto the canvas
     context.drawImage(image, 0, 0);

     // get the image data to manipulate
     var input = context.getImageData(0, 0, canvas.width, canvas.height);

     // get an empty slate to put the data into
     var output = context.createImageData(canvas.width, canvas.height);

     // alias some variables for convenience
     // notice that we are using input.width and input.height here
     // as they might not be the same as canvas.width and canvas.height
     // (in particular, they might be different on high-res displays)
     var w = input.width, h = input.height;
     var inputData = input.data;
     var outputData = output.data;

     // edge detection
     for (var y = 1; y &lt; h-1; y += 1) {
       for (var x = 1; x &lt; w-1; x += 1) {
         for (var c = 0; c &lt; 3; c += 1) {
           var i = (y*w + x)*4 + c;
           outputData[i] = 127 + -inputData[i - w*4 - 4] -   inputData[i - w*4] - inputData[i - w*4 + 4] +
                                 -inputData[i - 4]       + 8*inputData[i]       - inputData[i + 4] +
                                 -inputData[i + w*4 - 4] -   inputData[i + w*4] - inputData[i + w*4 + 4];
         }
         outputData[(y*w + x)*4 + 3] = 255; // alpha
       }
     }

     // put the image data back after manipulation
     context.putImageData(output, 0, 0);
   }
  &lt;/script&gt;
 &lt;/head&gt;
 &lt;body onload="init()"&gt;
  &lt;canvas&gt;&lt;/canvas&gt;
 &lt;/body&gt;
&lt;/html&gt;</pre>

  </div>




  <h6 id="compositing"><span class="secno">1.1.17 </span>Compositing</h6>

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current alpha value applied to rendering operations.</p>

    <p>Can be set, to change the alpha value. Values outside of the range 0.0 .. 1.0 are
    ignored.</p>

   </dd>


   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current composition operation, from the values defined in the Compositing and
    Blending specification. <a href="#refsCOMPOSITE">[COMPOSITE]</a>.</p>

    <p>Can be set, to change the composition operation. Unknown values are ignored.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>All drawing operations are affected by the global compositing attributes, <code data-anolis-xref="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code> and <code data-anolis-xref="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code>.</p>

  <!-- conformance criteria for painting are described in the "drawing model" section below -->

  <p>The <dfn data-anolis-xref="dom-context-2d-globalAlpha" id="dom-context-2d-globalalpha"><code>globalAlpha</code></dfn> attribute gives an
  alpha value that is applied to shapes and images before they are composited onto the <a href="#scratch-bitmap">scratch
  bitmap</a>. The value must be in the range from 0.0 (fully transparent) to 1.0 (no additional
  transparency). If an attempt is made to set the attribute to a value outside this range, including
  Infinity and Not-a-Number (NaN) values, the attribute must retain its previous value. When the
  context is created, the <code data-anolis-xref="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code> attribute must
  initially have the value 1.0.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-globalCompositeOperation" id="dom-context-2d-globalcompositeoperation"><code>globalCompositeOperation</code></dfn>
  attribute sets the current composition operator, which controls how shapes and images are drawn
  onto the <a href="#scratch-bitmap">scratch bitmap</a>, once they have had <code data-anolis-xref="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code> and the current transformation matrix
  applied. The possible values are those defined in the Compositing and Blending specification. <a href="#refsCOMPOSITE">[COMPOSITE]</a></p>

  <p>These values are all case-sensitive — they must be used exactly as defined. User agents
  must not recognise values that are not a <span>case-sensitive</span> match for one of the values
  given in the Compositing and Blending specification. <a href="#refsCOMPOSITE">[COMPOSITE]</a></p>

  <p>On setting, if the user agent does not recognise the specified value, it must be ignored,
  leaving the value of <code data-anolis-xref="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code> unaffected.
  Otherwise, the attribute must be set to the given new value.</p>

  <p>When the context is created, the <code data-anolis-xref="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code> attribute must
  initially have the value <code>source-over</code>.</p>

  </div>



  <h6 id="image-smoothing"><span class="secno">1.1.18 </span>Image smoothing</h6>

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-imageSmoothingEnabled"><a href="#dom-context-2d-imagesmoothingenabled">imageSmoothingEnabled</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns whether pattern fills and the <code data-anolis-xref="dom-context-2d-drawImage"><a href="#dom-context-2d-drawimage">drawImage()</a></code> method will attempt to smooth images if
    their pixels don't line up exactly with the display, when scaling images up.</p>

    <p>Can be set, to change whether images are smoothed (true) or not (false).</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-context-2d-imageSmoothingEnabled" id="dom-context-2d-imagesmoothingenabled"><code>imageSmoothingEnabled</code></dfn>
  attribute, on getting, must return the last value it was set to. On setting, it must be set to the
  new value. When the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object is created, the attribute must be
  set to true.</p>

  </div>


  <h6 id="shadows"><span class="secno">1.1.19 </span><dfn>Shadows</dfn></h6>

  <p>All drawing operations are affected by the four global shadow attributes.</p>

  <dl class="domintro">

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current shadow color.</p>

    <p>Can be set, to change the shadow color. Values that cannot be parsed as CSS colors are ignored.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-shadowOffsetX"><a href="#dom-context-2d-shadowoffsetx">shadowOffsetX</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-shadowOffsetY"><a href="#dom-context-2d-shadowoffsety">shadowOffsetY</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current shadow offset.</p>

    <p>Can be set, to change the shadow offset. Values that are not finite numbers are ignored.</p>

   </dd>

   <dt><var data-anolis-xref="">context</var> . <code data-anolis-xref="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>Returns the current level of blur applied to shadows.</p>

    <p>Can be set, to change the blur level. Values that are not finite numbers greater than or
    equal to zero are ignored.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-context-2d-shadowColor" id="dom-context-2d-shadowcolor"><code>shadowColor</code></dfn> attribute sets the
  color of the shadow.</p>

  <p>When the context is created, the <code data-anolis-xref="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code>
  attribute initially must be fully-transparent black.</p>

  <p>On getting, the <a data-anolis-xref="serialization of a color" href="#serialization-of-a-color">serialization of the color</a> must
  be returned.</p>

  <p>On setting, the new value must be <span>parsed as a CSS &lt;color&gt; value</span> and the
  color assigned. If the value cannot be parsed as a CSS &lt;color&gt; value then it must be
  ignored, and the attribute must retain its previous value. <a href="#refsCSSCOLOR">[CSSCOLOR]</a></p>

  <p>The <dfn data-anolis-xref="dom-context-2d-shadowOffsetX" id="dom-context-2d-shadowoffsetx"><code>shadowOffsetX</code></dfn> and <dfn data-anolis-xref="dom-context-2d-shadowOffsetY" id="dom-context-2d-shadowoffsety"><code>shadowOffsetY</code></dfn> attributes specify the
  distance that the shadow will be offset in the positive horizontal and positive vertical distance
  respectively. Their values are in coordinate space units. They are not affected by the current
  transformation matrix.</p>

  <p>When the context is created, the shadow offset attributes must initially have the value
  <code>0</code>.</p>

  <p>On getting, they must return their current value. On setting, the attribute being set must be
  set to the new value, except if the value is infinite or NaN, in which case the new value must be
  ignored.</p>

  <p>The <dfn data-anolis-xref="dom-context-2d-shadowBlur" id="dom-context-2d-shadowblur"><code>shadowBlur</code></dfn> attribute specifies
  the level of the blurring effect. (The units do not map to coordinate space units, and are not
  affected by the current transformation matrix.)</p>

  <p>When the context is created, the <code data-anolis-xref="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code>
  attribute must initially have the value <code>0</code>.</p>

  <p>On getting, the attribute must return its current value. On setting the attribute must be set
  to the new value, except if the value is negative, infinite or NaN, in which case the new value
  must be ignored.</p>

  <p><dfn data-anolis-xref="when shadows are drawn" id="when-shadows-are-drawn">Shadows are only drawn if</dfn> the opacity component of
  the alpha component of the color of <code data-anolis-xref="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code> is
  non-zero and either the <code data-anolis-xref="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code> is non-zero, or
  the <code data-anolis-xref="dom-context-2d-shadowOffsetX"><a href="#dom-context-2d-shadowoffsetx">shadowOffsetX</a></code> is non-zero, or the <code data-anolis-xref="dom-context-2d-shadowOffsetY"><a href="#dom-context-2d-shadowoffsety">shadowOffsetY</a></code> is non-zero.</p>

  <p class="critical">It is likely that this will change: browser vendors have indicated an interest
  in changing the processing model for shadows such that they only draw when the composition
  operator is "source-over" (the default).</p>

  <p><a href="#when-shadows-are-drawn">When shadows are drawn</a>, they must be rendered as follows:</p>

  <ol>

   <li><p>Let <var data-anolis-xref="">A</var> be an infinite transparent black bitmap on which the source
   image for which a shadow is being created has been rendered.</p></li>

   <li><p>Let <var data-anolis-xref="">B</var> be an infinite transparent black bitmap, with a coordinate
   space and an origin identical to <var data-anolis-xref="">A</var>.</p></li>

   <li><p>Copy the alpha channel of <var data-anolis-xref="">A</var> to <var data-anolis-xref="">B</var>, offset by <code data-anolis-xref="dom-context-2d-shadowOffsetX"><a href="#dom-context-2d-shadowoffsetx">shadowOffsetX</a></code> in the positive <var data-anolis-xref="">x</var>
   direction, and <code data-anolis-xref="dom-context-2d-shadowOffsetY"><a href="#dom-context-2d-shadowoffsety">shadowOffsetY</a></code> in the positive
   <var data-anolis-xref="">y</var> direction.</p></li>

   <li>

    <p>If <code data-anolis-xref="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code> is greater than 0:</p>

    <ol>

     <li> <p>Let <var data-anolis-xref="">σ</var> be half the value of <code data-anolis-xref="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code>.</p></li>

     <li> <p>Perform a 2D Gaussian Blur on <var data-anolis-xref="">B</var>, using <var data-anolis-xref="">σ</var>
     as the standard deviation.</p> <!-- wish i could find a reference for this --> </li>

    </ol>

    <p>User agents may limit values of <var data-anolis-xref="">σ</var> to an implementation-specific
    maximum value to avoid exceeding hardware limitations during the Gaussian blur operation.</p>

   </li>

   <li><p>Set the red, green, and blue components of every pixel in <var data-anolis-xref="">B</var> to the
   red, green, and blue components (respectively) of the color of <code data-anolis-xref="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code>.</p></li>

   <li><p>Multiply the alpha component of every pixel in <var data-anolis-xref="">B</var> by the alpha
   component of the color of <code data-anolis-xref="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code>.</p></li>

   <li><p>The shadow is in the bitmap <var data-anolis-xref="">B</var>, and is rendered as part of the
   <a href="#drawing-model">drawing model</a> described below.</p></li>

  </ol>

  </div>

  <p>If the current composition operation is <code data-anolis-xref="gcop-copy">copy</code>, shadows
  effectively won't render (since the shape will overwrite the shadow).</p>



  <div class="impl">

  <h6 id="drawing-model"><span class="secno">1.1.20 </span><dfn>Drawing model</dfn></h6>

  <p>When a shape or image is painted, user agents must follow these steps, in the order given (or
  act as if they do):</p>

  <ol>

   <li><p>Render the shape or image onto an infinite transparent black bitmap, creating image <var data-anolis-xref="">A</var>, as described in the previous sections. For shapes, the current fill, stroke,
   and line styles must be honored, and the stroke must itself also be subjected to the current
   transformation matrix.</p></li>

   <li><p><a href="#when-shadows-are-drawn">When shadows are drawn</a>, render the shadow from image <var data-anolis-xref="">A</var>,
   using the current shadow styles, creating image <var data-anolis-xref="">B</var>.</p></li>

   <li><p><a href="#when-shadows-are-drawn">When shadows are drawn</a>, multiply the alpha component of every pixel in <var data-anolis-xref="">B</var> by <code data-anolis-xref="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code>.</p></li>

   <li><p><a href="#when-shadows-are-drawn">When shadows are drawn</a>, composite <var data-anolis-xref="">B</var> within the
   <a href="#clipping-region">clipping region</a> over the current <a href="#scratch-bitmap">scratch bitmap</a> using the current
   composition operator.</p></li>

   <li><p>Multiply the alpha component of every pixel in <var data-anolis-xref="">A</var> by <code data-anolis-xref="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code>.</p></li>

   <li><p>Composite <var data-anolis-xref="">A</var> within the <a href="#clipping-region">clipping region</a> over the current
   <a href="#scratch-bitmap">scratch bitmap</a> using the current composition operator.</p></li>

  </ol>

  <p>When compositing onto the <a href="#scratch-bitmap">scratch bitmap</a>, pixels that would fall outside of the
  <a href="#scratch-bitmap">scratch bitmap</a> must be discarded.</p>

  </div>




  <h6 id="best-practices"><span class="secno">1.1.21 </span>Best practices</h6>

  <p><i>This section is non-normative.</i></p>

  <p class="auth">When a canvas is interactive, authors should include focusable elements in the element's
  fallback content corresponding to each focusable part of the canvas, as in the <a href="#drawCustomFocusRingExample">example above</a>.</p>
  <!-- START w3c-html-->
  <p class="auth">To expose text and interactive content on a <code>canvas</code> to users of accessibility
  tools, authors should use the <code data-anolis-xref="dom-context-2d-addHitRegion"><a href="#dom-context-2d-addhitregion">addHitRegion()</a></code>
  API. When rendering focus outline, to ensure that focus outlines have the appearance of native focus
  outlines, authors should use the <code data-anolis-xref="dom-context-2d-drawFocusIfNeeded"><a href="#dom-context-2d-drawfocusifneeded">drawFocusIfNeeded()</a></code> method, passing it the
  element for which a outline is being drawn. This method only draws the focus outline if the element is
  <span>focused</span>, so that it can simply be called whenever drawing the element, without
  checking whether the element is focused or not first.</p><!-- END FORK w3c-html-->

  <p class="auth" id="no-text-editing-in-canvas-please">Authors should avoid implementing text editing controls
  using the <code>canvas</code> element. Doing so has a large number of disadvantages:</p>

  <ul>

   <li>Mouse placement of the caret has to be reimplemented.</li>

   <li>Keyboard movement of the caret has to be reimplemented (possibly across lines, for multiline
   text input).</li>

   <li>Scrolling of the text field has to be implemented (horizontally for long lines, vertically
   for multiline input).</li>

   <li>Native features such as copy-and-paste have to be reimplemented.</li>

   <li>Native features such as spell-checking have to be reimplemented.</li>

   <li>Native features such as drag-and-drop have to be reimplemented.</li>

   <li>Native features such as page-wide text search have to be reimplemented.</li>

   <li>Native features specific to the user, for example custom text services, have to be
   reimplemented. This is close to impossible since each user might have different services
   installed, and there is an unbounded set of possible such services.</li>

   <li>Bidirectional text editing has to be reimplemented.</li>

   <li>For multiline text editing, line wrapping has to be implemented for all relevant
   languages.</li>

   <li>Text selection has to be reimplemented.</li>

   <li>Dragging of bidirectional text selections has to be reimplemented.</li>

   <li>Platform-native keyboard shortcuts have to be reimplemented.</li>

   <li>Platform-native input method editors (IMEs) have to be reimplemented.</li>

   <li>Undo and redo functionality has to be reimplemented.</li>

   <li>Accessibility features such as magnification following the caret or selection have to be
   reimplemented.</li>

  </ul>

  <p>This is a huge amount of work, and authors are most strongly encouraged to avoid doing any of
  it by instead using the <code>input</code> element, the <code>textarea</code> element, or the
  <code data-anolis-xref="attr-contenteditable">contenteditable</code> attribute.</p>


  <h6 id="examples"><span class="secno">1.1.22 </span>Examples</h6>

  <p><i>This section is non-normative.</i></p>

  <div class="example">

  <p>Here is an example of a script that uses canvas to draw <a href="data:text/html;charset=utf-8;base64,PCFET0NUWVBFIEhUTUw%2BDQo8aHRtbCBsYW5nPSJlbiI%2BDQogPGhlYWQ%2BDQogIDx0aXRsZT5QcmV0dHkgR2xvd2luZyBMaW5lczwvdGl0bGU%2BDQogPC9oZWFkPg0KIDxib2R5Pg0KPGNhbnZhcyB3aWR0aD0iODAwIiBoZWlnaHQ9IjQ1MCI%2BPC9jYW52YXM%2BDQo8c2NyaXB0Pg0KDQogdmFyIGNvbnRleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJylbMF0uZ2V0Q29udGV4dCgnMmQnKTsNCg0KIHZhciBsYXN0WCA9IGNvbnRleHQuY2FudmFzLndpZHRoICogTWF0aC5yYW5kb20oKTsNCiB2YXIgbGFzdFkgPSBjb250ZXh0LmNhbnZhcy5oZWlnaHQgKiBNYXRoLnJhbmRvbSgpOw0KIHZhciBodWUgPSAwOw0KIGZ1bmN0aW9uIGxpbmUoKSB7DQogICBjb250ZXh0LnNhdmUoKTsNCiAgIGNvbnRleHQudHJhbnNsYXRlKGNvbnRleHQuY2FudmFzLndpZHRoLzIsIGNvbnRleHQuY2FudmFzLmhlaWdodC8yKTsNCiAgIGNvbnRleHQuc2NhbGUoMC45LCAwLjkpOw0KICAgY29udGV4dC50cmFuc2xhdGUoLWNvbnRleHQuY2FudmFzLndpZHRoLzIsIC1jb250ZXh0LmNhbnZhcy5oZWlnaHQvMik7DQogICBjb250ZXh0LmJlZ2luUGF0aCgpOw0KICAgY29udGV4dC5saW5lV2lkdGggPSA1ICsgTWF0aC5yYW5kb20oKSAqIDEwOw0KICAgY29udGV4dC5tb3ZlVG8obGFzdFgsIGxhc3RZKTsNCiAgIGxhc3RYID0gY29udGV4dC5jYW52YXMud2lkdGggKiBNYXRoLnJhbmRvbSgpOw0KICAgbGFzdFkgPSBjb250ZXh0LmNhbnZhcy5oZWlnaHQgKiBNYXRoLnJhbmRvbSgpOw0KICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGNvbnRleHQuY2FudmFzLndpZHRoICogTWF0aC5yYW5kb20oKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNhbnZhcy5oZWlnaHQgKiBNYXRoLnJhbmRvbSgpLA0KICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2FudmFzLndpZHRoICogTWF0aC5yYW5kb20oKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNhbnZhcy5oZWlnaHQgKiBNYXRoLnJhbmRvbSgpLA0KICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RYLCBsYXN0WSk7DQoNCiAgIGh1ZSA9IGh1ZSArIDEwICogTWF0aC5yYW5kb20oKTsNCiAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnaHNsKCcgKyBodWUgKyAnLCA1MCUsIDUwJSknOw0KICAgY29udGV4dC5zaGFkb3dDb2xvciA9ICd3aGl0ZSc7DQogICBjb250ZXh0LnNoYWRvd0JsdXIgPSAxMDsNCiAgIGNvbnRleHQuc3Ryb2tlKCk7DQogICBjb250ZXh0LnJlc3RvcmUoKTsNCiB9DQogc2V0SW50ZXJ2YWwobGluZSwgNTApOw0KDQogZnVuY3Rpb24gYmxhbmsoKSB7DQogICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuMSknOw0KICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjb250ZXh0LmNhbnZhcy53aWR0aCwgY29udGV4dC5jYW52YXMuaGVpZ2h0KTsNCiB9DQogc2V0SW50ZXJ2YWwoYmxhbmssIDQwKTsNCg0KPC9zY3JpcHQ%2BDQogPC9ib2R5Pg0KPC9odG1sPg0K">pretty glowing lines</a>.</p>

  <pre>&lt;canvas width="800" height="450"&gt;&lt;/canvas&gt;
&lt;script&gt;

 var context = document.getElementsByTagName('canvas')[0].getContext('2d');

 var lastX = context.canvas.width * Math.random();
 var lastY = context.canvas.height * Math.random();
 var hue = 0;
 function line() {
   context.save();
   context.translate(context.canvas.width/2, context.canvas.height/2);
   context.scale(0.9, 0.9);
   context.translate(-context.canvas.width/2, -context.canvas.height/2);
   context.beginPath();
   context.lineWidth = 5 + Math.random() * 10;
   context.moveTo(lastX, lastY);
   lastX = context.canvas.width * Math.random();
   lastY = context.canvas.height * Math.random();
   context.bezierCurveTo(context.canvas.width * Math.random(),
                         context.canvas.height * Math.random(),
                         context.canvas.width * Math.random(),
                         context.canvas.height * Math.random(),
                         lastX, lastY);

   hue = hue + 10 * Math.random();
   context.strokeStyle = 'hsl(' + hue + ', 50%, 50%)';
   context.shadowColor = 'white';
   context.shadowBlur = 10;
   context.stroke();
   context.restore();
 }
 setInterval(line, 50);

 function blank() {
   context.fillStyle = 'rgba(0,0,0,0.1)';
   context.fillRect(0, 0, context.canvas.width, context.canvas.height);
 }
 setInterval(blank, 40);

&lt;/script&gt;</pre>

  </div>

  

<!--FIXUP 2dcontext -4-->
  <h2 class="no-num" id="references">References</h2><!--REFS-->

  <p>All references are normative unless marked "Non-normative".</p>

  <!-- Dates are only included for standards older than the Web, because the newer ones keep changing. -->

  <dl>
<!--REFERENCES ON-->

   <!-- (rather a dubious reference; let me know if you know a better one) -->

   <dt id="refsARIA">[ARIA]</dt>
   <dd><cite><a href="http://www.w3.org/WAI/PF/aria/">Accessible Rich Internet Applications (WAI-ARIA)</a> (URL: <a href="http://www.w3.org/WAI/PF/aria/">http://www.w3.org/WAI/PF/aria/</a>)</cite>, J. Craig, M. Cooper, L. Pappas, R. Schwerdtfeger, L. Seeman. W3C.</dd>

   <dt id="refsBEZIER">[BEZIER]</dt>
   <dd><cite>Courbes à poles</cite>, P. de Casteljau. INPI, 1959.</dd>

   <dt id="refsCOMPOSITE">[COMPOSITE]</dt>
   <dd><cite><a href="http://dev.w3.org/fxtf/compositing/">Compositing and Blending</a> (URL: <a href="http://dev.w3.org/fxtf/compositing/">http://dev.w3.org/fxtf/compositing/</a>)</cite>. R. Cabanier, N. Andronikos. W3C.</dd>

   <!-- really should be "NARUSE, Y." or some such, but there's a western bias to these references for consistency. sorry. -->

   <dt id="refsCSS">[CSS]</dt>
   <dd><cite><a href="http://www.w3.org/TR/CSS2/">Cascading Style Sheets Level 2 Revision 1</a> (URL: <a href="http://www.w3.org/TR/CSS2/">http://www.w3.org/TR/CSS2/</a>)</cite>, B. Bos, T. Çelik, I. Hickson, H. Lie. W3C.</dd>

   <dt id="refsCSSCOLOR">[CSSCOLOR]</dt>
   <dd><cite><a href="http://dev.w3.org/csswg/css3-color/">CSS Color Module Level 3</a> (URL: <a href="http://dev.w3.org/csswg/css3-color/">http://dev.w3.org/csswg/css3-color/</a>)</cite>, T. Çelik, C. Lilley, L. Baron. W3C.</dd>

   <dt id="refsCSSFONTLOAD">[CSSFONTLOAD]</dt>
   <dd><cite><a href="http://dev.w3.org/csswg/css-font-loading/">CSS Font Loading</a> (URL: <a href="http://dev.w3.org/csswg/css-font-loading/">http://dev.w3.org/csswg/css-font-loading/</a>)</cite>, T. Atkins. W3C.</dd>


   <dt id="refsCSSFONTS">[CSSFONTS]</dt>
   <dd><cite><a href="http://dev.w3.org/csswg/css3-fonts/">CSS Fonts</a> (URL: <a href="http://dev.w3.org/csswg/css3-fonts/">http://dev.w3.org/csswg/css3-fonts/</a>)</cite>, J. Daggett. W3C.</dd>

   <dt id="refsCSSIMAGES">[CSSIMAGES]</dt>
   <dd><cite><a href="http://dev.w3.org/csswg/css-images/">CSS Image Values and Replaced Content Module</a> (URL: <a href="http://dev.w3.org/csswg/css-images/">http://dev.w3.org/csswg/css-images/</a>)</cite>, E. Etemad, T. Atkins. W3C.</dd>

   <dt id="refsCSSOM">[CSSOM]</dt>
   <dd><cite><a href="http://dev.w3.org/csswg/cssom/">Cascading Style Sheets Object Model (CSSOM)</a> (URL: <a href="http://dev.w3.org/csswg/cssom/">http://dev.w3.org/csswg/cssom/</a>)</cite>, S. Pieters, G. Adams. W3C.</dd>

   <dt id="refsCSSUI">[CSSUI]</dt>
   <dd><cite><a href="http://dev.w3.org/csswg/css3-ui/">CSS3 Basic User Interface Module</a> (URL: <a href="http://dev.w3.org/csswg/css3-ui/">http://dev.w3.org/csswg/css3-ui/</a>)</cite>, T. Çelik. W3C.</dd>

            <!--
   <dd><cite><a href="http://dom.spec.whatwg.org/">DOM</a></cite>, A. van Kesteren, A. Gregor, Ms2ger. WHATWG.</dd>
   -->
   <dt id="refsECMA262">[ECMA262]</dt>
   <dd><cite><a href="http://people.mozilla.org/~jorendorff/es6-draft.html">ECMAScript Language Specification</a> (URL: <a href="http://people.mozilla.org/~jorendorff/es6-draft.html">http://people.mozilla.org/~jorendorff/es6-draft.html</a>)</cite>. ECMA.</dd>

   <!--
   <dd><cite><a href="http://encoding.spec.whatwg.org/">Encoding</a></cite>, A. van Kesteren, J. Bell. WHATWG.</dd>
   -->
   <!-- http://www.iana.org/assignments/charset-reg/GBK -->

   <!--
   This book ("Computer Graphics: Principles and Practice in C") apparently does not make any
   references to literature in the bibliographic section to define the "even-odd" rule for polygon
   filling and hit testing. In the absence of such a reference, I guess that this book is the most
   authoritative reference.
   -->

   <dt id="refsHTML5">[HTML5]</dt>
   <dd>
   <cite><a href="http://www.w3.org/TR/html5/">HTML5</a> (URL: <a href="http://www.w3.org/TR/html5/">http://www.w3.org/TR/html5/</a>)</cite>,
   R. Berjon, T. Leithead, E. Doyle Navara, E. O'Connor, S. Pfeiffer. W3C.</dd>

   <!-- too many editors to list -->

   <!-- search for ["bytes are removed from this buffer at a rate defined by sb_leak_rate"] to find it -->

   <!-- search for ["Box Structure was and subsequent clauses were re-organized"] to find it -->

   <!-- for text/plain and "Internet Media type"; not for definition of "valid MIME type". -->

   <dt id="refsSVG">[SVG]</dt>
   <dd><cite><a href="http://www.w3.org/TR/SVGTiny12/">Scalable Vector Graphics (SVG) Tiny 1.2 Specification</a> (URL: <a href="http://www.w3.org/TR/SVGTiny12/">http://www.w3.org/TR/SVGTiny12/</a>)</cite>, O. Andersson, R. Berjon, E. Dahlström, A. Emmons, J. Ferraiolo, A. Grasso, V. Hardy, S. Hayman, D. Jackson, C. Lilley, C. McCormack, A. Neumann, C. Northway, A. Quint, N. Ramani, D. Schepers, A. Shellshear. W3C.</dd>

   <dt id="refsTOUCH">[TOUCH]</dt>
   <dd><cite><a href="https://dvcs.w3.org/hg/webevents/raw-file/v1/touchevents.html">Touch Events</a> (URL: <a href="https://dvcs.w3.org/hg/webevents/raw-file/v1/touchevents.html">https://dvcs.w3.org/hg/webevents/raw-file/v1/touchevents.html</a>)</cite>, D. Schepers, S. Moon, M. Brubeck, A. Barstow. W3C.</dd>

   <dt id="refsWEBIDL">[WEBIDL]</dt>
   <!--
   <dd><cite><a href="http://www.w3.org/TR/WebIDL/">Web IDL</a></cite>, C. McCormack. W3C.</dd>
   -->
   <dd><cite><a href="http://dev.w3.org/2006/webapi/WebIDL/">Web IDL</a> (URL: <a href="http://dev.w3.org/2006/webapi/WebIDL/">http://dev.w3.org/2006/webapi/WebIDL/</a>)</cite>, C. McCormack. W3C.</dd>

   <!--
   <dd><cite><a href="http://www.w3.org/TR/XMLHttpRequest/">The XMLHttpRequest
   Object</a></cite>, A. van Kesteren, J. Aubourg, J. Song, H.R.M. Steen. W3C.</dd>
   -->
   <!--(once XSLTProcessor is defined somewhere, update this and the place that references this)
   <dt id="refsXSLTP">[XSLTP]</dt>
   <dd>(Non-normative) <cite><a href=""></a></cite>, . .</dd>
-->

<!--REFERENCES OFF-->
  </dl>


</body></html>
